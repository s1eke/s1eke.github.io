{"meta":{"title":"S1eke's Blog","subtitle":"I'm curious.","description":null,"author":"Sean Fang","url":"https://blog.jugg.xyz","root":"/"},"pages":[{"title":"Timeline","date":"2024-03-11T18:14:54.495Z","updated":"2024-03-11T18:14:54.495Z","comments":false,"path":"Timeline/index.html","permalink":"https://blog.jugg.xyz/Timeline/index.html","excerpt":"","text":"@timeline{ 2017@item{ 7月10日更换主题为 indigo。 } @item{ 5月14日博客初步搭建，采用 git+hexo+nginx。 } 2018@item{ 4月3日全面抛弃 sm.ms 图床，全站转向腾讯云 COS+CDN 存储业务。 } @item{ 4月4日已添加 PWA 支持。 } @item{ 4月13日已删除 AMP 支持。 } @item{ 4月22日评论系统从 disqus 迁移到 valine。 } }"},{"title":"","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":false,"path":"categories/index.html","permalink":"https://blog.jugg.xyz/categories/index.html","excerpt":"","text":""},{"title":"","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"about/index.html","permalink":"https://blog.jugg.xyz/about/index.html","excerpt":"","text":"关于我 Dota2 天梯两千分鱼苗 专科咸鱼，沉迷于 Hello, World 业余运维，摸鱼为生"},{"title":"旅游学笔记（一）","date":"2018-04-12T01:37:29.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"discard/Tourism-principles-and-practice-1.html","permalink":"https://blog.jugg.xyz/discard/Tourism-principles-and-practice-1.html","excerpt":"","text":"旅游学旅游学的定义和特点 旅游三要素：旅游主题、旅游客体、旅游媒体。 旅游学是以旅游现象中的基本矛盾为研究对象，以旅游三要素及其相互关系为核心，探索旅游活动发展规律和旅游业运行关系及其对社会、经济、环境影响的学科。 旅游学具有跨学科和多学科的特点，设计社会、经济、文化许多领域。 旅游学还没有形成独立、完整的学科体系。研究的独特语言体系还没有规范，研究的方法论体系也还未形成，这是一个新兴学科。 掌握旅游的框架体系及其内涵*基于多学科的框架体系主动向其他学科扩展和渗透，大量吸取相关学科的养分来丰富和完善自己。多学科的旅游学框架体系就是对经济学、管理学、文学、史学、心理学、地理学、社会学等众多与旅游相关学科的基本理论和研究方法进行借鉴和延伸，将它们集聚起来并融为一体，形成新的旅游多学科基本框架和分支体系。 该框架体系的意义是创造性的提出了旅游学科体系建立的基础和方法，即交叉学科&rarr;多学科&rarr;跨学科&rarr;新学科。 基于雷珀模型的旅游学框架体系雷珀模型有三个要素：1、旅游者。2、地理区域。3、旅游业。这三个要素都是互相关联的，这也是一个很重要的旅游研究原理。雷柏模型非常巧妙的整合了一次旅游过程的全过程，这也反映了他的普遍性。 雷珀模型 理解旅游学的研究对象与研究内容旅游的研究对象对旅游活动所引起的基本矛盾以及发展规律的探索，就是旅游学特定的研究对象和研究范畴。 旅游学的研究内容 旅游学研究的基本内容 掌握旅游学的基本研究方法和体系* 旅游研究方法体系结构图 了解旅游学研究的相关理论和实践问题国外旅游研究的相关理论 Gouglas G. Pearce(1979)提出了旅游地理学的六个研究层面————供应空间、需求空间、旅游地理、运动与流动模式、旅游影响、旅游者的空间模型。 Neil Leiper(1979)提出了旅游体系框架，将旅游活动分为旅游者、客源产生地、旅游途径地、旅游目的地、旅游业五个要素。 RenG Baretje(1982)认为，旅游账户的收支平衡不是对旅游经济活动的最好测量，应该以旅游外部账户来代替旅游账户，以利于制定更恰当的旅游政策。 Donald Getz(1983)根据旅游的吸引力( Capacity to Absorb Tourism )概念，提出了旅游战略规划模型，包括建立目标、影响评价、有极限的最佳利用。 Joseph D. Fridgen(1984)分析了环境心理学和旅游学的关系，提出了旅游五阶段框架————旅游预期、旅行到目的地、旅游现场( On-site )行为、返回居住地旅行、回忆。 Sung Soo Pyo 等(1991)提出了美国国内旅游需求的线性开支模型，认为在交通、住宿、饮食、娱乐和其他服务中，交通花费是最价格最敏感的旅游因子，减少旅游预算的最好方法是减少交通费而非食宿支出。 Tae-Hee Lee &amp; John Crompton(1992)从惊恐、与日常经验的差异、减轻疲倦、惊奇等 4 个方面和 21 个指标测量了旅游新奇性。 Alf H. Walle(1997)探讨了旅游研究中的定性和定量方法，认为由于旅游现象的复杂性，严格的科学方法并不是总是用于旅游问题。 Svend Lundtorp &amp; Stephen Wanhill(2002)认为，原有的生命周期模型没有考虑到其潜在的发生过程，旅游者数量岁时间变化的模式导致了旅游地生命周期的变化，由此可以发展为规划旅游地生命周期的五个阶段。 此外，还有旅游知识获得模型、城市文化旅游承载力模型、后工业旅游动机和感知模型、目的地选择实验性分析模型、旅游合作伙伴演化模型等各种各样的研究成果。 国外旅游研究方法国外在旅游学的研究方法上重视定量分析和定性结合。主要有 Box Jenkins 方法、现场方法（访问、观察、记数）、Archer 的旅游乘数方法、随机时间序列模型、受控对比法、线性因子方法、空间分析法、多维尺度法、投入产出法、层次分析法、模糊线性规划法、元分析技术、最近邻域技术( Nearest-Neighbor Techniques )、神经网络法、多标准决策模糊法、聚类分析、单变量和双变量的谱分析、问卷法和德尔菲法。 国内旅游研究概述我国部分知名旅游院校和旅游研究机构、旅游出版单位于 2001 年发起成立了中国旅游学术论坛( China Tourism Academy, CTA )。该论坛是站在中国旅游学术研究前沿，以推动多学科、跨学科研究旅游现象为目标的民间性纯学术组织。 把握旅游学研究的未来趋势 注重人文关怀, 重视可持续发展观点。 注重旅游研究的信息化发展。 旅游掌握古代旅游、近代旅游、现代旅游产生和发展的主要原因和特征*古代旅游人类早期的迁徙活动从本质上说，迁徙是不具有移动目的的休闲性、移动时间的暂定性和移动空间的异地性三个旅游基本属性。因此人类早期出现的迁徙活动不属于旅游的范畴。 古代的旅行活动古代的旅行是人类史上三次社会大分工的产物。主要目的为交换产品和贸易经商。 古代的旅游活动古代的旅游始于奴隶制社会的早期，一直延续到 19 世纪封建社会的末期，是古代人以休闲和愉悦为主要目的、离开自己的居住地、到异地游览后返回的新型旅行方式。 古代西方旅游 古代商务旅游：腓尼基人、马克·波罗 古代航海冒险旅游：哥伦布、麦哲伦 古代宗教旅游：释迦摩尼、麦加圣地 古代修学旅游：艾布·哈桑·阿里·马苏第、毕达哥拉斯 古代中国旅游 帝王巡游：秦始皇、隋炀帝 官宦旅游：孔子、张骞 国际贸易旅游：丝绸之路、郑和 宗教旅游：东晋法显、唐代玄奘 文化旅游：李白、司马迁 庶民节令旅游：春节庙会、元宵灯市 古代旅行发展的特点经商旅行是当时社会的主流，以休闲为目的的旅游在旅行活动中所占比例十分有限。 近代旅游西方近代旅游的产生和崛起 文艺复兴带来的思想解放和新价值观为旅游奠定了精神和文化的基础。 新技术在交通运输中的应用为近代旅游提供了原动力。 城市化和大规模的人员流动为近代旅游创造了巨大的客源市场。 国际贸易的大发展掀起了近代商贸旅游的高潮。 社会财富的增加和收入水平的提高为近代旅游奠定了坚实的物质基础。 近代旅游业的崛起满足了旅游需求并刺激了新的旅游欲望。 1931年，英国托马斯·库克( Thmoas Cook )旅游公司作为世界上第一家商业性的旅游机构诞生，从此结束了一个旧的旅游时代，开辟了近代旅游的新纪元，也标志着近代旅游业的开端。 中国近代旅游的产生和发展 中国近代旅游是被迫对外开放和一系列不平等条约的附属产物。这些不平等条约构成了旧中国扭曲的政治制度和失衡的经济关系，同时也催生了中国近代旅游需求。 外商在华投资和国际贸易的扩大使中国近代旅游迅速发展。 交通运输的发展为近代中国旅游提供了便利条件。 城市近代化为中国近代旅游发展开辟了广阔的空间。 近代旅游也得产生为中国近代旅游发展提供了供给能力。 持续的银本位制度刺激了近代中国旅游入境人数上升。 世界经济发展去式为中国近代旅游创造了有力的宏观条件 中国近代第一家旅行社、也是旧中国唯一的一家大型旅行社是1923年上海商业银行创办的中国旅行社，创办者是陈光甫。 现代旅游大众旅游阶段 大众旅游的特点：大众参与性、全球普及性、规划标准化。 大众旅游面临的问题：旅游目的地盲目的开发相同的景点、公园、服务、商场，使旅游的多样性和差异性退化消失；大众旅游带来大规模的客流量，使许多目的地的交通拥挤，景区人满为患，不仅造成了对旅游资源的破坏，而且引起了当地居民的反感和憎恨；旅游业管理不善，造成环境污染；地方民俗的过度商业化减弱了地方文化的真实性及其对旅游者的吸引力；游客的不文明行为导致许多有价值的文物古迹的损毁。 大众旅游的定义：大众旅游是以固定的价格、标准化的服务，大批量销售给大众顾客的包价旅游。 新旅游阶段新旅游的定义普恩( poon, 1993 )对新旅游( New Tourism )的定义是：新旅游产品是灵活的，可与标准化批量生产的产品在价格上竞争；新旅游产品的生产不再取决于规模经济，而是在生产过程中兼顾规模经济和满足不同游客的特殊需求、提供量身定做的个性化旅游产品；新旅游产品的生产更多地受消费者不同需求的驱动；新旅游产品的促销手段也因旅游者需求、收入、时间和兴趣的不同而异，大众化营销模式不再占主导地位；新旅游产品仍会被旅游者大量消费，但这个消费群体更有经验、受过更多的教育、更能为旅游目的地照相、更独立、更灵活、更环保；旅游者会把目的地的环境和文化视为旅游体验的一个重要组成部分。 新旅游的形成和发展原因 新生产方式使个性化的产品替代了标准化产品； 新技术使人类社会进去了信息化时代； 新消费者使旅游行为更加理性和成熟； 新管理方式是柔性化和系统化的； 新环境因素使旅游发展面临新的挑战和压力。 新旅游的基本特征新旅游的需求特征： 需求主流转变 需求多样化 需求个性化 需求参与化 需求安全化 新旅游的供给特征： 旅游市场细分化 旅游经营网络化 旅游服务优质化 旅游管理知识化 旅游增长集约化 旅游发展可持续化 大众旅游与新旅游特征对比 大众旅游框架 新旅游框架 掌握从不同角度对旅游的定义方法*国内外学术界关于旅游的定义1. 艾斯特定义 瑞士学者汉泽克尔和克拉普夫( 1942 )对旅游的定义：“旅游是非定居者的旅行和暂时居留而引起的现象和关系的总和。这些人不会引起永久居留，并且不从事赚钱活动。”这个定义强调旅游的综合性，提出旅游活动中必将产生经济关系和社会关系。由于这个定义在 20 世纪 70 年代为旅游科学专家国际联合会( AIEST )所采用，因此被称为艾斯特( AIEST )定义，是国际上一直被普遍接受的旅游定义。 2. 交往定义 德国的蒙根·罗德( 1927 )对旅游的定义：“旅游从狭义的理解是那些暂时离开自己的住地，为了满足生活和文化的需要，或各式各样的愿望，而作为经济和文化商品的消费者逗留在异地的人的交往”该定义强调旅游是一种社会交往活动。 3. 目的定义 奥地利维也纳经济大学旅游研究所对旅游的定义：“旅游可以理解为是暂时在异地的人的空余时间活动，主要是出于修养；其次是出于受教育，扩大知识和交际的原因的旅行；再次是参加这样或那样的组织活动，以及改变有关的关系和作用。”该定义强调了旅游的基本目的是消遣和增长知识。 4. 流动定义 英国学者波卡特和梅特列克( 1974 )对旅游的定义：“旅游发生于人们前往和逗留在各种旅游地的活动，是人们离开他平时居住和工作的地方，短期暂时前往一个旅游目的地和逗留在该地的各种活动。”该定义强调旅游的本质特征是异地性和暂时性。 5. 时间定义 美国通用大西洋有限公司的马丁·普雷博士( 1979 )对旅游的定义为：“旅游是为了消遣而进行旅行，在某一个国家逗留的时间至少超过 24 小时。”该定义强调了各国在进行国际旅游者统计时的标准之一是逗留的时间。 6. 关系定义 美国密执安大学的伯特·麦金托什和夏西肯特·格伯特( 1980 )对旅游的定义：“旅游可以定义为在吸引和接待旅游及其访问者的过程中，由于旅客、旅游企业、东道政府及东道地区的居民的相互作用而产生的一切现象和关系的总和。”该定义强调了旅游所引发的各种现象和关系。 7. 生活方式定义 我国经济学家于光远( 1985 )对旅游的定义：“旅游是现代社会中居民的一种短期性的特殊生活方式，这种生活方式的特点是：异地性、业余性和享受性。”该定义强调了旅游是一种生活方式，并指出异地性、业余性和享受性是旅游的主要特点。 8. 技术定义 世界旅游组织( 1995 )对旅游的定义：“旅游是人们为了休闲、商务和其他目的，离开他们惯常的环境，到某些地方去以及在那些地方停留的活动，暂时停留时间不超过一年，且访问的主要目的不应该是通过所从事的活动从访问地获取报酬。”该定义是世界旅游经济组织出于统计目的所制定的 5 本技术手册之一中对旅游的定义。 9. 体验定义 我国学者谢彦君( 2004 )对旅游的定义：“旅游是个人以前往异地寻求愉悦为主要目的而度过的一种具有社会、休闲和消费属性的短暂经历。”该定义强调旅游是一种享受异地愉悦和体验的短暂经历。 总结 上述对旅游的定义表达方式虽然不同，但是大体可以分为两类： 第一类是旅游的概念性定义( Conceptual Definition )，即为了规范人们对旅游的本质认识，从理论上对旅游现象进行抽象和概括，如定义 1、2、3、4、6、7、9。 第二类是旅游的技术性定义( Technical Definition )，即为了使旅游调查和统计具有可操作性，从某些具体指标上对旅游现象进行界定，如定义 5、8。 从供需角度对旅游的定义从需求角度定义旅游旅游的概念性定义为：旅游是人们为了休闲、商务和其他目的，离开自己的常居环境，连续不超过一年的旅行和逗留活动（世界旅游组织和联合国统计部署，1994)。 旅游的技术性定义： 旅游旅游最短的逗留时间为一夜，未过夜的游客被成为当日游者或短途游者； 旅游最长的逗留时间为一年； 严格按照旅游的目的来划分旅游类型； 对旅游距离的认定通常以“常居环境”范围为依据，世界旅游组织建议的距离使离开常居环境 160 公里。 从供给角度定义旅游雷珀从供给的角度对旅游的概念性定义是特质旅游业；对旅游的技术性定义是：旅游业是由为满足旅游者需求和愿望而提供产品和服务的所有企业、机构和设施构成的产业( 1979,p400 )。 界定的方法是将旅游业分成两个层类：第一层类是离开旅游不能生存的企业（如航空公园、酒店、国家公园），第二层类是离开旅游能够生存，但规模会缩小的企业（如餐饮企业、计程车、当地旅游景点）。 对旅游的界定 旅游具有异地性：离开自己的常居地到异地活动； 旅游局有暂时性：不在异地进行永久居留； 旅游具有目的性：不涉及任何赚钱和移民活动； 旅游具有时间性：24小时以上、一年以内； 旅游具有综合性：可以引发各种现象和关系。 掌握旅游系统的构成和特征*旅游系统的构成要素和分析 旅游系统构成要素图 旅游客源地系统：客源地系统由现实和潜在的具有旅游动机、可自由支配收入、闲暇时间和健康体魄的旅游者构成。 旅游目的地系统：旅游目的地系统通常由旅游吸引物、旅游设施和旅游服务三要素组成。 旅游通道系统：旅游通道系统由有形的旅游交通通道和无形的旅游信息通道组成。 旅游支持系统：旅游支持系统由政策、制度、环境、人才、社区、科技、安全、体制等因素组成。 旅游系统的基本特征 整体性：旅游系统的整体性指单独的四个子系统不能实现旅游的基本功能。 层次性：旅游系统的层次性指旅游系统由不同等级的子系统构成。 复杂性：旅游系统的复杂性指系统内部各组成部分之间具有牵一发而动全身的特性。 开放性：旅游系统的开放性指系统与外部环境之间具有物质、能量和信息的双向交流。 动态性：旅游系统的动态性指旅游系统的发展变化性，无论是客源地还是目的地和旅游通道，都在处于不断的发展变化中。 地域性：旅游系统的地域性指旅游系统分布的不平衡性和跨地域性。 掌握旅游系统的分类方法和基本类型*旅游的分类国境、国界分类标准 国际旅游：国际旅游是指游客从自己的定居国或常住国跨越国界到另一个或好几个国家的旅游活动。 国内旅游：国内旅游时指离开游客自己的定居地或常住地在本国内的其他一个或几个地方的旅游活动。 两者的差异： 停留时间不同。 便利程度不同。 经济作用不同。 消费总量不同。 文化影响不同。 地理区域分类标准 国际：世界旅游组织按洲际把旅游分为欧洲旅游、每美洲旅游、非洲旅游、中东旅游、南亚旅游、东亚及太平洋地区旅游等 6 类。 国内：国内旅游可分为全国旅游、区域旅游、地方旅游、远程旅游、近程旅游和周边旅游等 组织形式分类标准 团体旅游：又称包价旅游，是指参加旅行社或其他旅游组织事先计划、统一组织、精心编排旅游项目、提供相关服务并以包价形式一次性收取费用的旅游形式。 散客旅游：又称个人旅游，是相对团体旅游而言的个体、家庭或 15 人以下自行结伴的旅游活动。 费用来源分类标准 自费旅游：自费旅游是指全部旅游费用都由自己承担的旅游活动。 社会旅游：社会旅游是指享受社会给予福利性补贴的旅游活动。 奖励旅游：奖励旅游是指获得的以参加旅游活动作为奖品和激励的旅游方式。 访问的目的分类标准 休闲和消遣旅游：休闲和消遣旅游包括观光、度假、体育运动、文化旅游和探亲访友等旅游形式。 商务和专业旅游：商务和专业旅游包括会议、谈判、使团、奖励和经商旅游。 持有其他目的的旅游：包括修学旅游、宗教旅游、科学考察旅游、考古旅游、探险旅游、寻根祭祖旅游、美食购物旅游、医疗保健旅游等。 吸引物分类标准以旅游吸引物的性质为标准可划分海滨旅游、温泉旅游、森林旅游、山川旅游、江河湖泊旅游、冰雪旅游、乡村旅游、都市旅游、民族风情旅游、美食旅游、主题公园旅游等。 其他分类标准除了上述 6 种分类标准之外，还可使用交通方式标准、年龄标准、性别标准、付费方式标准、身份地位标准、参与程度标准、享受程度标准、消费水平标准等对旅游的类型进行超细分。 旅游的本质属性 社会综合本质属性：旅游是一项内容丰富、形式多样，涉及社会、经济、政治、文化、科技等各种因素的高度综合性活动。 经济消费本质属性：旅游产生了经济基础和消费行为的同事，还是一种特殊的生产行为。 国际政治本质属性：在国际交往中，旅游素有民间外交的美称。欧共体在建立欧洲联盟时达成了欧盟成员国人员来往互相免签证的协议。 生活方式本质属性：旅游是人类社会发展的基本属性之一。 旅游者掌握国际和国内旅游者的技术定义和概念性定义*对旅游者的技术性定义国际旅游者的技术性定义 国际联盟统计专家委员会对国际旅游者的定义：离开自己的居住国，到另一个国家访问至少 24 小时的人。 罗马会议对国际旅游者的定义：除了为获得有报酬的职业目的以外，基于任何原因到一个不是自己常住的国家进行观光和访问的人员。 世界旅游组织对国际旅游者的定义：国际旅游者是指在目的国住宿设施中至少度过一夜的游客；短程国际游览者是指未在目的国住宿设施中过夜的游客，其中包括多日居住在巡游船上、上岸游览的游船乘客。 中国对国际旅游者的定义：指任何一个因休闲、娱乐、观光、度假、探亲访友、就医疗养、购物、参加会议或从事经济、文化、体育、宗教活动，离开常住国到其他国家，连续停留时间不超过12个月，并且在其他国家或地区的主要目的不是通过所从事的活动获取报酬的人。 国内旅游者的技术性定义 世界旅游组织对国内旅游者的定义：任何以消闲娱乐、度假、体育活动、商务、公务、会议、疗养、学习和宗教为目的，而在自己定居的国内，不论国籍如何，对某个旅游目的地进行24小时以上，一年以内访问的人员，均可视为国内游客。 北美和欧洲国家对国内旅游者的定义： ● 美国对国内旅游者的定义：旅游者是指为了出差、消遣、个人事务、或者出于工作上下班之外的其他任何原因而离家外出旅行至少50英里（约 80 千米）的人员，而不管其在外过夜还是当日返回。 ● 加拿大对国内旅游者的定义：旅游者是指到距离其居住地边界至少50英里以外的地方去旅行的人员。 ● 英国对国内旅游者的定义：基于上下班以外的任何原因，离开居住地外出旅行过夜至少一次的人员。 ● 法国对国内旅游者的定义：基于消遣、健康、出差或参加各种形式的会议、商务旅行、改变课堂教学的修学旅行，外出旅行超过 24 小时但未超过 4 个月的人员。 中国对国内旅游者的定义：指我国大陆居民离开常住地在境内其他地方的旅游住宿设施内至少停留一夜，最长不超过 6 个月的人员。国内旅游者应包括在我国境内居住一年以上的外国人和港澳台同胞，但不包括到各地巡视工作的部级以上领导、驻外地办事机构的临时工作人员、调遣的武装人员、到外地学习的学生、到基层锻炼的干部、到境内其他地区定居的人员和无固定居住地的无业游民。 对旅游者的概念性定义旅游者是离开常住地前往异国他乡做短暂停留，寻求生理和心理满足、实现愉悦过程的人。 旅游者的本质属性：短暂性、异地性、主动性、愉悦性。 掌握国际和国内旅游者的统计范围和方法*国际旅游者的统计范围和方法 国际旅客的统计范围 对国际旅游者的统计可使用： 旅游人次数 = 旅游者人数 * 每个旅游者的旅游次数 国内旅游者的统计范围和方法 国内旅客的统计范围 国内旅游者统计的计算公式与国际旅游者相似。由于收集国内游客的信息比较困难，可以使用旅游者家庭调查、旅游者旅途中调查、旅游目的地游客调查和对旅游供应商调查等常见手段。 掌握常见的旅游者类型、特点及其分类方法*观光型旅游者及其特点观光型旅游者是最基本、最普通的一种旅游者类型，是旅游者以游山玩水为方式，到异国他乡观赏自然风光、城市风貌、名胜古迹、社会风情等，达到增长知识、扩大阅历、陶冶情操，获得新、奇、美的享受的旅游目的。其特点如下： 旅游者对自然风光和人文景观吸引物以静态观赏为主，在旅游活动中缺乏参与性和较流行； 旅游者喜欢知名度高、形象好的观光目的地； 旅游者在旅游目的地的活动空间和自由选择度大； 旅游者在目的地的逗留时间短，重游率低； 旅游者的流动性大，在旅游目的地的消费水平低； 旅游者受气候的影响大，旅游淡旺季十分明显； 旅游者出行团队形式多，对价格比较敏感。 休闲度假型旅游者及其特点休闲度假型旅游者是指以休闲、度假、疗养、消除疲惫、增进健康为活动内容的旅游者。其特点如下： 对旅游地的自然环境条件有明确的选择，旅游者喜欢气候温和、阳光充足、环境优雅、空气清新、远离噪音的地方； 旅游者对旅游目的地的设施有较高的选择，很注意是否有相关的健身、疗养、运动场所和设备； 停留时间长，重游率高，一次去几个度假目的地停留不同的时间； 旅游者一般为高收入者，休闲消费水平较高，对价格不敏感； 对服务质量要求高，为了健康和愉悦，愿意花钱买健康、花钱买舒适。 文化科普性旅游者及其特点文化科普性旅游者指以鉴赏异国异地传统文化、追寻文化名人遗迹、参加当地举办的各种文化活动为目的的旅游者。其主要特点是： 旅游者一般具有较高的文化修养，求知欲望强； 旅游者一般具有特殊兴趣和某种专长，希望在旅游活动中能与同行交流并得到知识和专业的提高； 旅游者需要相对特殊的服务和接待方式，对导游的水平和专业知识要求较高； 旅游者要求旅游线路具有文化科普内涵和连续性，喜欢重游和深游层数，以满足探索和钻研的需要。 消遣娱乐型旅游者及其特点消遣娱乐型旅游者以享受临时环境所带来的欢乐和消遣为主要目的。其主要特点是： 以松弛精神、享受环境变化所带来的欢愉为主要目的； 对旅游产品的质量、加个等比较敏感； 要求物有所值，消费水平较高； 季节性强，选择旅游地最好的季节出游； 在职人员都利用带薪假期出游； 在旅游地停留的时间根据旅游产品的类型和个人感受可长可短。 宗教朝觐型旅游者及其特点宗教朝觐型旅游者是以宗教朝觐为目的的特殊旅游者群体。其主要特点是： 旅游目的地和客流比较集中，一般都是世界著名的宗教圣地； 对接待设施和服务有特殊的要求，不能违反特定的宗教习俗和规定； 季节性弱，宗教朝觐时间性强，通常集中在每年 12 月份举行宗教仪式的时间。 家庭及个人事务型旅游者及其特点家庭及个人事务型旅游者是指以探亲访友、寻根问祖、出席节庆典礼活动、处理家庭事务为目的的旅游者。其特点是： 出游的季节选择性差，偶发性和时间限制性强； 因私自费消费，对价格敏感，需要经济实惠的服务和设施； 食宿亲朋好友处较多，使用目的地设施较少； 旅游需求因目的而各异和复杂，共同点较少，难以一概而论。 公务商务型旅游者及其特点公务商务型旅游者是由于工作事务需要而出行的旅游者，主要目的是经商贸易、出席会议、参加公务活动、进行交流等。其特点是： 出游率高，停留时间长，支付能力强； 季节性不明显，对目的地选择没有自由度，较少受价格变动影响； 会议旅游的计划性强，所需床位、餐位、交通、活动等可实现作出准备； 要求接待服务单位具有良好的场所、设施、通信、交通，要求舒适、方便、快捷、完备、高档。 其他旅游者类型和分类方法其他旅游者类型除了上述 7 种常见的旅游者类型之外，世界上还存在大量形形色色、五花八门的特殊旅游者群体，如探险旅游者、生态旅游这、狩猎旅游者、太空旅游者、仿古旅游者、两极旅游者、美食旅游者、购物旅游者、工业旅游者、乡村旅游者、新婚旅游者、金婚旅游者、银发旅游者、红色线路旅游者、逃避现实旅游者、寻找激情旅游者、高端旅游者等等。 其他旅游者分类方法 科恩的旅游者分类方法 科恩的旅游者分类方法 旅游者人口统计变量和出游要素分类方法：这个方法是通过旅游者在性格、社会人口特征、个人经历和旅游方式等方面的差异进行分类。 旅游者影响分类法：这种方法是根据旅游者与目的地之间相互影响程度和方式对旅游者进行分类。 熟悉旅游者产生的客观影响因素个人因素 收入和职业 闲暇时间 受教育程度 出行的机动性 种族和性别 家庭与角色 身体健康状况 家庭生命周期因素 休闲旅游矛盾交叉体 STEP 因素对旅游者产生影响的还有国家和社会的宏观因素，可以概括为 STEP 因素，即社会因素（S）、技术因素（T）、经济因素（E）、政治因素（P）。 其他影响因素 旅游的经济距离 旅游的文化距离 旅游目的地相对生活费用 掌握旅游者产生的主观影响因素*动机与马斯洛的需要层次模型人的动机通常来自于需要，是需要的表现形式，也是一个人从旁那个需要转化为行动的中间环节。冬季被付诸行动后，就会以行动的结果来满足需要并释放动机。 行为发生的心理过程模式 马斯洛的需要层次模型将一个人的需要排列成阶梯层次状。他将动机分为两类，一类是确实冬季或缓解压力动机，另一类是诱发动机或追求刺激动机。 马斯洛的需要层次模型 了解旅游动机理论的主要内容丹恩( Dann )的旅游动机理论 旅游可以满足未能满足的欲望，认为旅游者受到这种欲望的驱动，希望外出体验与家居环境不同的事物。 旅游目的地的拉力可以对应旅游者动机的推力，这样可以对旅游者个人动机的期望水平（推力）和目的地或吸引物的拉力加以区别。 旅游动机是一种幻想，这种观点是前两个观点的子集，并认为旅游者出游是采取不受家庭环境和文化约束的行动。 旅游动机可按旅游目的地分类。一种宽泛的旅游动机分类是将旅游的主要目的当作旅游动机。 旅游动机分类。追寻阳光；追求“漫游”；旅游者角色分类法。 旅游动机对旅游者体验的真实性提出争议，以各类旅游者体验的可信度为依据。 动机可以自我解释并具有自我含义，认为描述旅游者状态比简单观察旅游者行为能更好地认识旅游动机。 麦金托什( McIntosh )的旅游动机理论麦金托什等学者( 1995 )通过研究将旅游动机归纳为4类： 身体健康动机 文化动机 人际交往动机 地位与声望动机 普洛格( Plog )的旅游动机理论普洛格( 1974 )将旅游者划分为一系列相关联的人格类型，这些类型分布于两个极端之间： 自我中心型：这种人格类型的人重视生活中的琐事。他们趋向于保持原有的旅游方式，更喜欢去安全的熟悉的旅游目的地，并经常进行故地重游。 多中心型：这种人格类型的人喜欢冒险，抱游览会发现新旅游目的地的动机。他们很少去一个地方两次。 大多数人属于普洛格所指出的两个极端之间的中间类型。 对旅游动机理论的总结 旅游最初与需要先关，是个人需要的表现。动机推力时产生旅游行为的驱动力； 动机是从社会学到心理学种习得的准则、态度、文化、认知的基础上产生的，这些方面导致一个人具有特定的冬季模式； 通过多种沟通渠道树立的目的地形象将对旅游动机产生影响，之后对旅游行为产生影响。 动机产生的心理动因 求新心理 逃避心理 学习心理 发展心理 目的地形象 目的地形象的概念：世界旅游组织对目的地形象的定义是“个人或团体对目的地的看法和构想”。 目的地形象的作用：目的地形象是影响旅游者出游的重要的决策因素之一。如果目的地不能再旅游者心中形成独特鲜明的感知形象，就会影响潜在的旅游者。 目的地形象的树立：来自社会上各方面信息的总和组成了目的地的本色形象，通过旅游相关的各类机构有意的宣传和促销树立了目的地的诱导形象。 了解消费者行为分析模型的主要内容 韦哈布、克拉姆珀和罗森菲尔德( Wahab, Crampon &amp; Rothfield )的模型 斯莫尔( Schmoll )的模型 梅奥和贾维斯( Mayo &amp; Jarvis )的模型 马西森和沃尔( Mathieson and Wall )的模型 莫斯卡多等人( Moscardo et al. )的模型"},{"title":"管理学","date":"2018-04-26T14:41:24.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"discard/Management.html","permalink":"https://blog.jugg.xyz/discard/Management.html","excerpt":"","text":"管理活动与管理理论掌握管理的定义和职能*定义：管理是指组织为了达到个人无法实现的目标，通过各项职能活动，合理分配、协调相关资源的过程。 职能：决策与计划、组织、领导、控制、创新。 掌握管理者的角色与技能*亨利·明茨伯格( Henry Mintzberg )研究发现管理者扮演着十种角色，这十种角色可被归入三大类。 人际角色： 代表人 领导者 联络者 信息角色： 监督人 传播人 发言人 决策角色： 企业家 冲突管理者 资源分配者 谈判者 根据罗伯特·卡茨( Katz, 1974 )的研究，管理者要具备三类技能： 技术技能 人际技能 概念技能 熟悉中国早期管理思想中国古代管理思想在许多著作中都有体现，如《孙子兵法》、《周礼》、《墨子》、《老子》、《管子》、《齐民要术》、《天工开物》等。 了解外国早期管理思想 亚当·斯密( Adam Smith, 1723——1790 )劳动分工观点和经济人观点 小瓦特( James Watt Jr. ,1769——1848 )和博尔顿( Mattew R. Boulton, 1770——1842 )科学管理制度 马萨诸塞车祸与所有权和管理权的分离 欧文( Robert Owen, 1771——1858 )的人事管理 巴贝奇( Charles Babbag, 1782——1871 )的作业研究和报酬制度 亨利·汤( Henry R. Towne, 1844——1924 )的收益分享制度 哈尔西( Frederick A. Halsey, 1856——1935 )奖金方案 掌握泰罗科学管理理论、霍桑实验要点*泰罗科学管理理论： 工作定额 标准化：使工人掌握标准化的操作方法，使用标准化的工具、及其和材料，并使作业标准化。 能力与工作相适应 差别计件工资制 计划职能与执行职能相分离 霍桑实验： 第一阶段：工作场所照明试验 第二阶段：继电器装配实验室 第三阶段：大规模访谈 第四阶段：接线板接线工作试验 总结： 工人是社会人，而不是经纪人 企业中存在着非正式组织 生产率主要取决于工人的工作态度以及他和周围人的关系 熟悉法约尔一般管理理论要点，韦伯行政组织管理理论要点，人际关系学说要点，现在管理理论主要学派的基本观点法约尔的贡献任何企业都存在六种基本活动： 技术活动 商业活动 财务活动 安全活动 会计活动 管理活动 管理的 14 条原则： 分工 权利与责任 纪律 统一指挥 统一领导 个人利益服从集体利益 报酬合理 集权与分权 等级链与跳板 秩序 公平 人员稳定 首创精神 集体精神 韦伯行政组织管理理论行政组织管理理论的特点： 存在明确的分工 按等级原则对各种公职或指为进行法定安排，形成一个自上而下的指挥链或等级体系 根据经过正式考试或教育培训而获得的技术资格来选拔员工，并完全根据植物要求来任用 除个别需要通过选举产生的公职以外，所有担任公职的人都是任命的 行政管理人员是“专职的”管理人员，领取固定的“薪金”，由明文规定的升迁制度 行政管理人员不是其管辖的企业的所有者，只是其中的工作人员 行政管理人员必须严格遵守组织中的规则、纪律和办事程序 组织中成员之间的关系以理性准则为指导，不受个人情感的影响。 现代管理理论主要学派 数量管理理论内容：运筹学、系统分析、决策科学化 系统管理理论：系统管理理论指运用系统理论中的范畴、原理，对组织中的管理活动和管理过程，特别是组织结构和模式进行分析的理论。 权变管理理论：这一理论的核心是力图研究组织与环境的联系，并确定各种变量的关系类型和结构类型，他强调管理要根据组织所处的环境随机应变，针对不同的环境寻求相应的管理模式。 全面质量管理理论：全面质量管理的本质是由顾客需求和期望驱动企业持续不断改善的管理理论。 了解管理理论的新发展 学习型组织 精益思想 业务流程再造 核心能力理论 管理道德与企业社会责任了解伦理道德的内涵伦理的真谛是“本性上普遍的东西”。这种“本性上普遍的东西”被称为伦理性的实体，即伦理性的共同体。 熟悉伦理道德的管理学意义财富创造是一种道德行为。 企业管理一方面透过伦理道德建立个体与组织相统一的内部伦理关系。 任何企业产品的品质，早先决定于创办人的价值观，后来则决定于整个企业的工作价值观。 掌握基本的道德观 功利主义道德观：能给行为影响所及的大多数人带来最大利益的行为就是善的。 权力至上道德观：能尊重和保护个人基本权利的行为才是善的。 公平公正道德观：管理者不能因种族、肤色、性别、个性、个人爱好、国籍、户籍等因素对部分员工歧视，而那些按照同工同酬原则和公平公正的标准向员工支付酬薪的行为是善的。 社会契约道德观：只要按照企业所在地区政府和员工都能接受的社会契约所进行的管理行为就是善的。 推己及人道德观：己所不欲，勿施于人。 了解道德管理的特征道德管理具有以下七个特征： 合乎道德的管理不仅把遵守道德规范作为组织获取利益的一种手段，而且更会把其视作组织的一项责任。 合乎道德的管理不仅从组织自身角度更应从社会整体角度看问题。 合乎道德的管理尊重所有者以外的利益相关者的利益，善于处理组织与利益相关者的关系，也善于处理管理者与一般员工内部的关系。 合乎道德的管理不仅把人看作手段，更把人看作目的。组织行为的目的都是为了人。 合乎道德的管理超越了法律的要求，能让组织取得卓越的成就。 合乎道德的管理具有自律的特征。 合乎道德的管理以组织的价值观为行为导向。 熟悉影响管理道德的因素 道德发展阶段：道德发展要经历前惯例层次、惯例层次、原则层次三个阶段。随着阶段的上升，个人的道德判断越来越不受外部因素的影响。 个人特性：管理者的个人特性对组织的管理道德存有着直接的影响。这里所讲的个人特性主要是指管理者的个人价值观、自信心和自控力。 组织结构：组织内部机构和职责分工有没有必要的权力制衡、监察、检查、审计机制，有没有外部群众和舆论监督；组织内部有无明确的规章制度；上级管理行为的示范作用；绩效评估考核体系会起到指挥棒的作用。 组织文化：组织有无诚信、包容的组织文化对管理道德有重要影响。 问题强度：道德问题强度会直接影响管理者的决策。 掌握改善企业道德企业的途径 挑选高道德素质的员工 建立道德守则和决策规则 管理者在道德方面领导员工 设定工作目标 对员工进行道德教育 对绩效进行全面评价 进行独立的社会审计 提供正式的保护机制 了解企业价值观发展的历史阶段 工业化初期，企业处于资本原始积累阶段，企业价值观必然是追求股东利润最大化，到处都是残酷剥削工人的血汗工厂。 工业化中期，资本原始积累已基本完成，工人争取自身权益的群众运动风起云涌，为了求得社会稳定和维持工厂的正常生产秩序，或者为了更文明的提高生产绩效，企业逐步采取科学管理方法，更多地较为公平的兼顾到员工的利益。 工业化后期，追求企业相关利益者价值最大化。 后工业化时期：追求企业相关利益者价值最大化的同时还要保护和增进社会福利。 熟悉企业社会责任的体现 办好企业，把企业做强、做大、做久 企业一切经营管理行为应符合道德规范 社区福利投资 社会慈善事业 自觉保护自然环境 全球化与管理掌握全球化的内涵 在世界层面上，全球化是指国家之间日益增长的经济相互依赖性，反映在商品、服务、资本和信息等方面不断增长的跨过流通上。 在国家或地区层面上，全球化是指一个国家或地区的经济与世界其他领域之间的联系程度。 在产业层面上，全球化是指某一产业在全球范围内的扩张和活动，以及在全球国家或地区间相互依赖的程度。 在公司层面上，全球化是指公司在各国或地区的收入分而和资产扩展的程度，以及与各国或地区的资本、商品和信息的跨国&#x2F;地区交流程度。 了解全球化的环境因素全球化的一般环境政治与法律环境： 国家政治体制。 政治的稳定性。 政府对外来经营者的态度。 法律环境。 经济和技术环境：在全球范围内，经济体制主要包括三大类型：自由市场经济、命令经济和混合型经济。 经济体制和经济政策。 经济发展水平及其发展潜力。 市场规模及其准入程度。 科技发展水平。 社会基础设施。 文化环境：文化环境是指企业所在的国家或地区中人们的处世态度、价值取向、道德行为准则、教育程度、风俗习惯等构成的环境因素。 权力距离。 不确定性的避免。 个人主义或集体主义。 男性化或女性化。 长期导向或短期导向。 熟悉全球化管理者的关键能力国际商务知识： 为了新产品和服务的发展，建立创造性的公司文化，来平衡独特的、以文化为基础的知识和消息 有效地进行跨文化谈判 在一个给定的地方对于如何能够成功地开展业务能够给出精确的选择 在多个国家中知道大众的行为规则框架 识别和管理文化对于市场和商业运作地影响 理解文化是如何影响人们表达不同意见地方法 将文化差异看作是组织动力的源泉 整合当地和全球信息来制定不同的地点的决策 即使有飞行时差或者需要通过翻译，在不同的商业环境中也能够有效地进行谈判 文化适应能力： 以文化中立的方法来评价他人的工作 再多文化的环境中选择和培养人 鼓励相互不了解或者有不同的文化背景的人进行知识共享 能够有效激励跨文化的团队 调整管理方式适应不同的文化期望 视角转换能力： 良好地倾听 当试图进行改变时考虑他人关注地问题 能够通过他人眼光看待环境 意识到自己观点地局限性 创新能力： 形成能够创造新的不同的解决问题地联盟和概念 在必要时，能够摆脱经常性地思考和行为方式 尝试新方法 有创新精神，能够抓住机会 形成新的想法 提出有说服力的概念或观点 熟悉全球化经营的进入方式（未完待续……"},{"title":"旅游学笔记（二）","date":"2018-04-25T10:01:07.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"discard/Tourism-principles-and-practice-2.html","permalink":"https://blog.jugg.xyz/discard/Tourism-principles-and-practice-2.html","excerpt":"","text":"旅游业掌握旅游业的定义、构成、分类和特征*旅游业的定义 以一次旅游全过程所需要的产品和服务组合来定义旅游业：将旅游者出游之前的信息服务，旅游过程中的交通、住宿、饮食、游览、购物、娱乐、导游等各种服务和相关产品组合在一起，就形成了现代旅游意义上的整体旅游产品和组合旅游产品，而为旅游者提供这一系列产品的企业的集合体就可以统称为旅游业 以提供产品的对象和市场关系来定义旅游业：以旅游者为服务对象，以旅游市场为联系纽带，以旅游资源和设施为基础，以旅游经营活动为中心，将相关行业和企业集合起来，像旅游者提供旅游过程中所需要的产品和服务的综合性产业，就是旅游业。 旅游业的构成和分类 狭义上的旅游业：旅行社、住宿和交通。 广义上的旅游业：相关旅游业包括餐饮、娱乐、旅游吸引物、旅游购物、金融、保险、旅游管理机构等。 间接旅游业：间接旅游业指基础公共设施、公共服务和支持性行业和部门。 旅游业的特征 旅游业是资源和设施依托的产业 旅游业是劳动密集型服务产业 旅游业是综合性和交叉性产业 旅游业是市场聚集度低、产业结构松散的产业 旅游业是产品生产链条不顺畅的产业 掌握旅游吸引物的概念和分类方法旅游吸引物的概念旅游吸引物或旅游资源的定义：自然界和人类社会中凡是能够对旅游者产生吸引力，可以为旅游业开发利用，并产生经济效益、社会效益和生态环境效益的各种事物和因素。 旅游吸引物的分类方法以总和吸引物特征和游客体验标准的分类方法美国的克劳森和尼奇( Claseson and Knetsh, 1996 )根据旅游吸引物接近客源市场的程度、旅游吸引物的特征和游客使用旅游吸引物的程度，吧旅游吸引物大致分为三类：使用者导向型旅游吸引物、资源导向型旅游吸引物、中间型旅游吸引物。 多因素综合分类方法多因素综合分类方法的核心那部分是以主要旅游吸引物为基础，所提供的各种旅游产品和设施，如导游讲解、餐饮、住宿、购物、交通、事件与活动等。 围绕核心部分，可以按照旅游吸引物的基本属性将旅游吸引物细分为自然吸引物和人造吸引物两大类。 掌握旅游吸引物管理的内容和要求*资源管理假定可用于旅游的自然资源数量是固定的，唯一可行的方法就是采用不同的资源使用方式来改变资源的供给状况，但一个重要的前提是游客在旅游是不应对自然资源过度使用而造成资源的破坏。 所有权 公有制吸引物：总的趋势是采用参观者支付门票的方式。 自愿者组织：会员费、捐赠和遗赠是他们最为主要的收入来源。 商业性旅游吸引物：主题公园需要增加游乐设施，并置换那些只能让游客付出体力的陈旧设施；历史古迹和博物馆则可以依靠建筑物和收藏品本身的内在价值来吸引游客，其展品的陈列和解说尤为重要。 成本管理在旅游吸引物的建设上政府可以提供现金资助、国家财政援助贷款、共享所有权，以提供土地、基础设施和道路等，或将这些形式综合起来，来降低旅游吸引物的建设成本。 价格管理门票价格和边际成本之间的差额就是企业所能掌握的价格变动范围，企业在短期内必须能够支付运营成本，但在长期内能够补偿固定成本。 人员管理旅游景区景点在管理中必须建立扁平式的组织结构，授权给员工，重视有价值的员工，并增加他们的绩效工资。 季节管理景区景点的经营者可以在淡季的时候为游客提供一些额外的利益，例如在淡季时向游客开放景区经典中一些可免费参观的内容，从而来缩小季节差价的幅度。 游客管理要避免城市主要道路的拥挤和堵塞，景区景点首先要解决汽车或公交车的问题。一旦到了景区，旅游者百年可以使用景区内的交通系统或步行。对于主题公园内的热门游乐点或游乐设施有必要对游客进行排队管理，这样游客不会因为过长的等待时间而无法尽兴游玩。 环境管理保持旅游的环境可以建立一个长期发展的平台来提供更好的旅游产品、节约旅游资源和提高公众对旅游业的认知。 对环境问题最保守的解决方法时通过限制游客人数将旅游需求拉回到单位消费的社会成本与经济成本相等的位置。 旅游吸引物的真实性历史和文化表演向游客展现的是当地历史文化遗产静态的一面，但却可以降低游客对当地居民隐私空间的侵犯，同时也能激发当地居民为以前拥有的历史而感到骄傲和自豪。 掌握住宿设施的类型*住宿业是旅游业的重要组成部分，被誉为与旅行社业、旅游交通并列的旅游业三大支柱。（也是狭义上的旅游业） 连锁酒店的出现归功于凯蒙斯·威尔逊( Kemmons Wilson )和假日连锁酒店的创立。 酒店 家庭旅馆、床和早餐旅馆、农场客房 餐饮自理住宿设施——公寓、别墅、乡村住所等 校园住宿设施 分时度假 青年住宿设施 野营和房车露营地 医疗保健住宿设施 定期游轮和渡船住宿设施 火车和飞机住宿设施 探亲访友接待设施 了解住宿业的特征及其质量管理和等级评定方法旅游住宿业的基本特征 旅游住宿业是有形和无形要素的组合产品 旅游住宿业的产品生产与消费是不可分割的 旅游住宿业的产品是瞬间即逝的 旅游住宿业质量管理与等级评定许多分等级体系主要以可操作的有形而量化的特征来决定等级，这些特征包括： 房间的面积； 房间的设施，尤其注重是否有套房； 提供的服务项目，如洗衣、房餐服务、24小时接待服务 住宿业分登基体系的问题有： 政策给分等级体系带来的压力使大多数酒店不断向高档次发展，由此导致了酒店业头重脚轻的结构不合理现象非常普遍； 管理和操作复杂的分等级体系需要付出成本，特别是无法衡量的主观和无形成本； 住宿业反对国家用强制性的手段来实施分等定级体系； 分等定级的发展趋势是鼓励标准化，而不是个体酒店创造卓越。 掌握旅游中间商的含义、基本类型和结构旅游中间商的含义和类型旅游中间商是指介于旅游生产者与旅游消费者之间，从事转售旅游目的地旅游企业的产品、具有法人资格的经济组织或个人。 欧美国家的旅游中间商 旅游批发商( Tour Wholesaler )：旅游批发商是指从事旅游产品批发业务的旅行社。 旅游经营商( Tour Operator )：旅游经营商与旅游批发商在性质和经营业务上基本相同，其差别仅在于：旅游批发商不直接销售旅游线路产品，也不服务于最终旅游消费者；而旅游经营商则拥有自己的零售网络，在组合整体旅游产品的同时不但通过旅游零售商出售其旅游产品，而且还通过自己的旅游零售网点直接向广大旅游者出售这些产品，直接服务于旅游者。 旅游零售商：旅游零售商是直接与旅游者打交道的旅行社，向旅游者宣传和推销旅游产品，承担旅游消费者决定策问与旅游产品推销员的双重角色。 中国的旅游中间商 国内旅行社：国内旅行社的经营范围仅限于国内旅游业务，包括想国内旅游者宣传促销、招徕国内游客、安排国内游客形成、提供导游服务和行李服务、代订和代办交通票据和其他事宜等。 国际旅行社：国际旅行社的经营的范围是国际旅游业务和国内旅游业务。国际旅行社又细分为两类，一类是既可经营出境旅游业务、又可经营入境旅游业务，还可以经营国内旅游业务；另一类就是只能经营入境旅游业务和国内旅游业务。 旅游中间商的结构 旅游产品分销渠道结构 了解旅游中间商的发展趋势 旅游中间商会逐渐被网络取代。 旅游中间商企业的纵向一体化：纵向一体化是指旅游中间商企业将现有的经营业务扩展至原料购买、产品胜场以及产品销售诸环节的一条龙发展战略。 旅游中间商企业的横向一体化：横向一体化是旅游企业的另一种组织形式，通常是指两个旅游经营商或两个旅游代理商通过兼并收购的方式合并经营。 网上交易是旅游中间商的发展趋势。 区分旅游批发商与旅游经营商和旅游零售商与旅游代理商的业务特点和职能旅游零售商与旅游代理商的职能旅游零售商的基本职能是为公众提供旅行服务，是旅游产品的供应商或委托人的代理销售者。旅游代理商也提供旅游保险和外汇兑换服务。 旅游批发商与经营商的职能旅游批发商的产品是通过批量购买而达到一定的经济规模后提供给消费者的。大型旅游经营商和批发商通常销售非常丰富多彩的旅游线路，所以编制了大量图文并茂、价格和日常安排明确的宣传手册将度假产品的信息传递给消费者。 掌握旅游交通的基本方式和构成要素*旅游交通作为旅游产品的基本要素体现在三个方面：一时游客抵达目的地的手段；二是游客在目的地内展开活动的必要方式；三是交通本身就是一种吸引物或旅游活动，是旅游经历中重要的组成部分，车船外的景色和空中飞行的兴奋都会给游客带来效用。 旅游交通的基本方式旅游交通的方式主要有公路、铁路、水路和航空四种，可以被进一步细分为抵达目的地的交通和目的地内的交通。 旅游交通的构成要素 路径 客运站点 交通工具 交通动力 了解各种旅游交通方式及其竞争优势和劣势陆路交通 小轿车：小轿车的优势是便捷、普遍。劣势是会对空气质量造成影响，可导致哮喘和其他呼吸道疾病，并制造交通拥挤、交通事故和视觉障碍等高的社会成本，这些都极大的降低了许多旅游目的地的吸引力。 旅行轿车：优势是价格低廉，发车频率和数量高。劣势是速度慢。 火车：优势是安全、价廉而舒适。劣势是火车的固定成本很高，旅行过程对部分人来说相对枯燥。 航运交通航运的优势是价格和乘客能携带私人车辆到达目的地后使用。劣势是行程慢。 空中交通空中旅行的优势是速度块，舒适性高，劣势是价格昂贵。 认识对旅游交通有重大影响的问题和未来发展趋势 政府的行为总是影响着国际旅游的流向，也影响着旅游交通。 在许多国家，铁路通常都是由国家垄断、归政府所有并由政府提供补助。 未来发展趋势，在交通领域应用现代新技术，如收益管理、轴心与辐射经营系统、现代分销系统、就算及预订系统等，来改变商业运作模式。 全球化是国际旅游业的一个主要发展趋势。 掌握政府在旅游管理中的作用和影响政府在旅游管理中的作用国家旅游机构的市场影响部门提出市场营销策略，并负责广告策划、宣传资料设计，以及通过传媒和旅游交易会进行旅游促销。 对外联络是国家旅游组织相当重要的职能，原因是国家旅游组织在国内外经常代表政府处理来自公众、媒体和商家的咨询，并在公关活动中积极支持由市场影响部门进行的广告和销售促进活动。 政府在旅游管理中的影响政府部门对旅游业施加影响主要是通过需求和收益管理及供给和成本管理两种途径。 需求和收益管理 市场营销和宣传促销 信息提供和网络开发 价格管理 旅游目的地进入限制 安全保障 供给和成本管理 土地使用规划和控制 建筑法规 市场规范 市场调研和规划 税收 教育和培训 投资激励 政策干预政府可采用的干预政策很多，而且政府能够在各种程度和层面上影响旅游业的发展方向。 旅游目的地了解旅游目的地的作用、构成和主要利益集团旅游目的地的作用旅游目的地是满足旅游者需求的服务和设施中心。从地理空间角度看，旅游目的地是一个考察旅游的影响和作用的基地。旅游目的地吧旅游的所有重要元素都集于一个有效的框架内，是旅游活动中最重要和最有生命力的部分，也是游客接待的载体。 旅游目的地的构成旅游目的地通常由下属核心部分构成：旅游吸引物，以住宿、餐饮、娱乐、购物品零售为主题的旅游接待设施，当地的交通体系和进入通道，各种辅助性服务设施和组织机构。 旅游目的地的利益集团 当地居民 旅游者 旅游企业 政府部门 其他利益集团：其他利益集团主要包括当地的、区域的和国家的利益群体、商会和政治团体。 掌握旅游目的地生命周期模型的特征和意义*旅游目的地的生命周期模型的特征1980 年加拿大旅游学家 R.W.Butler 提出，旅游目的地的发展过程通常要经过 6 个阶段：探索期、导入期、发展期、稳定期、停滞期、衰落期或复苏期。 旅游地生命周期框架 旅游目的地的生命周期理论的意义旅游目的地生命周期理论为描述和总结目的地旅游发展历程提供了一套游泳的模板，该理论可用来分析目的地的增长状况，考察那些导致目的地生命周期从一个阶段深化到另一个阶段的因素以及其转折点的特征。 旅游目的地生命周期理论有利于研究者或从事旅游实践工作者掌握目的地的发展阶段，以便采取相应的措施尽可能延长其生命周期并预测目的地未来发展趋势。 了解旅游开发规划的层次和程序旅游开发的层次编制旅游开发规划由国际级、国家级和国家级以下三个不同的层次。 旅游开发规划的程序 提高认识并做好规划准备 制定规划目标 收集现有资料 开展实地考察 筛选和分析资料 拟定政策并形成初步规划 提出规划建议 实施规划 监控和修订规划 了解旅游卫星账户的作用和内容卫星账户( Satellite Account )也成为附属账户，是用于测量现有国民核算体系中尚未或不能被作为一个产业经济部门的规模的一种核算方法。 卫星账户的作用卫星账户作为一个国民经济核算的工具，除了提供国民经济核算中有关旅游业的准确内容和数据外，从经济学意义上，它还可以教全面地反映旅游活动的供需情况、供需对应平衡问题；核算旅游业的产业规模。作为一个较全面的数据库，旅游卫星账户的基础数据可以为政府的公共政策提供依据。 卫星账户的主要内容 旅游产品的攻击情况，主要反映是哪些旅游产品，人们主要消耗的旅游产品是什么，这些产品由哪些产业生产； 旅游产品的消费情况，反映游客、居民、政府、企业等对旅游产品的消费支出以及在不同旅游产品上的支出结构； 旅游产业中的经济活动单元在生产过程中所创造的增加值、所吸收的就业情况。 掌握测量旅游经济影响的基本方法利用国际旅客调查和国家旅游者调查的方式和结果来估计一个地区的旅游消费去获得该地区旅游者消费的数据。 了解乘数效应分析的局限性 限制假设：每一种积极模型都有一系列的假设。这些假设的现实性对于模型至关重要，非现实的假设提供的都是非现实的结果。 数据缺乏：二手数据是几乎无法满足复杂模型和高级模型的要求，数据收集困难。 负面经济影响：旅游开发以一种支出的形式和经济活动来替代其他发展，被称之为替代效应。当旅游的发展占用了其他行业的资金并通常被称为一种发展的机会成本时，替代效应就会产生。 乘数效应值的大小：在不同的环境下，乘数效应值的大小是不同的，因为乘数效应值的大小依赖于一个地区经济的特性以及经济体系中不同行业在交易方式上的联系。 了解旅游对环境的正面和负面影响正面影响 保护和修复名胜古迹 建立国家公园和野生动物园 保护珊瑚和海岸 保护森林 负面影响 旅游可以直接影响水和空气的质量并增加噪声。 旅游活动给许多稀缺的自然资源造成巨大的压力。 一些古迹由于受到侵蚀、乱涂乱画和游客的偷窃而变形或被破坏。 掌握衡量旅游环境影响的评估方法、内容和程序环境影响评估方法利用环境核查表进行评估。当旅游对环境的潜在影响和主要风险因素都列入了核查表后，就可以按照每个因素来评估旅游开发项目将产生的环境影响，即无影响、有少量影响、中等影响或严重影响的不同程度 （此处应该有张旅游环境影响核查表） 环境影响的评估内容和程序内容： 环境监测过程； 对自然资源的妨碍； 影响项目可行性的环境问题和矛盾； 对人类、植动物、土壤、水源、空气、安宁、安静、风景、文化胜地等可能的有害影响，不论这些有害影响发生在项目实施的区域还是在受到项目影响的区域。 评估程序： （此处应该有对环境影响评估程序图，p297 ） 掌握旅游社会文化影响的研究方法*旅游者类型学研究方法旅游者类型是一种社会学的研究方法，它按照特定的旅游动机和行为现象对旅游者进行分类。 （此处应该有一张史密斯所建立的旅游者分类法表， p302 ） 旅游心理学研究方法普罗格认为，处于中间心理状态的几个细分市场与处于两个完全极端心理状态的旅游者群体是互相衔接的，每个心里状态群体都居于纵轴上相应的位置，如自我中心型、近自我中心型、中间型、进多中心型、多中心型。 （此处应该有目的地选择的心理定位，p303）有待商榷 旅游社会学研究方法（此处应该有旅游社会文化影响的研究方法图，p307）如果检索不到可手写 熟悉旅游社会文化的正面和负面影响负面影响常见的消极旅游社会文化影响类型： 消极经济影响 消极劳动力影响 行为示范效应的消极影响 一些特殊的消极旅游社会文化影响： 性：旅游者到国外旅游去寻求不受禁止的暂时性的性享受。 犯罪：由于人口的增加而引起犯罪活动的增加或者是旅游发展直接引起了犯罪活动的增加。 健康：不为人们所关注的疾病会在来自不同地区的人们相互接触时传播。 其他方面的消极影响：文化商品化、表演的真实性、设施标准化、旅游者的不同体验 正面影响 增加当地人的自豪感 提升社会文化意识与促进和平：旅游把人们带到了新的地方，以新的文化和环境扩大了人们的视野和认知。 共享基础设施：旅游目的地会加强基础设施建设以满足日益增长的率与发展需求。 直接提供社会文化支持：旅游业可以提供继续的资金，以帮助修复文物古迹，保护自然和文化遗址。 掌握旅游的可持续发展定义可持续性的定义目前可持续性一般使用“布伦兰特报告”( 1987 )所下的定义，即“既满足当代人的需求，又不损害后代人满足其需求的能力。” 可持续旅游的定义可持续旅游发展在满足当前旅游者和接待地需求的同时，要保护和增加未来的机会。也就是说，在对所有旅游资源进行管理时要考虑到满足当前经济、社会和审美需要，同时要保持文化的完整性，保持基本生态进程、生物多样性和生命支持系统。 了解影响旅游可持续发展的经济、环境因素、社会文化 经济与可持续旅游之间的矛盾：旅游会与其他行业争夺争产要素。会严重妨碍当地经济的健康发展。 环境与可持续旅游之间的矛盾：航空公司是空气污染的主要制造着，大部分的空中交通是因旅游而产生的。旅游还与房地产开发商相关，与其他行业争夺土地使用权， 这也同样会使自然环境受到损失。旅游活动对生物多样性有严重的影响。 社会文化与可持续旅游之间的矛盾：由于旅游活动需要旅游者对目的地进行访问，外来者的行为举止、衣着和习惯会潜移默化的影响当地居民的行为、衣着和习惯，这种负面影响必定是旅游与生俱来的一种文化威胁。 掌握旅游目的地承载力概念*承载力的含义旅游承载力曾被定义为“同一地点可接纳的人数极限，在这个限度内，自然环境不会发生令人无法接受的改变，同时游客的体验质量也不会下降到一种令人无法接受的水平”。这个定义包含以下三层含义： 旅游者数量对于可持续性的实现有直接影响。 承载力具有灵活多变性 旅游承载力受到多种因素的影响 承载力的确定过程承载力的指标可以粗略的分为五大组：经济、环境、社会、文化和旅游者。 影响承载力的因素当地因素： 社会结构 文化遗址 环境 经济结构 政治结构 资源 外来因素： 旅游者特征 旅游活动类型 规划管理和技术 影响是承载力的尺度，而规划人员和旅游管理专家的任务是确保产生的影响都是合理可接受的： 参数：影响反映了旅游者与当地居民接触互动后产生变化的性质和规模，当然这是在规划和管理都已实施的情况下。 标准：标准可以看成是应用于参数的极限，是指对由当地居民和旅游者就某个变量要接受的变化程度给出量化的值。 承载力确定：承载力是一个因变量，他不是一个固定不变的值，橙子阿里的灵活多变是源于每个自变量的可接受水平是不断变化的。 旅游市场掌握旅游市场的概念及内涵* 有形交换地点概念：旅游市场是旅游产品和服务交换和消费的场所，即在一定的空间换个时间范围内，旅游者和旅游供给者双方进行旅游产品交易的有形地点。 无形交换关系概念：旅游市场是供需双方以及中间商之间以各自的经济利益为纽带，为实现旅游产品让渡的交换现象和交换关系的总和。 旅游消费者群体概念：旅游市场就是指在一定的时间和地点条件下，具有旅游购买力、旅游愿望和旅游购买权力的消费者群体。 掌握旅游市场的构成要素和特点*旅游市场构成要素 旅游者 旅游购买力 旅游愿望 旅游购买权力 旅游市场的特点 旅游市场具有波动性：从总体和长期看，旅游市场将保持持续发展的趋势，但不是直线发展，而是在波动中向前发展。 旅游市场具有季节性：在一年中的不同时期，旅游市场有明显差别，这种旅游需求量在时间分布上的不均衡，构成旅游市场的季节性特点。 旅游市场客源流动具有规律性：旅游市场客源地流向是由近及远，以近距离旅游为主；旅游市场主要源于经济发达国家和地区；国际旅游市场的中心将向亚太地区转移；旅游市场具有高度竞争性。 了解全球旅游市场的发展趋势和影响因素全球旅游市场的发展趋势现代全球旅游业从第二次世界大战之后开始蓬勃发展。半个多世纪以来，全球旅游人数与旅游收入展现出持续增长的趋势，国际旅游达到人次从 1950 年的 2500 万增长到 2004 年的 7.63 亿。国际旅游收入从 21 亿美元增长到 6235 亿美元。 全球旅游市场发展的影响因素经济方面： 世界经济全球化 世界范围内的消费需求持续增长 社会文化方面： 人们受教育水平普遍提高以及新的工作形式的出现 世界城市化发展趋势以及人们对于可持续发展的重视 对旅游安全因素的重视 人口老龄化趋势 科学技术方面： 信息技术的普及 先进的交通工具和设备的出现 了解全球旅游市场发展新趋势 区域旅游仍将盛行，亚太旅游市场蓬勃发展 世界统一市场的形成促使旅游市场一体化进程加快 旅游市场超细粉化趋势明显 熟悉中国入境旅游市场的发展历程、规模和需求特点中国入境旅游市场发展历程 新中国成立之改革开放前的旅游市场( 1949——1977 年 )：从建国初期至十一届三中全会以前的 20 多年间，中国的旅游主要是政治性很强的外事接待，提倡友谊第一，不计算经济收益。 改革开放之后的入境旅游市场( 1978——2001 年 )：20 世纪 90 年代依赖，中国旅游业持续快速发展，在国民经济中所占比重日益提高，旅游业的经济效益得到了全面的表现，全社会发展旅游业的的自觉性更加高涨，旅游产业定位日趋明确，国际旅游业保持了稳定的增长。 中国入世之后的入境旅游市场( 2002 年至今 )：中国加入世贸组织为入境旅游业的发展提供了新的契机。从之之后，中国入境旅游市场一直保持持续增长的势头。 中国入境旅游市场的规模和需求特点中国入境旅游市场主要构成包括以下三类： 港澳台同胞 东亚旅游者 欧美旅游者 中国入境旅游市场的需求特点： 入境观光者的需求：一般而言，观光旅游者对自然风景有着浓厚的兴趣，愿意去具有独特山水风光的名胜区。 入境休闲旅游者的需求：休闲旅游者一般选择著名的、风光秀美的旅游景点，或度假村，或憩息豪华宾馆，或在疗养胜地休息，他们追求自在、舒畅、潇洒，整个旅游活动以休闲为中心，旅游节奏慢，而是是夏日避暑、冬日防寒。 入境商务旅游者的需求：上午旅游者大多是以经商为目的，或是为了营销和业务交流，或是参加大型交易会，或是考察当地商业环境和商情，或是订立商务合同等。 熟悉中国国内旅游市场的发展内涵、规划和需求趋势发展内涵： 中国国内旅游的恢复和转轨阶段( 1978——1980 年 ) 国内旅游的起步阶段( 1981——1990 年 ) 国内旅游迅猛崛起阶段( 1991——1998 年 ):1995年，中国成立了“全国旅游标准化委员会”，发布了国家旅游标准和两个行业标准，并部署旅游市场专项治理工作。 国内旅游稳步增长阶段( 1999 年至今 ) 需求趋势： 旅游者更注重与健康、环保相结合的休闲度假旅游 旅游者更偏好于体验性、参与性强的旅游活动 旅游者更追求旅游活动的文化内涵 老年人的旅游需求增长迅速 乡村旅游市场前景看好 熟悉中国出境旅游市场的发展历程、规模和特点发展历程： 试探性发展阶段( 1984——1989 年 )：在此阶段，中国出境旅游人数增长非常缓慢，到 1989 年处境旅游人数仅达到 300 万左右。 初步发展阶段( 1990——1996 年 ) 规范发展阶段( 1997——2000 年 ) 快速发展阶段( 2001 年至今 ) 中国出境旅游市场规模：是亚洲的第一大客源输出国，并且还在规模还在持续扩大。 中国出境旅游市场特点： 市场环境趋于宽松 港澳“自由行”持续升温，欧美游快速增长 “超常”旅游消费开始出现 掌握旅游市场营销的概念和内涵*旅游市场营销的概念古典与狭窄的旅游市场营销： 重视已经生产的旅游产品，忽视未胜场的和已售出的旅游产品； 局限在流通领域开展营销活动，不涉及产前领域、生产后领域和售后领域的营销活动； 主要的工作内容是旅游产品的推销和销售，部进行市场调研、需求分析、市场细分、营销计划、产品设计、产品生产、定价、促销、分销和售后服务等一些列活动； 达到的目的是实现旅游产品的交换，从中获得收益和理论，不管顾客从旅游产品中获得的价值和利益、顾客的满意度、与顾客建立长远关系等。 现代宽泛的旅游市场营销： 旅游市场营销活动范围扩大了，从一个流通领域扩大到四个领域，即向前扩展到产前领域和生产领域，向后延伸到售后领域，市场营销活动囊括了旅游经营管理活动的全过程。 旅游市场营销活动的内容复杂了，从单一的产品推销和交换活动，扩展到旅游企业的综合循环活动的各个领域。 旅游市场营销的只能转变了，从旅游产品的推销的单一职能，变为以顾客为中心，以市场需求为导向，通过制定一条龙式的市场营销系统来引导、管理和控制企业的整体经营管理活动。产品推销已经别变成了市场营销中不重要、甚至是不必要的职能。 参与营销活动的人员不只是旅游企业的专业营销队伍，而是上到高曾管理者，下到每一个员工，人人都树立起全员营销意识，大家共同参与，形成上下结合、内外结合的营销合力和整个营销网络，确保旅游企业的产品和服务从生产到销售的每一个环节都能满足市场的需求。 旅游市场营销计划的作用 用系统、书面的形式明确旅游市场营销的行动和方向，并确定一系列企业宗旨和目标。 协调旅游企业资源，减少内耗和相互误解，最大限度的求得合作。 为每个人、部门和企业整体设定可衡量的量化经营指标。 通过内外部环境分析降低风险，认识企业的优势和劣势，评价外部机遇与威胁。 确定针对不同细分市场的营销方式，估计销售量和收入以及营销预算。 提供市场营销政策和计划，保持政策和计划的延续性。制定企业的长期经营目标，以便更好地实现未来目标。 掌握制定市场营销计划地内容和过程（此处应该由旅游市场营销计划过程和内容图，p374） 掌握市场营销组合策略的内容 产品决策：能否向目标市场的客户提供适销对路的产品； 价格决策：能否制定出顾客愿意接受、企业能够盈利和击败竞争对手的价格； 促销决策：能否将产品和星系迅速而准确的传达给目标顾客，激发他们的购买欲望和购买行动； 销售渠道决策：能否让顾客随时随地方便地获得产品。 旅游的发展与未来趋势用科学的方法分析和展望旅游的未来（此处应该有旅游区是分析框架图，p392） 了解社会和政治的变化，包括采取旅游安全措施的必要性社会发展趋势： 越来越多的人选择在城市中生活 女性的地位和影响力不断提高 人们对文化的需求越来越高 政治因素： 服务贸易总协定( GATS ) 贸易集团 全球化 世界新格局 安全措施的必要性：危险会动摇旅游者信心并影响旅游业正常经营。 意识到其后对旅游业未来的影响意义从供给角度讲，地球气候变暖会抬升海平面，从而影响到很多旅游地，包括湿地、岛屿和海岸地区。 从需求角度讲，由于担心皮肤癌和白内障，海滨旅游也同样会影响到目的地和旅游产品，其后的改变还会影响人们对初行交通工具的选择。 认识人力资源对未来旅游业的重要作用 保证旅游企业能给顾客提供高质量的服务； 是整个行业的价值增高，提高人员素质，提高行业的职业化水平； 更好地界定行业并突出行业内各部门之间地异同； 让从业人员深入了解各部门之间地相互关系并更好地探寻商业机会； 技能和知识的培训能提高全行业的劳动生产率； 让教育和培训与人力规模相结合能更好地满足酒店和旅游学校的产出需要； 留住员工，降低员工流动率，建立职业阶梯，使旅游业地人力资源得到更好地利用； 确保目的地旅游产品能由当地人提供而不是外人提供 未来旅游教育和培训的趋势： 专业化程度加深 学科领域扩大 确定职业素质标准 了解在未来的旅游产品和市场之间的联系的重要性现有旅游产品范例： 海滨旅游 乡村旅游 生态旅游 文化和遗址旅游 新旅游产品范例：特殊兴趣旅游 未来旅游产品范例： 虚拟现实 太空旅游 新模式：普恩( 1989 )认为引领新旅游的主要趋势是：一个新的信息技术系统将融入旅游行业；航空业和金融业的开放；大众旅游对目的地国的负面影响；从追求阳光型向阳光附加型旅游转换；环境压力；技术；竞争和消费者品味的改变。 掌握一些旅游行业可以控制的影响变量（无） 了解影响旅游消费者行为变化趋势的重要因素（无） 掌握信息通信技术和电子旅游的主要概念信息通信技术是一种商业工具，从宏观层面上讲，由于信息技术成为沟通和交易的手段，使各国经济的整体实力增强，并决定者某国经济在全球的竞争能力。 电子旅游是通过信息技术协助个人满足旅游的需求。（个人理解） 掌握信息技术在旅游业的一般应用 信息技术能让旅游者可靠和准确的消息 信息技术参与旅游分销环节，四大全球分销系统几乎垄断了全球分销系统市场（伽利略、阿梅丢斯、骑士、环球）。 掌握计算机预订系统和全球分销渠道的基本概念（无） 掌握互联网和信息技术现象对旅游系统的结构和各个构成要素的影响 对航空公司的影响：计算机预订系统使航空公司可以根据市场需要调整自己的航班安排和票价。 对酒店的影响：酒店可以利用信息技术辅助分销和营销功能，让全球的顾客都能看到企业，让旅行代理商都能了解就顶啊房价和空房情况的准确信息，使预定变得更方便、快捷、可靠和便宜。 对旅游经营商的影响：旅行社也开始使用计算机预定系统，调节供给，适应波动的市场需求，同时，更好地监控预定的进展情况和各旅行代理的效率 对旅行代理商的影响：信息技术使旅行代理商不可取代的工具，作为消费者和主题供应商之间的中介机构，技术能提供他们所需要的信息并帮助他们实现预定。 对目的地的影响：目的地管理系统利用互联网实现多媒体分销，镶嵌在消费者互动地展示当地景点和设施，使消费者能根据自己的兴趣、要求和各方面条件的限制涉及自己的行程。 了解信息技术和互联网对未来旅游业各相关利益方的战略意义信息技术在旅游经营和分销方面带来了巨变，使消费者有能力了解到专业的产品并满足自己的特殊要求。此外，信息技术还未目的地提供了空置率有影响的战略工具，目的地利用新技术能更好地散播信息和调整供给。主题供应商和目的地在电子市场上的可见度直接影响了他们的竞争力，而这种可见度就是指利用技术和网络与顾客进行互动。 信息技术能带来如此巨大的利益，能帮助企业提高效率，加强协调，实现差异化和节省成本，但它不是一个放之四海而皆准的灵丹妙药，企业流程的再造和战略管理思维是理性利用信息技术的前提。"},{"title":"友情链接","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"friend-links/index.html","permalink":"https://blog.jugg.xyz/friend-links/index.html","excerpt":"","text":"排名不分先后 :) DA LAO Name Links AresX AresX’s Blog https://ares-x.com \\xeb\\xfe \\xeb\\xfe’s Blog https://doge-dog.github.io Kami Kami third home https://kamisec.github.io/#blog Matrix M4tr1xk00k67’s blog https://matrixkook.github.io"},{"title":"","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"discard/index.html","permalink":"https://blog.jugg.xyz/discard/index.html","excerpt":"","text":"这里是一个隐藏的垃圾桶。"},{"title":"","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":false,"path":"tags/index.html","permalink":"https://blog.jugg.xyz/tags/index.html","excerpt":"","text":""},{"title":"三言两语","date":"2024-03-11T18:14:54.499Z","updated":"2024-03-11T18:14:54.499Z","comments":false,"path":"weibo/index.html","permalink":"https://blog.jugg.xyz/weibo/index.html","excerpt":"","text":"2018年4月15日@card{ 结束了一次失败的尝试，开始找工作了。好久没碰服务器了…… } 2018年4月15日@card{ 我好像特别擅长做废事，用 GitHub 写课后习题，用博客记笔记……或许应了下面那段，这是种小付出（不用太动脑子）大回报（或许博客字数和 Github commit量也算大回报？）的偏方吧……以后尽量不做这种事吧。 } 2018年4月14日@card{ 一个人是怎么废掉的呢？就是沉溺于「轻易获得高成就感」的事情：有意无意地寻求用很小付出获得很大「回报」的偏方，哪怕回报是虚拟的。同时，还习惯用「错位成就感」麻痹自己，例如：在开发群里解答运维问题，在运维群谈开发，在 pwn 群扯前端，在前端群……我好像没有前端群（逃 总之，就是通过一点点基础的知识，给自己带来一些虚拟的成就感后，就开始放弃深入学习。那如果一个废掉的人意识到这一点后，还能不能追上正常人的脚步呢？我不知道……但可以试试。 } 2018年4月11日@card{ 两耳不闻窗外事，一心只读圣贤书。 } 2018年4月9日@card{ PWA 满分成就达成！ Lighthouse } 2018年4月8日@card{ mastodon 有毒，部署起来真复杂…… } 2018年4月6日@card{ 为什么我的评分这么低……好想要满分啊，又要折腾许久&#x3D;。&#x3D; Lighthouse } 2018年4月3日@card{ #TODO 1、 添加PWA支持。 2、 改进文章摘要样式。 3、 weibo 页面支持翻页。 } 2018年4月2日@card{ 差点以为 sm.ms 图床挂了，上去一看首页还在，猜测是换了域名，更换后恢复正常，果然用免费的东西还是很不靠谱，回头换到腾讯云存储吧。 } 2017年7月10日@card{ 时隔两个月再把博客重新拾起。加油！ 小绿 } 2017年5月20号@card{ nodejs要把我弄疯了，不该直接弄这个的，我还是先把今天的博客写好吧。 小埋 } 2017年5月19号@card{ 不对啊，说好的 LNMP 搭建怎么还没开始&#x3D;。&#x3D;又荒废了三天 } 2017年5月18号@card{ 人啊，干嘛和自己过不去呢？开心就好，反正在校也没几个月时间了。 } 2017年5月17号@colum-3{ @card{ 11:00都快毕业了，还没学点什么实用的，又不知道该学什么。没有理想的人和咸鱼真没什么区别啊(￣▽￣)” } @card{ 14:00昨天花了一下午搭建了个 git+nginx+hexo 的站点，总感觉有点失心疯……我搭建完后才发现这么干的人几乎很少，就我所知的只有我自己&#x3D;。&#x3D; 主要是费力不讨好😂。这些日子搭建的一直是静态网站，动态网站也只试过wp和jsp，这几天就尝试下 LNMP 和 LAMP 把。 } @card{ 21:00芒果台的片子真是不管什么类型都能放成小鲜肉言情剧啊，以前芒果台也买过几个不错的剧，但是因为收视率的问题就开始只放如今这种片子，不知道这是谁的悲哀。(ps.话说最大的悲哀就是好剧不叫座吧。) } } 2017年5月15号@column-2{ @card{ 10:00同步方面感觉可以在本地搭建个hexo，然后用git同步，当然，前提是先学习下git的运用了&#x3D;。&#x3D; 另外还有nginx的目录更换问题，今天尽量解决。（ps.虚拟机真是个好东西） } @card{ 21:00解决了同步问题，404页面也配置好了，目录配置路径可能有问题，或者说有多个备份，改了位置依然能正确启动……nginx的坑真多，明天再躺吧。另外，宿舍的那个傻逼越没人理就越张扬了 ┗|｀O′|┛ 嗷~~ 迟早要GG。 } } 2017年5月14号@card{ 把hexo部署在nginx上了，暂时同步比较麻烦，因为更换nginx目录总是404，只能先将静态文件放入默认目录下了，希望明天能解决同步问题。 }"}],"posts":[{"title":"为什么国内大厂很难在toB领域出成绩","slug":"repost/Why-is-it-hard-for-the-big-domestic-manufacturers-to-make-a-mark-in-the-toB-field","date":"2020-12-10T12:33:33.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2020/12/10/repost/Why-is-it-hard-for-the-big-domestic-manufacturers-to-make-a-mark-in-the-toB-field/","permalink":"https://blog.jugg.xyz/2020/12/10/repost/Why-is-it-hard-for-the-big-domestic-manufacturers-to-make-a-mark-in-the-toB-field/","excerpt":"","text":"本文转载自 Passluo 的 推文 一、领导层的困境国内大厂业务多以toC或广告为主要收入来源，行业规模大、增长方法简单、来钱快，领导层长期都是在追求如何短平快地增长。然而toB侧重垂直领域或专业方向，目标企业绝对数量不大，无法像toC那样舍弃客户。只能将需求和应用场景逐一覆盖，所以注定是个慢工出细活、长期投入的事情。 从企业角度出发，toB产品或服务的采购决策更加理性、周期也相对较长。除非是行业刚需的革命性产品（比如AI替代人工打骚扰电话），否则增长根本快不起来。大多需要依靠市场和销售人员不断去接触客户、了解市场需求、宣传产品和品牌、教育企业用户，从而最终培育出销售机会。 现在市场上能见到的比较大的toB软件产品大多都是从 2012-2015 这一波做起来的，有些甚至还更早。北森03年、帆软06年创业，金蝶、用友、金山这些就更不用说了。这些企业都是花了十多年、几十年的时间才积累了行业地位、品牌和足够的商业壁垒，并且现在还不断在被后起之秀挑战。 那一个toC出身的大佬哪儿能耐得住性子花几年去摸市场、磨产品、看用户、造品牌，最后出成绩？你耐得住，上面的那些CEO、董事会也耐不住。他们不会给你那么多时间，因为试错时间成本太高。并且toB产品或服务营收规模都不会太大，年收入能过10亿的赛道屈指可数。但10亿对于toC大厂算个啥？抖音3天的广告收入？ 事情难做、时间成本高、ROI低、在集团内被看不起，这大概就是toB领导层的困境。所以我们看到大厂的toB团队大多都是些低level的Leader在带。他们常常急于求成，按toC的打法和要求去管理toB团队，瞎折腾。最后产品很难做好，部门出不了成绩，团队心力交瘁、气势低落、怨声载道、离职率居高不下。 阿里云当然是特例，它很难得得克服了上述困境。首先阿里有toB基因。其次是当年马云力排众议力挺王坚。 这是非常大的决心和赌注，除了因为云基建这条赛道市场前进足够大，也是因为除了钱以外的战略意义。即便如此，2019年财报看，阿里云也只是阿里电商营收的10%而已。 钉钉就不用提了，赔钱货。 二、人才的困境总的来说toB人才会比toC要求高一点，特别是产品层面。这里面有个矛盾的点就在于有toB领域经验的人不懂互联网，不具备互联网产品人需要的能力，而互联网大部分产品人不懂垂直领域，不懂toB的游戏规则和套路，不知道怎么切入领域。 这是目前toB人才困境的主要原因，也是在这一章节我主要想和大家讨论的。先来看看toB和toC产品工作的区别。 大家平时讨论最多的都是toC互联网，听到最多的一个词是「风口」。为什么toC那么在意风口？因为toC强调创新和需求体量。toC爆发通常靠两点：更好地解决需求 &#x2F; 创造新需求。这个过程需要不断试错，费时费力费钱。相比之下更聪明的做法肯定是抄作业、抢风口。 既然是抢风口，比的就是谁快。什么鸡巴精益创业、敏捷开发、弹性架构、人月神话，只要业务能跑起来、让运营去做增长，管你是PHP、Python还是易语言写出来的代码，能Run就行。而且初期系统挂的越多越好，挂的多说明你业务增长快，说明你火爆。越挂越有人想注册，去投资人那这理由还能加钱。 在这种氛围的长期熏陶下，toC产品人越发重视细节、重视核心想法的表达、越发去抓大放小、越发忽略系统的顶层架构和长远战略。另外由于toC病毒传播的可行性强，产品人会觉得只要发点优惠券烧钱、广告轰炸烧钱、做足微信传播，用户自然就能指数增长。 当他们涉足toB领域时，发现这些套路根本不Work。 反观toB，机会真的遍地都是。 记得有个投资人说过「数字经济下，几乎每个行业都值得信息化改造」。但toB垂直领域体量一般都很小。比如法律领域，全中国持证律师不超过50w人，律所不超过5w家，愿意付钱的可能就几万人、几千家律所。在这样的情况下，不稳扎稳打、深耕细作，是不可能有所起色的。 对于toC来说，一些需求没被满足不要紧，你可以舍弃这波用户，反正中国有14亿人。但对于toB来说，潜在用户一共就那么多，这里舍弃点、那里舍弃点，你还有多少用户？你还做个毛线？所以必须深耕细作，争取把行业通吃，toB里面赢家通吃是很常见的。 而深耕细作依赖行业理解。如果你没有参与过销售管理，你就很难明白为什么CRM里需要那么复杂的销售线索分配机制。然而现在的互联网产品人，大多一毕业就进入互联网圈，没有接触行业一线的机会，也不愿意去了解。 互联网来钱太容易，PM都干不了脏活。不信你问问身边的，有几个敢去主动给用户打电话？而那些在行业里经验丰富的人呢？互联网公司嫌弃他们又土又穷、不懂互联网，很少给他们转业的机会。这些人因为专业、技能、经验和学历的原因，不太容易进入互联网行业；即便进入了，也不可能担任重要角色。可以说很大一部分想法和创新都被封闭和埋没在了领域内部。 这么说肯定有点太抬高领域人才而贬低PM们了。事实上你让一个行业大佬来做互联网，大概率难有起色。无讼的创始人是全国顶级律师，产品一坨屎；iCourt创始人是搞律师培训的，产品年收入破亿。toB产品人需要把互联网和行业知识相结合，打造完整的产品研发和服务团队。有这能力的人，凤毛麟角。 公司之所以是公司，毕竟还是人的事情。大公司成型以后，人才建设和储备基本固化，toB专业人才输入的问题从根本上就被卡死，没办法解决。一个毛都不懂的Leader，带领一群想当然的PM，去折腾一群老实巴交的程序员、运营和销售。这样的团队，能在toB领域做出成绩，那可真是彗星撞地球哦。 三、组织管理的困境公司大到一定规模，就没办法再像小团队那样进行协作。 360 人才评估、绩效、OKR、KPI、季度考核、年末考核、晋升答辩……管理者们发明了一大堆制度和工具，妄想能让团队继续保持高效协作。殊不知，这些方法和工具只是在降低管理者的工作难度，对于一线效率是大大的负增益 一个 toB 小公司的 PM 洞察到一个改进点。简单地在草稿纸上画了一下草图，利用中午吃饭时间和关系好的研发小哥们简单说一下，吃完饭回来找前端快速出一个交互和界面。到了晚上 10 点班车发布后，PM 的微信上就收到消息 “那个玩意儿已经发布了，你快去线上测下看看” 与此同时大厂又是怎么样的风貌呢？PM 首先需要撰写一篇狗屁不通的 PRD，产品总监需要像上朝一样一一评审，设计得出一套保高保原型，然后找人调研测试，因为只有这样研发才肯开搞，技术方案和文档一写就是一两天。好不容易代码交付，又是一堆测试和发布流程。周报上收获满满，客户那两周干着急。 我知道看到这里有人要坐不住了： 「不这么做，怎么保证质量？」 「软件作坊那样做很不符合规范」 「这样搞就是为以后埋坑」 「北大青鸟培训班出来的才这么开发」 「听你这么说，就知道你没系统学习过软件工程」 来我先统一回复一下：你没理解我说的意思。 我当然不反对科学、规范、系统地进行软件研发工作。互联网圈很多都是高学历的聪明人，你们都知道什么才是理想化的协作方式，然而在大公司，这一切都变味了。美国有「政治正确」，而互联网公司有「流程正确」，规范和方法成了避免背锅的工具，让本来应该简单敏捷的迭代过程变得复杂而冗余。非常不敏捷的「敏捷开发流程」只是一个例子。 除此之外，大厂还有一万种方法来拖累组织协作效率。一个季度就 13 周，大厂需要在上季末花费 2 周来总结复盘，再在季度初花 2 周来确定计划目标，接下来的 2 周通常是目标的拆解和确认。你算算吧，真正能干活儿的时间还有多少？ 为了管理庞大的组织体系，大厂花费了非常多的心血在制定组织协作规范上，而这样的规范正是让公司变得臃肿低效的元凶。当大厂的 toB 团队面对市场时，沿用下来的、不可更改的协作规范变成了束缚他们的枷锁。市场的声音、用户的反馈都在淹没在了无尽的 meeting schedule 里。 你说，这仗你怎么打得过？ 四、赛道选型的困境很少听说大厂在 toB 领域有一些跨界且出色的产品对不对？ 阿里的语雀、腾讯的 TAPD、字节的 Lark，这些其实都脱胎于内部需求。虽然面向企业用户、工作场景，但产品形态和运营方式上更加接近于 toC。 而在 toB 领域一些市值更高的常规赛道，比如： 供应链管理 生产管理 销售管理 组织管理 客户服务 流程管理 大厂一直没有切进去，或者说切进去了也没有做的很好。大厂在赛道选型的问题上，相比其他创业公司有着诸多劣势，视野容易受到限制。大多只能看到和自己业务相关联的领域，或者从内部需求开始孵化，再逐渐外延至商业化。而以大厂自己的需求去开发商业化产品，很容易跑偏走型。 大厂能叫大厂，本身就说明了他们的独一无二性，满足大厂需求的产品注定是不普适的。而 toB 产品，特别是 toB SaaS 强调的是边际成本递减，说白了就是标准化和规模化获客。大型企业一共就那么点儿，哪儿来的规模化让你实现边际成本递减呢？ 当然聪明的你已经发现了，其实这并不绝对。对的，Saleforce 和 Workday 这些 toB 软件服务的巨头确实特殊。他们 80% 的收入都是来自于世界 500 强，并不需要太多客户就能达到一个非常高的收入规模。但这些企业的选型之初也并不是因为内发的需求，而是在不断尝试的过程中发现了一个不错的赛道深挖下去。 不管是中国还是西方国家，中小企业肯定是占据了市场主流，他们虽然无法提供规模宏大的收益、无法提供媲美 500 强的预算稳定性。但是 SMB 能提供规模宏大的客户群，客户群给了你丰富的市场反馈和试错验证的机会。这对于 toB 创业的早起来说，远比现金流的回报，意义要大得多。 toB 大厂里的员工长期接收的都是内部的声音，很容易将某种需求扩大化，从而选择了不是那么有市场价值的赛道。即便你看到了一个比较好的赛道，你的 Leader 们可能也很难支持你去做，因为你可能不是很懂，并且你的 Leader 也不是很懂，很难控制风险。对于大厂来说，控制风险比寻找机会重要的多。 那些从大厂里面跳出来去创业、并且有所成绩的，很多都是这种情况。这样的例子非常多，并且换到 toC 赛道也依然适用。否则，按逻辑，每个大厂都应该成为制霸全球的霸主才对。因为不管从人才、资金还是资源上，他们拥有的都比 startups 多太多。 那大厂就不能等一个 toB 赛道初具规模、被验证过了是可行道路以后，再使劲砸进去？目前看，很难，原因就是上述的 一、二、三点。 成功的例子恐怕也只有阿里云了。 五、写在最后的话所以说，怕什么呢朋友们？ 在今天的中国进行 toB 创业真的是绝好的机会。又有市场、又不用担心巨头的侵扰，是非常有潜力的一个领域。 我写这么多，除了吐槽大厂的不争气，其实更多也是鼓励大家不要害怕。互联网的魅力所在，就是永远有巨大的机会等你去挖掘！ 谢谢各位，祝好。","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"startups","slug":"startups","permalink":"https://blog.jugg.xyz/tags/startups/"}]},{"title":"使用 ceph-deploy 部署 Ceph 集群","slug":"ops/Ceph-Deploy","date":"2020-07-02T18:16:33.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2020/07/02/ops/Ceph-Deploy/","permalink":"https://blog.jugg.xyz/2020/07/02/ops/Ceph-Deploy/","excerpt":"","text":"部署 Ceph 存储集群前置条件 管理节点下需要将所有节点对应的主机名和 IP 写入 hosts 方便批量操作（所有节点需要用不同的主机名） 所有节点配置免密登录方便管理节点使用 ceph-deploy 部署(用户需要有sudo权限，并且是NOPASSWD) 重置环境（仅在原环境上操作需要使用）该操作需要在集群的管理节点的 ceph-deploy 目录下操作。 删除所有节点的ceph软件 $ ceph-deploy purge &#123;ceph-node&#125; [&#123;ceph-node&#125;] 删除所有节点的ceph软件数据 $ ceph-deploy purgedata &#123;ceph-node&#125; [&#123;ceph-node&#125;] 删除所有节点的keys $ ceph-deploy forgetkeys 删除ceph配置文件 $ rm ceph.* 自动部署（ceph-deploy）安装 ceph-deploy# pip install ceph-deploy 存储集群由于官方的源再国内访问所以需要使用第国内供的软件源，通过配置环境变量使用 aliyun 提供的 ceph-mimic 版本的仓库。 1# export CEPH_DEPLOY_REPO_URL=https://mirrors.aliyun.com/ceph/debian-mimic 创建集群先在管理节点上创建一个目录，用于保存 ceph-deploy 生成的配置文件和密钥对。 # mkdir my-cluster # cd my-cluster 然后开始创建监控节点： # ceph-deploy new 监控节点主机名 这里需要把所有设备配置好免密登录，以及把所有设备的主机名和IP的对应关系写入管理节点的 hosts ，防止网络发现没有生效。另外因为 ceph-deploy 是直接调用 ssh 远程操作节点，而且会使用 sudo ，而且不支持 root 登录（官方的口径是 root 不支持 sudo ，但是实际上是可以用的。），所以要配置好用户的 sudo 免密操作。 配置文件ceph 自带的容灾配置，默认是保存三份副本，可以把 osd pool default size = 3 写入 Ceph 配置文件的 [global] 段下。更改为其他数量。 另外如果你有多个网卡，也可以可以把 public network 写入 Ceph 配置文件的 [global] 段下。 以下是我的配置文件： 1234567891011121314[global]fsid = aa7852b8-dd0b-40d4-a2f4-bd1f38c6dc69mon_initial_members = node3, node4mon_host = 192.168.1.3,192.168.1.4auth_cluster_required = cephxauth_service_required = cephxauth_client_required = cephxosd pool default pg num = 4096osd pool default pgp num = 4096osd pool default size = 3mon_allow_pool_delete = truemon clock drift allowed = 0.1mon data avail warn = 10osd pool default min size = 1 为所有节点安装 Ceph# ceph-deploy install 所有节点主机名（包括管理节点） 配置初始 monitor(s)、并收集所有密钥# ceph-deploy mon create-initial 如有报错，请检查管理节点的 &#x2F;etc&#x2F;hosts、~&#x2F;.ssh&#x2F;config 里的所有主机名和 IP 与监控节点的主机名和 IP 名一致。另外还有多个节点 创建集群分发管理节点的配置以及密钥# ceph-deploy admin 所有节点名 为监控节点部署管理器守护程序# ceph-deploy mgr create 所有监控节点 创建 OSD# ceph-deploy osd create --data &#123;device&#125; &#123;ceph-node&#125; 示例：ceph-deploy osd create --data /dev/sdb node30 OSD 创建完毕后再检查一些集群的健康情况(当使用ceph时需要使用管理员权限)： # ceph health 也可以用 ceph -s 查看集群的详细信息。 123456789101112131415vm@Lotus-Master ~/my-cluster % sudo ceph -s cluster: id: 8d24cae1-07a9-4c3c-a74c-d0b56e4ad243 health: HEALTH_OK services: mon: 2 daemons, quorum node3,node4 (age 2m) mgr: node7(active, since 43m), standbys: node8, node9, node10, node11, node12, node15, node16, node6, node14, node18, Lotus-Master, node3, node5, node4 osd: 14 osds: 14 up (since 2m), 14 in (since 15m) data: pools: 0 pools, 0 pgs objects: 0 objects, 0 B usage: 14 GiB used, 114 TiB / 114 TiB avail pgs: 创建 Cephfs创建 mds 节点# ceph-deploy mds create &#123;ceph-node&#125; CephFS 中的所有元数据操作都通过 mds 进行，因此至少需要一台 mds 节点。为了防止单点故障，在这里可以配置多个mds 服务器。默认的 创建 pool# ceph osd pool create cephfs_data 2048 # ceph osd pool create cephfs_meta 512 创建了一个名为 cephfs_data 和一个名为 cephfs_meta 的 pool 。关于 pg 数量的配置公式如下。当使用公式计算时，pg 数一定要是贴近计算值的2的指数值。譬如有两百个 OSD ，两个 pool ，三个副本，则计算值为200*100&#x2F;2&#x2F;3&#x3D;4000，pg 值应设置为最接近 4000 的 2 的指数值 4096。其中 cephfs 的 data pool 和 metadata pool 的 pg 数按 ceph官方邮件 讨论中来说，建议是 4：1 的比例。 123 (OSDs * 100)Total PGs = --------------------------------------- (pool count) * (max replication count) 另外可通过 sudo ceph osd lspools 来查看已有的 pool，如果要删除 pool 可以使用以下命令： # ceph osd pool delete cephfs_data cephfs_data --yes-i-really-really-mean-it 创建 cephfs# ceph fs new mycephfs cephfs_meta cephfs_data 挂载 cephfs监控节点的密钥可以通过在监控节点执行 “sudo cat &#x2F;etc&#x2F;ceph&#x2F;ceph.client.admin.keyring|grep key|cut -d” “ -f3” 获取。 # mount -t ceph 监控节点IP:6789:/ 目录挂载点 -o name=admin,secret=&quot;监控节点密钥&quot;,acl,async,rw,noexec,nodev,noatime,nodiratime 示例： # mount -t ceph 192.168.1.30:6789,192.168.1.32:6789,192.168.1.34:6789,192.168.1.35:6789,192.168.1.37:6789:/ /lotus -o name=admin,secret=&quot;AQCyVdde8Y5EDBAAQCrFCJYVsmXZHAZC+4mAJQ==&quot;,acl,async,rw,noexec,nodev,noatime,nodiratime 实施中遇到的其他问题 用parted分区后的分区表不会立即生效，需要重启。如果不想重启，可以使用 partprobe 命令，此命令可以让系统内核重新读取分区表信息，就不用重新启动电脑。 如果硬盘在使用之前已经有了 GPT 分区创建 OSD 的时候就会报报 error: GPT headers found ，这时可以直接用 dd 将 GPT 分区删掉： 1# dd if=/dev/zero of=/dev/sdb bs=512K count=1 如果需要添加的硬盘在已存在的lvm卷组里，譬如重置环境后需要加入新的集群的 osd ，可以用以下命令先脱离 lvm ，再删除GPT分区： 123# lvremove -vf `lvdisplay|grep &quot;LV Path&quot;|awk &#x27;&#123;print $3&#125;&#x27;`# vgremove -vf `vgdisplay|grep &quot;VG Name&quot;|awk &#x27;&#123;print $3&#125;&#x27;`# pvremove -vf `pvdisplay|grep &quot;PV Name&quot;|awk &#x27;&#123;print $3&#125;&#x27;` 修改 ceph.conf后要使用 ceph-deploy --overwrite-conf config push 所有节点名称 来把新配置推送到所有节点上。 如果删除 pool 报错 Error EPERM: pool deletion is disabled; you must first set the mon_allow_pool_delete config option to true before you can destroy a pool ，则可以添加 mon_allow_pool_delete = true 到 ceph.conf ，然后执行 ceph osd pool delete lotus lotus --yes-i-really-really-mean-it ，或者用下面的方法 12# ceph tell mon.\\* injectargs &#x27;--mon-allow-pool-delete=true&#x27;# ceph osd pool delete lotus lotus --yes-i-really-really-mean-it 错误： # rbd: create error: (33) Numerical argument out of domain # 2020-03-09 22:38:32.177 7fe1a39ecf40 -1 librbd::image::CreateRequest: validate_order: order must be in the range [12, 25] 原因：rbd_default_order 配置过高，这个配置项决定了集群内切块的大小，默认是22，范围是[12, 25]，不在这个范围都会报错。 错误：集群大小与实际存储容量不符合 原因：RBD 进行数据删除的时候实际上并不会直接删除对象，而是给对象打上已删除的标记，所以删除内容还是在集群内占用空间。这里需要通过文件系统去主动释放被标记为已删除的对象 sudo fstrim rbd挂载目录 。 错误：pg 数设置错误，需要调整 解决方法（另外这里需要注意，pg 数不能一次性扩大太多，每次调整的大小尽量不要超过100%）： # ceph osd pool set cephfs_data pg_num 4096 # ceph osd pool set cephfs_data pgp_num 4096 错误：监控节点数量添加少了，需要调整 解决方法： # ceph-deploy mon add 新增监视器主机名 这里有一点要注意，所有监视器一定要设置 NTP 同步，尽量选择同一个 NTP 服务器进行同步。 而一旦添加了新的Ceph监视器，Ceph将开始同步监视器并形成仲裁。可以通过执行以下操作检查仲裁状态： # ceph quorum_status --format json-pretty 错误：cephfs出现错误需要重建，删除pool却显示pool正在被cephfs使用中 解决方法： 首先停止mds的服务 # systemctl stop ceph-mds@$HOSTNAME 然后 设置mds为失败 # ceph mds fail 0 接着删除cephfs # ceph fs rm mycephfs --yes-i-really-mean-it 然后删除cephfs使用的pool # ceph osd pool delete lotus lotus --yes-i-really-really-mean-it","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jugg.xyz/tags/Linux/"},{"name":"Ceph","slug":"Ceph","permalink":"https://blog.jugg.xyz/tags/Ceph/"}]},{"title":"记一次 Python 脚本坑","slug":"ops/Python-Exercises","date":"2019-10-09T17:09:42.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2019/10/09/ops/Python-Exercises/","permalink":"https://blog.jugg.xyz/2019/10/09/ops/Python-Exercises/","excerpt":"","text":"起因公司有百来台矿机接入 f2pool 在挖 eth ，但是系统用的并不是我们自己的，也没办法提供权限，所以监控上有一点麻烦。还好 f2pool 也算是比较大的矿池了，看了一下，有提供 api 给用户使用，就写一个监控脚本吧。蛤？ f2pool 还提供微信推送监控？emmmm………别人的哪有自己写的好（其实是因为没有需求也要创造需求（逃 需求 记录掉线矿机 ID 以及掉线时间 矿机掉线推送消息到 telegram channel 矿机上线后消息自动删除，防止 channel 内消息过多 设计123456789101112131415def main(): 通过 getData() 函数获得推送消息的输出内容以及是否推送的判断，调用 saveLog() 函数并将推送消息内容作为传参，同时将接收系统当前时间的返回值，通过 if 判断消息是否推送，如推送则调用 postMessages()函数开始推送。def getData(): requests.get 获取访问 api ，通过 decode 方法解码返回值的 content 属性内容，得到完整的 json 数据。然后通过 json.loads 将 json 数据转换成 dict 数据，通过 get 方法取得矿机总数，总算力以及所有矿机详细数据。 再通过循环取所有矿机的最后一次提交时间，将矿机带时区格式的最后提交时间转换成时间戳格式与当前时间比对，超过十分钟的就算掉线矿机。同时为避免下架矿机频繁推送造成影响，选择掉线超过八小时则默认掉线设备，不予统计。将所有掉线设备计入列表，并综合所有数据产生输出以及是否推送的判断作为返回值。 def deleteMessage(messageID): 接受传递过来的消息 ID ，通过 api 删除该消息。 def postMessages(minerData): 通过api推送消息，并记录返回值，将推送消息 ID 存下，二十分钟后调用 deleteMessage() 函数自动删除该消息，防止 channel 内消息过多，影响查看。 def saveLog(minerData): 接受推送内容参数并记录到 log 文件，同时将当前设备时间作为返回值。 坑我是比较喜欢新鲜技术的人，俗称小白鼠，所以脚本定时推送选了 systemd timer （其实也并不新，已经沦为主流了），结果推送几乎每两天就挂掉一次，于是开始排查。 第一个版本我写入日志用的是 open() 函数，但是我没有写 close() ，我怀疑是不是文件流打开没有关闭导致的推送卡住，于是我学会了 with-as 语句。然而现实是残酷的，没两天推送又挂了。我开始怀疑是 systemd 的锅，尝试了各种配置方案，无果。最终，偶然在手动调试的时候发现 api 有时候不会返回数据，而且会一直卡在这，我立刻醒悟过来，可能是 requests 拿不到数据反而把自己耽误了，于是加上 timeout 终于了结了。 其实这里我还是有点疑惑，我 systemd 的配置写的是 oneshot ，按照 systemd 的说明，这个选项应该是无论程序执行结果，都会去执行下一次任务，但是却也被卡住了，也许我还没有找到真正的原因…… 代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#!/bin/env pythonimport jsonimport requestsimport timefrom threading import TimerISOTIMEFORMAT = &#x27;%Y-%m-%d %H:%M:%S&#x27;LINE = &quot;\\n-------------------------------------------------------------------------------------------------------&quot;DELETETIME = 1190URL = &#123;&#x27;sendMessage&#x27;: &#x27;**YOURTGBOTAPIKEY**/sendMessage&#x27;, &#x27;deleteMessage&#x27;: &#x27;**YOURTGBOTAPIKEY**/deleteMessage&#x27;&#125;def getData(): # 从 f2pool api 获取矿机实时数据 ethminer = requests.get( url=&#x27;**YOURURL**&#x27;, timeout=30) ethminerDict = json.loads(ethminer.content.decode()) minerNumber = ethminerDict.get(&#x27;worker_length&#x27;) minerWorkers = ethminerDict.get(&#x27;workers&#x27;) minerHashrate = (ethminerDict.get(&#x27;hashrate&#x27;)/1000000) # 统计掉线矿机 ID 及掉线时间 dict0 = &#123;&#125; for i in range(minerNumber): minerTime = (minerWorkers[i][6]) minerTimeArray = time.strptime(minerTime, &quot;%Y-%m-%dT%H:%M:%S.%fZ&quot;) minerTimeStamp = time.mktime(minerTimeArray) timeNow = time.mktime(time.gmtime(time.time())) timeDiff = (timeNow-minerTimeStamp) if 28800 &gt; timeDiff &gt; 600: dict0[minerWorkers[i][0]] = &quot;已掉线&quot;+str(timeDiff//60)+&quot;分钟&quot; # 判断是否有矿机掉线或者算力不正常 offlineNumber = len(dict0) if dict0 or minerHashrate &lt; 30000: judge = True else: judge = False dict0 = &quot;无&quot; # 回传判断与推送消息 minerData = &quot;不得了了,矿机掉线了！&quot;+&quot;\\r\\n&quot;+&quot;目前掉线&quot; + \\ str(offlineNumber)+&quot;台,掉线设备ID为:&quot;+&quot;\\r\\n&quot;+str(dict0) + \\ &quot;\\r\\n&quot;+&quot;所有矿机总算力为&quot;+str(minerHashrate)+&quot;MH/s&quot; print(judge,minerData) return judge, minerData# 自动删除消息推送def deleteMessage(messageID): deletePost = requests.post(URL[&#x27;deleteMessage&#x27;], data=&#123;&#x27;chat_id&#x27;: &#x27;-1001241741624&#x27;, &#x27;message_id&#x27;: messageID&#125;) print(deletePost)# 推送消息def postMessages(minerData): pushPost = requests.post(URL[&#x27;sendMessage&#x27;], data=&#123;&#x27;chat_id&#x27;: &#x27;-1001241741624&#x27;, &#x27;text&#x27;: minerData&#125;) pushReturn = json.loads(pushPost.text) messageID = pushReturn[&quot;result&quot;][&quot;message_id&quot;] sleepSometime = Timer(DELETETIME, deleteMessage, [messageID]) sleepSometime.start()# 保存推送内容def saveLog(minerData): timeNowStr = time.strftime(ISOTIMEFORMAT, time.localtime(time.time())) with open(&#x27;/var/log/push/log&#x27;, &#x27;a+&#x27;) as getLog: print(&quot;现在是UTC时间:&quot;, timeNowStr, minerData, LINE, file=getLog) return timeNowStrdef main(): judge, minerData = getData() timeNowStr = saveLog(minerData) if judge: postMessages(minerData) else: print(timeNowStr, &quot;我安澜，从不掉线&quot;)if __name__ == &quot;__main__&quot;: main() ethminer_push.service: 1234567[Unit]Description=ethminer push serviceWants=ethminer_push.timer[Service]Type=oneshotExecStart=/bin/python &quot;/usr/local/bin/push.py&quot; ethminer_push.timer: 123456789101112[Unit]Description=every 10 minute to get[Timer]OnBootSec=5minOnCalendar=*:0/5Persistent=true[Install]WantedBy=timers.target","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://blog.jugg.xyz/tags/Python/"}]},{"title":"关于 Limits 的一些常识","slug":"ops/Common-Sense-About-The-Limits","date":"2019-09-22T17:09:42.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2019/09/22/ops/Common-Sense-About-The-Limits/","permalink":"https://blog.jugg.xyz/2019/09/22/ops/Common-Sense-About-The-Limits/","excerpt":"","text":"前言最近部署的一个项目，启动十几个小时后就报错了，看了下日志输出是 Too many open files 。放到搜索引擎查了下，了解到是系统默认进程最大打开文件描述符数太小导致的，所以解决问题后顺便来记录一下。（其实是为了水一篇博客） 关于用户的限制/etc/security/limits.conf 文件是用来限制用户的资源使用，防止系统被fork炸弹占用所有资源的有效方法，具体配置信息可以在 limit.conf (Arch manual pages) 里详细了解，可配置项很多。我们日常要用到的主要是其中的两项：nproc 和 nofile。 nproc 是用户最大可打开进程数。用 # ps -u &lt;user&gt;|grep -v PID|wc -l 可以查看用户当然打开进程数。（ps，grep，wc这三个进程也包括在内）下面提供两个nproc的修改示例。 12* hard nproc 2048 # *匹配所有用户；%可以匹配组root hard nproc 65536 # hard是硬限制，是系统不允许用户启动进程超过的上限；soft是软限制，是由用户限制进程不得超过的上限 nofile 是进程最大可打开文件描述符数。用ulimit -n可以查看当前用户的限制，用 $ cat /proc/&lt;PID&gt;/limits 可以该 PID 的所有资源限制。下面提供两个nofile的修改示例。 12* hard nofile 8192 root hard nofile unlimited # unlimited是不做限制 关于系统的限制系统最大可打开的文件描述符数通过 $ cat /proc/sys/fs/file-max 查看，当前系统打开文件描述符总数可以通过 # cat /proc/sys/fs/file-nr 查看，其中第一个数表示当前系统正在使用的文件描述符数，第二个数为目前不再使用的，第三个数则等于/proc/sys/fs/file-max。而如果要修改系统文件描述符限制则需要更改 /etc/sysctl.conf 文件，例如： 1# echo &quot;fs.file-max = 1000000&quot; &gt;&gt; /etc/sysctl.conf 另外，file-max是限制系统内核可分配的最大文件数，而单个进程最大可分配的文件数则是用 $ cat /proc/sys/fs/nr_open 查看，修改方式则较为类似： 1# echo &quot;fs.nr_open = 1000000&quot; &gt;&gt; /etc/sysctl.conf # nr_open不可大于file-max 结语简单的介绍了一下关于设备资源的限制的常识，可以发现其中很多都会牵扯到 /proc 这个目录，这是一个让你能和内核内部数据结构进行交互，获取相关进程有用信息的目录，也是一个独立的文件系统，下次我们就来聊聊 /proc 吧。","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jugg.xyz/tags/Linux/"},{"name":"Limits","slug":"Limits","permalink":"https://blog.jugg.xyz/tags/Limits/"}]},{"title":"命令行的艺术","slug":"repost/the-art-of-command-line","date":"2019-05-30T18:58:47.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2019/05/30/repost/the-art-of-command-line/","permalink":"https://blog.jugg.xyz/2019/05/30/repost/the-art-of-command-line/","excerpt":"","text":"本文转载自 the-art-of-command-line [ Join the chat at https://gitter.im/jlevy/the-art-of-command-line](https://badges.gitter.im/Join%20Chat.svg) 前言 基础 日常使用 文件及数据处理 系统调试 单行脚本 冷门但有用 仅限 OS X 系统 仅限 Windows 系统 在 Winodws 下获取 Unix 工具 实用 Windows 命令行工具 Cygwin 技巧 更多资源 免责声明 授权条款 cowsay 熟练使用命令行是一种常常被忽视，或被认为难以掌握的技能，但实际上，它会提高你作为工程师的灵活性以及生产力。本文是一份我在 Linux 上工作时，发现的一些命令行使用技巧的摘要。有些技巧非常基础，而另一些则相当复杂，甚至晦涩难懂。这篇文章并不长，但当你能够熟练掌握这里列出的所有技巧时，你就学会了很多关于命令行的东西了。 这篇文章是许多作者和译者共同的成果。这里的部分内容首次出现于 Quora，但已经迁移到了 Github，并由众多高手做出了许多改进。如果你在本文中发现了错误或者存在可以改善的地方，请贡献你的一份力量。 前言涵盖范围： 这篇文章不仅能帮助刚接触命令行的新手，而且对具有经验的人也大有裨益。本文致力于做到覆盖面广（涉及所有重要的内容），具体（给出具体的最常用的例子），以及简洁（避免冗余的内容，或是可以在其他地方轻松查到的细枝末节）。在特定应用场景下，本文的内容属于基本功或者能帮助您节约大量的时间。 本文主要为 Linux 所写，但在仅限 OS X 系统章节和仅限 Windows 系统章节中也包含有对应操作系统的内容。除去这两个章节外，其它的内容大部分均可在其他类 Unix 系统或 OS X，甚至 Cygwin 中得到应用。 本文主要关注于交互式 Bash，但也有很多技巧可以应用于其他 shell 和 Bash 脚本当中。 除去“标准的”Unix 命令，本文还包括了一些依赖于特定软件包的命令（前提是它们具有足够的价值）。 注意事项： 为了能在一页内展示尽量多的东西，一些具体的信息可以在引用的页面中找到。我们相信机智的你知道如何使用 Google 或者其他搜索引擎来查阅到更多的详细信息。文中部分命令需要您使用 apt-get，yum，dnf，pacman，pip 或 brew（以及其它合适的包管理器）来安装依赖的程序。 遇到问题的话，请尝试使用 Explainshell 去获取相关命令、参数、管道等内容的解释。 基础 学习 Bash 的基础知识。具体地，在命令行中输入 man bash 并至少全文浏览一遍; 它理解起来很简单并且不冗长。其他的 shell 可能很好用，但 Bash 的功能已经足够强大并且到几乎总是可用的（ 如果你只学习 zsh，fish 或其他的 shell 的话，在你自己的设备上会显得很方便，但过度依赖这些功能会给您带来不便，例如当你需要在服务器上工作时）。 熟悉至少一个基于文本的编辑器。通常而言 Vim （vi） 会是你最好的选择，毕竟在终端中编辑文本时 Vim 是最好用的工具（甚至大部分情况下 Vim 要比 Emacs、大型 IDE 或是炫酷的编辑器更好用）。 学会如何使用 man 命令去阅读文档。学会使用 apropos 去查找文档。知道有些命令并不对应可执行文件，而是在 Bash 内置好的，此时可以使用 help 和 help -d 命令获取帮助信息。你可以用 type 命令 来判断这个命令到底是可执行文件、shell 内置命令还是别名。 学会使用 &gt; 和 &lt; 来重定向输出和输入，学会使用 | 来重定向管道。明白 &gt; 会覆盖了输出文件而 &gt;&gt; 是在文件末添加。了解标准输出 stdout 和标准错误 stderr。 学会使用通配符 * （或许再算上 ? 和 […]） 和引用以及引用中 &#39; 和 &quot; 的区别（后文中有一些具体的例子）。 熟悉 Bash 中的任务管理工具：&amp;，ctrl-z，ctrl-c，jobs，fg，bg，kill 等。 学会使用 ssh 进行远程命令行登录，最好知道如何使用 ssh-agent，ssh-add 等命令来实现基础的无密码认证登录。 学会基本的文件管理工具：ls 和 ls -l （了解 ls -l 中每一列代表的意义），less，head，tail 和 tail -f （甚至 less +F），ln 和 ln -s （了解硬链接与软链接的区别），chown，chmod，du （硬盘使用情况概述：du -hs *）。 关于文件系统的管理，学习 df，mount，fdisk，mkfs，lsblk。知道 inode 是什么（与 ls -i 和 df -i 等命令相关）。 学习基本的网络管理工具：ip 或 ifconfig，dig。 学习并使用一种版本控制管理系统，例如 git。 熟悉正则表达式，学会使用 grep／egrep，它们的参数中 -i，-o，-v，-A，-B 和 -C 这些是很常用并值得认真学习的。 学会使用 apt-get，yum，dnf 或 pacman （具体使用哪个取决于你使用的 Linux 发行版）来查找和安装软件包。并确保你的环境中有 pip 来安装基于 Python 的命令行工具 （接下来提到的部分程序使用 pip 来安装会很方便）。 日常使用 在 Bash 中，可以通过按 Tab 键实现自动补全参数，使用 ctrl-r 搜索命令行历史记录（按下按键之后，输入关键字便可以搜索，重复按下 ctrl-r 会向后查找匹配项，按下 Enter 键会执行当前匹配的命令，而按下右方向键会将匹配项放入当前行中，不会直接执行，以便做出修改）。 在 Bash 中，可以按下 ctrl-w 删除你键入的最后一个单词，ctrl-u 可以删除行内光标所在位置之前的内容，alt-b 和 alt-f 可以以单词为单位移动光标，ctrl-a 可以将光标移至行首，ctrl-e 可以将光标移至行尾，ctrl-k 可以删除光标至行尾的所有内容，ctrl-l 可以清屏。键入 man readline 可以查看 Bash 中的默认快捷键。内容有很多，例如 alt-. 循环地移向前一个参数，而 alt-* 可以展开通配符。 你喜欢的话，可以执行 set -o vi 来使用 vi 风格的快捷键，而执行 set -o emacs 可以把它改回来。 为了便于编辑长命令，在设置你的默认编辑器后（例如 export EDITOR=vim），ctrl-x ctrl-e 会打开一个编辑器来编辑当前输入的命令。在 vi 风格下快捷键则是 escape-v。 键入 history 查看命令行历史记录，再用 !n（n 是命令编号）就可以再次执行。其中有许多缩写，最有用的大概就是 !$， 它用于指代上次键入的参数，而 !! 可以指代上次键入的命令了（参考 man 页面中的“HISTORY EXPANSION”）。不过这些功能，你也可以通过快捷键 ctrl-r 和 alt-. 来实现。 cd 命令可以切换工作路径，输入 cd ~ 可以进入 home 目录。要访问你的 home 目录中的文件，可以使用前缀 ~（例如 ~/.bashrc）。在 sh 脚本里则用环境变量 $HOME 指代 home 目录的路径。 回到前一个工作路径：cd -。 如果你输入命令的时候中途改了主意，按下 alt-# 在行首添加 # 把它当做注释再按下回车执行（或者依次按下 ctrl-a， **#**， enter）。这样做的话，之后借助命令行历史记录，你可以很方便恢复你刚才输入到一半的命令。 使用 xargs （ 或 parallel）。他们非常给力。注意到你可以控制每行参数个数（-L）和最大并行数（-P）。如果你不确定它们是否会按你想的那样工作，先使用 xargs echo 查看一下。此外，使用 -I&#123;&#125; 会很方便。例如： 12find . -name &#x27;*.py&#x27; | xargs grep some_functioncat hosts | xargs -I&#123;&#125; ssh root@&#123;&#125; hostname pstree -p 以一种优雅的方式展示进程树。 使用 pgrep 和 pkill 根据名字查找进程或发送信号（-f 参数通常有用）。 了解你可以发往进程的信号的种类。比如，使用 kill -STOP [pid] 停止一个进程。使用 man 7 signal 查看详细列表。 使用 nohup 或 disown 使一个后台进程持续运行。 使用 netstat -lntp 或 ss -plat 检查哪些进程在监听端口（默认是检查 TCP 端口; 添加参数 -u 则检查 UDP 端口）或者 lsof -iTCP -sTCP:LISTEN -P -n (这也可以在 OS X 上运行)。 lsof 来查看开启的套接字和文件。 使用 uptime 或 w 来查看系统已经运行多长时间。 使用 alias 来创建常用命令的快捷形式。例如：alias ll=&#39;ls -latr&#39; 创建了一个新的命令别名 ll。 可以把别名、shell 选项和常用函数保存在 ~/.bashrc，具体看下这篇文章。这样做的话你就可以在所有 shell 会话中使用你的设定。 把环境变量的设定以及登陆时要执行的命令保存在 ~/.bash_profile。而对于从图形界面启动的 shell 和 cron 启动的 shell，则需要单独配置文件。 要想在几台电脑中同步你的配置文件（例如 .bashrc 和 .bash_profile），可以借助 Git。 当变量和文件名中包含空格的时候要格外小心。Bash 变量要用引号括起来，比如 &quot;$FOO&quot;。尽量使用 -0 或 -print0 选项以便用 NULL 来分隔文件名，例如 locate -0 pattern | xargs -0 ls -al 或 find / -print0 -type d | xargs -0 ls -al。如果 for 循环中循环访问的文件名含有空字符（空格、tab 等字符），只需用 IFS=$&#39;\\n&#39; 把内部字段分隔符设为换行符。 在 Bash 脚本中，使用 set -x 去调试输出（或者使用它的变体 set -v，它会记录原始输入，包括多余的参数和注释）。尽可能地使用严格模式：使用 set -e 令脚本在发生错误时退出而不是继续运行；使用 set -u 来检查是否使用了未赋值的变量；试试 set -o pipefail，它可以监测管道中的错误。当牵扯到很多脚本时，使用 trap 来检测 ERR 和 EXIT。一个好的习惯是在脚本文件开头这样写，这会使它能够检测一些错误，并在错误发生时中断程序并输出信息： 12set -euo pipefailtrap &quot;echo &#x27;error: Script failed: see failed command above&#x27;&quot; ERR 在 Bash 脚本中，子 shell（使用括号 (...)）是一种组织参数的便捷方式。一个常见的例子是临时地移动工作路径，代码如下： 123# do something in current dir(cd /some/other/dir &amp;&amp; other-command)# continue in original dir 在 Bash 中，变量有许多的扩展方式。$&#123;name:?error message&#125; 用于检查变量是否存在。此外，当 Bash 脚本只需要一个参数时，可以使用这样的代码 input_file=$&#123;1:?usage: $0 input_file&#125;。在变量为空时使用默认值：$&#123;name:-default&#125;。如果你要在之前的例子中再加一个（可选的）参数，可以使用类似这样的代码 output_file=$&#123;2:-logfile&#125;，如果省略了 $2，它的值就为空，于是 output_file 就会被设为 logfile。数学表达式：i=$(( (i + 1) % 5 ))。序列：&#123;1..10&#125;。截断字符串：$&#123;var%suffix&#125; 和 $&#123;var#prefix&#125;。例如，假设 var=foo.pdf，那么 echo $&#123;var%.pdf&#125;.txt 将输出 foo.txt。 使用括号扩展（&#123;…&#125;）来减少输入相似文本，并自动化文本组合。这在某些情况下会很有用，例如 mv foo.&#123;txt,pdf&#125; some-dir（同时移动两个文件），cp somefile&#123;,.bak&#125;（会被扩展成 cp somefile somefile.bak）或者 mkdir -p test-&#123;a,b,c&#125;/subtest-&#123;1,2,3&#125;（会被扩展成所有可能的组合，并创建一个目录树）。 通过使用 &lt;(some command) 可以将输出视为文件。例如，对比本地文件 /etc/hosts 和一个远程文件： 1diff /etc/hosts &lt;(ssh somehost cat /etc/hosts) 编写脚本时，你可能会想要把代码都放在大括号里。缺少右括号的话，代码就会因为语法错误而无法执行。如果你的脚本是要放在网上分享供他人使用的，这样的写法就体现出它的好处了，因为这样可以防止下载不完全代码被执行。 123&#123; # 在这里写代码&#125; 了解 Bash 中的“here documents”，例如 cat &lt;&lt;EOF ...。 在 Bash 中，同时重定向标准输出和标准错误：some-command &gt;logfile 2&gt;&amp;1 或者 some-command &amp;&gt;logfile。通常，为了保证命令不会在标准输入里残留一个未关闭的文件句柄捆绑在你当前所在的终端上，在命令后添加 &lt;/dev/null 是一个好习惯。 使用 man ascii 查看具有十六进制和十进制值的ASCII表。man unicode，man utf-8，以及 man latin1 有助于你去了解通用的编码信息。 使用 screen 或 tmux 来使用多份屏幕，当你在使用 ssh 时（保存 session 信息）将尤为有用。而 byobu 可以为它们提供更多的信息和易用的管理工具。另一个轻量级的 session 持久化解决方案是 dtach。 ssh 中，了解如何使用 -L 或 -D（偶尔需要用 -R）开启隧道是非常有用的，比如当你需要从一台远程服务器上访问 web 页面。 对 ssh 设置做一些小优化可能是很有用的，例如这个 ~/.ssh/config 文件包含了防止特定网络环境下连接断开、压缩数据、多通道等选项： 1234567TCPKeepAlive=yesServerAliveInterval=15ServerAliveCountMax=6Compression=yesControlMaster autoControlPath /tmp/%r@%h:%pControlPersist yes 一些其他的关于 ssh 的选项是与安全相关的，应当小心翼翼的使用。例如你应当只能在可信任的网络中启用 StrictHostKeyChecking=no，ForwardAgent=yes。 考虑使用 mosh 作为 ssh 的替代品，它使用 UDP 协议。它可以避免连接被中断并且对带宽需求更小，但它需要在服务端做相应的配置。 获取八进制形式的文件访问权限（修改系统设置时通常需要，但 ls 的功能不那么好用并且通常会搞砸），可以使用类似如下的代码： 1stat -c &#x27;%A %a %n&#x27; /etc/timezone 使用 percol 或者 fzf 可以交互式地从另一个命令输出中选取值。 使用 fpp（PathPicker）可以与基于另一个命令(例如 git）输出的文件交互。 将 web 服务器上当前目录下所有的文件（以及子目录）暴露给你所处网络的所有用户，使用：python -m SimpleHTTPServer 7777 （使用端口 7777 和 Python 2）或python -m http.server 7777 （使用端口 7777 和 Python 3）。 以其他用户的身份执行命令，使用 sudo。默认以 root 用户的身份执行；使用 -u 来指定其他用户。使用 -i 来以该用户登录（需要输入_你自己的_密码）。 将 shell 切换为其他用户，使用 su username 或者 sudo - username。加入 - 会使得切换后的环境与使用该用户登录后的环境相同。省略用户名则默认为 root。切换到哪个用户，就需要输入_哪个用户的_密码。 了解命令行的 128K 限制。使用通配符匹配大量文件名时，常会遇到“Argument list too long”的错误信息。（这种情况下换用 find 或 xargs 通常可以解决。） 当你需要一个基本的计算器时，可以使用 python 解释器（当然你要用 python 的时候也是这样）。例如： 12&gt;&gt;&gt; 2+35 文件及数据处理 在当前目录下通过文件名查找一个文件，使用类似于这样的命令：find . -iname &#39;*something*&#39;。在所有路径下通过文件名查找文件，使用 locate something （但注意到 updatedb 可能没有对最近新建的文件建立索引，所以你可能无法定位到这些未被索引的文件）。 使用 ag 在源代码或数据文件里检索（grep -r 同样可以做到，但相比之下 ag 更加先进）。 将 HTML 转为文本：lynx -dump -stdin。 Markdown，HTML，以及所有文档格式之间的转换，试试 pandoc。 当你要处理棘手的 XML 时候，xmlstarlet 算是上古时代流传下来的神器。 使用 jq 处理 JSON。 使用 shyaml 处理 YAML。 要处理 Excel 或 CSV 文件的话，csvkit 提供了 in2csv，csvcut，csvjoin，csvgrep 等方便易用的工具。 当你要处理 Amazon S3 相关的工作的时候，s3cmd 是一个很方便的工具而 s4cmd 的效率更高。Amazon 官方提供的 aws 以及 saws 是其他 AWS 相关工作的基础，值得学习。 了解如何使用 sort 和 uniq，包括 uniq 的 -u 参数和 -d 参数，具体内容在后文单行脚本节中。另外可以了解一下 comm。 了解如何使用 cut，paste 和 join 来更改文件。很多人都会使用 cut，但遗忘了 join。 了解如何运用 wc 去计算新行数（-l），字符数（-m），单词数（-w）以及字节数（-c）。 了解如何使用 tee 将标准输入复制到文件甚至标准输出，例如 ls -al | tee file.txt。 要进行一些复杂的计算，比如分组、逆序和一些其他的统计分析，可以考虑使用 datamash。 注意到语言设置（中文或英文等）对许多命令行工具有一些微妙的影响，比如排序的顺序和性能。大多数 Linux 的安装过程会将 LANG 或其他有关的变量设置为符合本地的设置。要意识到当你改变语言设置时，排序的结果可能会改变。明白国际化可能会使 sort 或其他命令运行效率下降许多倍。某些情况下（例如集合运算）你可以放心的使用 export LC_ALL=C 来忽略掉国际化并按照字节来判断顺序。 你可以单独指定某一条命令的环境，只需在调用时把环境变量设定放在命令的前面，例如 TZ=Pacific/Fiji date 可以获取斐济的时间。 了解如何使用 awk 和 sed 来进行简单的数据处理。 参阅 One-liners 获取示例。 替换一个或多个文件中出现的字符串： 1perl -pi.bak -e &#x27;s/old-string/new-string/g&#x27; my-files-*.txt 使用 repren 来批量重命名文件，或是在多个文件中搜索替换内容。（有些时候 rename 命令也可以批量重命名，但要注意，它在不同 Linux 发行版中的功能并不完全一样。） 123456# 将文件、目录和内容全部重命名 foo -&gt; bar:repren --full --preserve-case --from foo --to bar .# 还原所有备份文件 whatever.bak -&gt; whatever:repren --renames --from &#x27;(.*)\\.bak&#x27; --to &#x27;\\1&#x27; *.bak# 用 rename 实现上述功能（若可用）:rename &#x27;s/\\.bak$//&#x27; *.bak 根据 man 页面的描述，rsync 是一个快速且非常灵活的文件复制工具。它闻名于设备之间的文件同步，但其实它在本地情况下也同样有用。在安全设置允许下，用 rsync 代替 scp 可以实现文件续传，而不用重新从头开始。它同时也是删除大量文件的最快方法之一： 1mkdir empty &amp;&amp; rsync -r --delete empty/ some-dir &amp;&amp; rmdir some-dir 若要在复制文件时获取当前进度，可使用 pv，pycp，progress，rsync --progress。若所执行的复制为block块拷贝，可以使用 dd status=progress。 使用 shuf 可以以行为单位来打乱文件的内容或从一个文件中随机选取多行。 了解 sort 的参数。显示数字时，使用 -n 或者 -h 来显示更易读的数（例如 du -h 的输出）。明白排序时关键字的工作原理（-t 和 -k）。例如，注意到你需要 -k1，1 来仅按第一个域来排序，而 -k1 意味着按整行排序。稳定排序（sort -s）在某些情况下很有用。例如，以第二个域为主关键字，第一个域为次关键字进行排序，你可以使用 sort -k1，1 | sort -s -k2，2。 如果你想在 Bash 命令行中写 tab 制表符，按下 ctrl-v [Tab] 或键入 $&#39;\\t&#39; （后者可能更好，因为你可以复制粘贴它）。 标准的源代码对比及合并工具是 diff 和 patch。使用 diffstat 查看变更总览数据。注意到 diff -r 对整个文件夹有效。使用 diff -r tree1 tree2 | diffstat 查看变更的统计数据。vimdiff 用于比对并编辑文件。 对于二进制文件，使用 hd，hexdump 或者 xxd 使其以十六进制显示，使用 bvi，hexedit 或者 biew 来进行二进制编辑。 同样对于二进制文件，strings（包括 grep 等工具）可以帮助在二进制文件中查找特定比特。 制作二进制差分文件（Delta 压缩），使用 xdelta3。 使用 iconv 更改文本编码。需要更高级的功能，可以使用 uconv，它支持一些高级的 Unicode 功能。例如，这条命令移除了所有重音符号： 1uconv -f utf-8 -t utf-8 -x &#x27;::Any-Lower; ::Any-NFD; [:Nonspacing Mark:] &gt;; ::Any-NFC; &#x27; &lt; input.txt &gt; output.txt 拆分文件可以使用 split（按大小拆分）和 csplit（按模式拆分）。 操作日期和时间表达式，可以用 dateutils 中的 dateadd、datediff、strptime 等工具。 使用 zless、zmore、zcat 和 zgrep 对压缩过的文件进行操作。 文件属性可以通过 chattr 进行设置，它比文件权限更加底层。例如，为了保护文件不被意外删除，可以使用不可修改标记：sudo chattr +i /critical/directory/or/file 使用 getfacl 和 setfacl 以保存和恢复文件权限。例如： 12getfacl -R /some/path &gt; permissions.txtsetfacl --restore=permissions.txt 为了高效地创建空文件，请使用 truncate（创建稀疏文件），fallocate（用于 ext4，xfs，btrf 和 ocfs2 文件系统），xfs_mkfile（适用于几乎所有的文件系统，包含在 xfsprogs 包中），mkfile（用于类 Unix 操作系统，比如 Solaris 和 Mac OS）。 系统调试 curl 和 curl -I 可以被轻松地应用于 web 调试中，它们的好兄弟 wget 也是如此，或者也可以试试更潮的 httpie。 获取 CPU 和硬盘的使用状态，通常使用使用 top（htop 更佳），iostat 和 iotop。而 iostat -mxz 15 可以让你获悉 CPU 和每个硬盘分区的基本信息和性能表现。 使用 netstat 和 ss 查看网络连接的细节。 dstat 在你想要对系统的现状有一个粗略的认识时是非常有用的。然而若要对系统有一个深度的总体认识，使用 glances，它会在一个终端窗口中向你提供一些系统级的数据。 若要了解内存状态，运行并理解 free 和 vmstat 的输出。值得留意的是“cached”的值，它指的是 Linux 内核用来作为文件缓存的内存大小，而与空闲内存无关。 Java 系统调试则是一件截然不同的事，一个可以用于 Oracle 的 JVM 或其他 JVM 上的调试的技巧是你可以运行 kill -3 &lt;pid&gt; 同时一个完整的栈轨迹和堆概述（包括 GC 的细节）会被保存到标准错误或是日志文件。JDK 中的 jps，jstat，jstack，jmap 很有用。SJK tools 更高级。 使用 mtr 去跟踪路由，用于确定网络问题。 用 ncdu 来查看磁盘使用情况，它比寻常的命令，如 du -sh *，更节省时间。 查找正在使用带宽的套接字连接或进程，使用 iftop 或 nethogs。 ab 工具（Apache 中自带）可以简单粗暴地检查 web 服务器的性能。对于更复杂的负载测试，使用 siege。 wireshark，tshark 和 ngrep 可用于复杂的网络调试。 了解 strace 和 ltrace。这俩工具在你的程序运行失败、挂起甚至崩溃，而你却不知道为什么或你想对性能有个总体的认识的时候是非常有用的。注意 profile 参数（-c）和附加到一个运行的进程参数 （-p）。 了解使用 ldd 来检查共享库。但是永远不要在不信任的文件上运行。 了解如何运用 gdb 连接到一个运行着的进程并获取它的堆栈轨迹。 学会使用 /proc。它在调试正在出现的问题的时候有时会效果惊人。比如：/proc/cpuinfo，/proc/meminfo，/proc/cmdline，/proc/xxx/cwd，/proc/xxx/exe，/proc/xxx/fd/，/proc/xxx/smaps（这里的 xxx 表示进程的 id 或 pid）。 当调试一些之前出现的问题的时候，sar 非常有用。它展示了 cpu、内存以及网络等的历史数据。 关于更深层次的系统分析以及性能分析，看看 stap（SystemTap），perf，以及sysdig。 查看你当前使用的系统，使用 uname，uname -a（Unix／kernel 信息）或者 lsb_release -a（Linux 发行版信息）。 无论什么东西工作得很欢乐（可能是硬件或驱动问题）时可以试试 dmesg。 如果你删除了一个文件，但通过 du 发现没有释放预期的磁盘空间，请检查文件是否被进程占用：lsof | grep deleted | grep &quot;filename-of-my-big-file&quot; 单行脚本一些命令组合的例子： 当你需要对文本文件做集合交、并、差运算时，sort 和 uniq 会是你的好帮手。具体例子请参照代码后面的，此处假设 a 与 b 是两内容不同的文件。这种方式效率很高，并且在小文件和上 G 的文件上都能运用（注意尽管在 /tmp 在一个小的根分区上时你可能需要 -T 参数，但是实际上 sort 并不被内存大小约束），参阅前文中关于 LC_ALL 和 sort 的 -u 参数的部分。 123sort a b | uniq &gt; c # c 是 a 并 bsort a b | uniq -d &gt; c # c 是 a 交 bsort a b b | uniq -u &gt; c # c 是 a - b 使用 grep . *（每行都会附上文件名）或者 head -100 *（每个文件有一个标题）来阅读检查目录下所有文件的内容。这在检查一个充满配置文件的目录（如 /sys、/proc、/etc）时特别好用。 计算文本文件第三列中所有数的和（可能比同等作用的 Python 代码快三倍且代码量少三倍）： 1awk &#x27;&#123; x += $3 &#125; END &#123; print x &#125;&#x27; myfile 如果你想在文件树上查看大小&#x2F;日期，这可能看起来像递归版的 ls -l 但比 ls -lR 更易于理解： 1find . -type f -ls 假设你有一个类似于 web 服务器日志文件的文本文件，并且一个确定的值只会出现在某些行上，假设一个 acct_id 参数在 URI 中。如果你想计算出每个 acct_id 值有多少次请求，使用如下代码： 1egrep -o &#x27;acct_id=[0-9]+&#x27; access.log | cut -d= -f2 | sort | uniq -c | sort -rn 要持续监测文件改动，可以使用 watch，例如检查某个文件夹中文件的改变，可以用 watch -d -n 2 &#39;ls -rtlh | tail&#39;；或者在排查 WiFi 设置故障时要监测网络设置的更改，可以用 watch -d -n 2 ifconfig。 运行这个函数从这篇文档中随机获取一条技巧（解析 Markdown 文件并抽取项目）： 12345678function taocl() &#123; curl -s https://raw.githubusercontent.com/jlevy/the-art-of-command-line/master/README-zh.md| pandoc -f markdown -t html | iconv -f &#x27;utf-8&#x27; -t &#x27;unicode&#x27; | xmlstarlet fo --html --dropdtd | xmlstarlet sel -t -v &quot;(html/body/ul/li[count(p)&gt;0])[$RANDOM mod last()+1]&quot; | xmlstarlet unesc | fmt -80&#125; 冷门但有用 expr：计算表达式或正则匹配 m4：简单的宏处理器 yes：多次打印字符串 cal：漂亮的日历 env：执行一个命令（脚本文件中很有用） printenv：打印环境变量（调试时或在写脚本文件时很有用） look：查找以特定字符串开头的单词或行 cut，paste 和 join：数据修改 fmt：格式化文本段落 pr：将文本格式化成页／列形式 fold：包裹文本中的几行 column：将文本格式化成多个对齐、定宽的列或表格 expand 和 unexpand：制表符与空格之间转换 nl：添加行号 seq：打印数字 bc：计算器 factor：分解因数 gpg：加密并签名文件 toe：terminfo 入口列表 nc：网络调试及数据传输 socat：套接字代理，与 netcat 类似 slurm：网络流量可视化 dd：文件或设备间传输数据 file：确定文件类型 tree：以树的形式显示路径和文件，类似于递归的 ls stat：文件信息 time：执行命令，并计算执行时间 timeout：在指定时长范围内执行命令，并在规定时间结束后停止进程 lockfile：使文件只能通过 rm -f 移除 logrotate： 切换、压缩以及发送日志文件 watch：重复运行同一个命令，展示结果并／或高亮有更改的部分 when-changed：当检测到文件更改时执行指定命令。参阅 inotifywait 和 entr。 tac：反向输出文件 shuf：文件中随机选取几行 comm：一行一行的比较排序过的文件 strings：从二进制文件中抽取文本 tr：转换字母 iconv 或 uconv：文本编码转换 split 和 csplit：分割文件 sponge：在写入前读取所有输入，在读取文件后再向同一文件写入时比较有用，例如 grep -v something some-file | sponge some-file units：将一种计量单位转换为另一种等效的计量单位（参阅 /usr/share/units/definitions.units） apg：随机生成密码 xz：高比例的文件压缩 ldd：动态库信息 nm：提取 obj 文件中的符号 ab 或 wrk：web 服务器性能分析 strace：调试系统调用 mtr：更好的网络调试跟踪工具 cssh：可视化的并发 shell rsync：通过 ssh 或本地文件系统同步文件和文件夹 wireshark 和 tshark：抓包和网络调试工具 ngrep：网络层的 grep host 和 dig：DNS 查找 lsof：列出当前系统打开文件的工具以及查看端口信息 dstat：系统状态查看 glances：高层次的多子系统总览 iostat：硬盘使用状态 mpstat： CPU 使用状态 vmstat： 内存使用状态 htop：top 的加强版 last：登入记录 w：查看处于登录状态的用户 id：用户&#x2F;组 ID 信息 sar：系统历史数据 iftop 或 nethogs：套接字及进程的网络利用情况 ss：套接字数据 dmesg：引导及系统错误信息 sysctl： 在内核运行时动态地查看和修改内核的运行参数 hdparm：SATA&#x2F;ATA 磁盘更改及性能分析 lsblk：列出块设备信息：以树形展示你的磁盘以及磁盘分区信息 lshw，lscpu，lspci，lsusb 和 dmidecode：查看硬件信息，包括 CPU、BIOS、RAID、显卡、USB设备等 lsmod 和 modinfo：列出内核模块，并显示其细节 fortune，ddate 和 sl：额，这主要取决于你是否认为蒸汽火车和莫名其妙的名人名言是否“有用” 仅限 OS X 系统以下是仅限于 OS X 系统的技巧。 用 brew （Homebrew）或者 port （MacPorts）进行包管理。这些可以用来在 OS X 系统上安装以上的大多数命令。 用 pbcopy 复制任何命令的输出到桌面应用，用 pbpaste 粘贴输入。 若要在 OS X 终端中将 Option 键视为 alt 键（例如在上面介绍的 alt-b、alt-f 等命令中用到），打开 偏好设置 -&gt; 描述文件 -&gt; 键盘 并勾选“使用 Option 键作为 Meta 键”。 用 open 或者 open -a /Applications/Whatever.app 使用桌面应用打开文件。 Spotlight：用 mdfind 搜索文件，用 mdls 列出元数据（例如照片的 EXIF 信息）。 注意 OS X 系统是基于 BSD UNIX 的，许多命令（例如 ps，ls，tail，awk，sed）都和 Linux 中有微妙的不同（ Linux 很大程度上受到了 System V-style Unix 和 GNU 工具影响）。你可以通过标题为 “BSD General Commands Manual” 的 man 页面发现这些不同。在有些情况下 GNU 版本的命令也可能被安装（例如 gawk 和 gsed 对应 GNU 中的 awk 和 sed ）。如果要写跨平台的 Bash 脚本，避免使用这些命令（例如，考虑 Python 或者 perl ）或者经过仔细的测试。 用 sw_vers 获取 OS X 的版本信息。 仅限 Windows 系统以下是仅限于 Windows 系统的技巧。 在 Winodws 下获取 Unix 工具 可以安装 Cygwin 允许你在 Microsoft Windows 中体验 Unix shell 的威力。这样的话，本文中介绍的大多数内容都将适用。 在 Windows 10 上，你可以使用 Bash on Ubuntu on Windows，它提供了一个熟悉的 Bash 环境，包含了不少 Unix 命令行工具。好处是它允许 Linux 上编写的程序在 Windows 上运行，而另一方面，Windows 上编写的程序却无法在 Bash 命令行中运行。 如果你在 Windows 上主要想用 GNU 开发者工具（例如 GCC），可以考虑 MinGW 以及它的 MSYS 包，这个包提供了例如 bash，gawk，make 和 grep 的工具。MSYS 并不包含所有可以与 Cygwin 媲美的特性。当制作 Unix 工具的原生 Windows 端口时 MinGW 将特别地有用。 另一个在 Windows 下实现接近 Unix 环境外观效果的选项是 Cash。注意在此环境下只有很少的 Unix 命令和命令行可用。 实用 Windows 命令行工具 可以使用 wmic 在命令行环境下给大部分 Windows 系统管理任务编写脚本以及执行这些任务。 Windows 实用的原生命令行网络工具包括 ping，ipconfig，tracert，和 netstat。 可以使用 Rundll32 命令来实现许多有用的 Windows 任务 。 Cygwin 技巧 通过 Cygwin 的包管理器来安装额外的 Unix 程序。 使用 mintty 作为你的命令行窗口。 要访问 Windows 剪贴板，可以通过 /dev/clipboard。 运行 cygstart 以通过默认程序打开一个文件。 要访问 Windows 注册表，可以使用 regtool。 注意 Windows 驱动器路径 C:\\ 在 Cygwin 中用 /cygdrive/c 代表，而 Cygwin 的 / 代表 Windows 中的 C:\\cygwin。要转换 Cygwin 和 Windows 风格的路径可以用 cygpath。这在需要调用 Windows 程序的脚本里很有用。 学会使用 wmic，你就可以从命令行执行大多数 Windows 系统管理任务，并编成脚本。 要在 Windows 下获得 Unix 的界面和体验，另一个办法是使用 Cash。需要注意的是，这个环境支持的 Unix 命令和命令行参数非常少。 要在 Windows 上获取 GNU 开发者工具（比如 GCC）的另一个办法是使用 MinGW 以及它的 MSYS 软件包，该软件包提供了 bash、gawk、make、grep 等工具。然而 MSYS 提供的功能没有 Cygwin 完善。MinGW 在创建 Unix 工具的 Windows 原生移植方面非常有用。 更多资源 awesome-shell：一份精心组织的命令行工具及资源的列表。 awesome-osx-command-line：一份针对 OS X 命令行的更深入的指南。 Strict mode：为了编写更好的脚本文件。 shellcheck：一个静态 shell 脚本分析工具，本质上是 bash／sh／zsh 的 lint。 Filenames and Pathnames in Shell：有关如何在 shell 脚本里正确处理文件名的细枝末节。 Data Science at the Command Line：用于数据科学的一些命令和工具，摘自同名书籍。 免责声明除去特别小的工作，你编写的代码应当方便他人阅读。能力往往伴随着责任，你 有能力 在 Bash 中玩一些奇技淫巧并不意味着你应该去做！;) 授权条款[ Creative Commons License](https://i.creativecommons.org/l/by-sa/4.0/88x31.png) 本文使用授权协议 Creative Commons Attribution-ShareAlike 4.0 International License。","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Shell","slug":"Shell","permalink":"https://blog.jugg.xyz/tags/Shell/"},{"name":"UNIX","slug":"UNIX","permalink":"https://blog.jugg.xyz/tags/UNIX/"}]},{"title":"Docker 基础知识","slug":"repost/Docker","date":"2018-12-04T04:40:20.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2018/12/04/repost/Docker/","permalink":"https://blog.jugg.xyz/2018/12/04/repost/Docker/","excerpt":"","text":"本文转载自 CS-Note 项目 一、解决的问题由于不同的机器有不同的操作系统，以及不同的库和组件，在将一个应用部署到多台机器上需要进行大量的环境配置操作。 Docker 主要解决环境配置问题，它是一种虚拟化技术，对进程进行隔离，被隔离的进程独立于宿主操作系统和其它隔离的进程。使用 Docker 可以不修改应用程序代码，不需要开发人员学习特定环境下的技术，就能够将现有的应用程序部署在其他机器中。 二、与虚拟机的比较虚拟机也是一种虚拟化技术，它与 Docker 最大的区别在于它是通过模拟硬件，并在硬件上安装操作系统来实现。 启动速度启动虚拟机需要启动虚拟机的操作系统，再启动应用，这个过程非常慢； 而启动 Docker 相当于启动宿主操作系统上的一个进程。 占用资源虚拟机是一个完整的操作系统，需要占用大量的磁盘、内存和 CPU，一台机器只能开启几十个的虚拟机。 而 Docker 只是一个进程，只需要将应用以及相关的组件打包，在运行时占用很少的资源，一台机器可以开启成千上万个 Docker。 三、优势除了启动速度快以及占用资源少之外，Docker 具有以下优势： 更容易迁移提供一致性的运行环境，可以在不同的机器上进行迁移，而不用担心环境变化导致无法运行。 更容易维护使用分层技术和镜像，使得应用可以更容易复用重复部分。复用程度越高，维护工作也越容易。 更容易扩展可以使用基础镜像进一步扩展得到新的镜像，并且官方和开源社区提供了大量的镜像，通过扩展这些镜像可以非常容易得到我们想要的镜像。 四、使用场景持续集成持续集成指的是频繁地将代码集成到主干上，这样能够更快地发现错误。 Docker 具有轻量级以及隔离性的特点，在将代码集成到一个 Docker 中不会对其它 Docker 产生影响。 提供可伸缩的云服务根据应用的负载情况，可以很容易地增加或者减少 Docker。 搭建微服务架构Docker 轻量级的特点使得它很适合用于部署、维护、组合微服务。 五、镜像与容器镜像是一种静态的结构，可以看成面向对象里面的类，而容器是镜像的一个实例。 镜像包含着容器运行时所需要的代码以及其它组件，它是一种分层结构，每一层都是只读的（read-only layers）。构建镜像时，会一层一层构建，前一层是后一层的基础。镜像的这种分层存储结构很适合镜像的复用以及定制。 构建容器时，通过在镜像的基础上添加一个可写层（writable layer），用来保存着容器运行过程中的修改。 参考资料 DOCKER 101: INTRODUCTION TO DOCKER WEBINAR RECAP Docker 入门教程 Docker container vs Virtual machine How to Create Docker Container using Dockerfile 理解 Docker（2）：Docker 镜像 为什么要使用 Docker？ What is Docker 持续集成是什么？","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Docker","slug":"Docker","permalink":"https://blog.jugg.xyz/tags/Docker/"}]},{"title":"MySQL基础知识","slug":"repost/MySQL","date":"2018-08-30T10:30:02.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2018/08/30/repost/MySQL/","permalink":"https://blog.jugg.xyz/2018/08/30/repost/MySQL/","excerpt":"","text":"本文转载自 CS-Note 项目 一、索引B+ Tree 原理1. 数据结构B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。 B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。 在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。 2. 操作进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归地在指针所指向的节点进行查找。直到查找到叶子节点，然后在叶子节点上进行二分查找，找出 key 所对应的 data。 插入删除操作会破坏平衡树的平衡性，因此在插入删除操作之后，需要对树进行一个分裂、合并、旋转等操作来维护平衡性。 3. 与红黑树的比较红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因： （一）更少的查找次数 平衡树查找操作的时间复杂度等于树高 h，而树高大致为 O(h)&#x3D;O(logdN)，其中 d 为每个节点的出度。 红黑树的出度为 2，而 B+ Tree 的出度一般都非常大，所以红黑树的树高 h 很明显比 B+ Tree 大非常多，查找的次数也就更多。 （二）利用磁盘预读特性 为了减少磁盘 I&#x2F;O，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的旋转时间，速度会非常快。 操作系统一般将内存和磁盘分割成固态大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I&#x2F;O 就能完全载入一个节点。并且可以利用预读特性，相邻的节点也能够被预先载入。 MySQL 索引索引是在存储引擎层实现的，而不是在服务器层实现的，所以不同存储引擎具有不同的索引类型和实现。 1. B+Tree 索引是大多数 MySQL 存储引擎的默认索引类型。 因为不再需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多。 除了用于查找，还可以用于排序和分组。 可以指定多个列作为索引列，多个索引列共同组成键。 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。 InnoDB 的 B+Tree 索引分为主索引和辅助索引。主索引的叶子节点 data 域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。 辅助索引的叶子节点的 data 域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。 2. 哈希索引哈希索引能以 O(1) 时间进行查找，但是失去了有序性： 无法用于排序与分组； 只支持精确查找，无法用于部分查找和范围查找。 InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。 3. 全文索引MyISAM 存储引擎支持全文索引，用于查找文本中的关键词，而不是直接比较是否相等。 查找条件使用 MATCH AGAINST，而不是普通的 WHERE。 全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。 InnoDB 存储引擎在 MySQL 5.6.4 版本中也开始支持全文索引。 4. 空间数据索引MyISAM 存储引擎支持空间数据索引（R-Tree），可以用于地理数据存储。空间数据索引会从所有维度来索引数据，可以有效地使用任意维度来进行组合查询。 必须使用 GIS 相关的函数来维护数据。 索引优化1. 独立的列在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。 例如下面的查询不能使用 actor_id 列的索引： 1SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5; 2. 多列索引在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 actor_id 和 film_id 设置为多列索引。 12SELECT film_id, actor_ id FROM sakila.film_actorWHERE actor_id = 1 AND film_id = 1; 3. 索引列的顺序让选择性最强的索引列放在前面。 索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，查询效率也越高。 例如下面显示的结果中 customer_id 的选择性比 staff_id 更高，因此最好把 customer_id 列放在多列索引的前面。 1234SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,COUNT(*)FROM payment; 123 staff_id_selectivity: 0.0001customer_id_selectivity: 0.0373 COUNT(*): 16049 4. 前缀索引对于 BLOB、TEXT 和 VARCHAR 类型的列，必须使用前缀索引，只索引开始的部分字符。 对于前缀长度的选取需要根据索引选择性来确定。 5. 覆盖索引索引包含所有需要查询的字段的值。 具有以下优点： 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。 一些存储引擎（例如 MyISAM）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。 对于 InnoDB 引擎，若辅助索引能够覆盖查询，则无需访问主索引。 索引的优点 大大减少了服务器需要扫描的数据行数。 帮助服务器避免进行排序和分组，以及避免创建临时表（B+Tree 索引是有序的，可以用于 ORDER BY 和 GROUP BY 操作。临时表主要是在排序和分组过程中创建，因为不需要排序和分组，也就不需要创建临时表）。 将随机 I&#x2F;O 变为顺序 I&#x2F;O（B+Tree 索引是有序的，会将相邻的数据都存储在一起）。 索引的使用条件 对于非常小的表、大部分情况下简单的全表扫描比建立索引更高效； 对于中到大型的表，索引就非常有效； 但是对于特大型的表，建立和维护索引的代价将会随之增长。这种情况下，需要用到一种技术可以直接区分出需要查询的一组数据，而不是一条记录一条记录地匹配，例如可以使用分区技术。 二、查询性能优化使用 Explain 进行分析Explain 用来分析 SELECT 查询语句，开发人员可以通过分析 Explain 结果来优化查询语句。 比较重要的字段有： select_type : 查询类型，有简单查询、联合查询、子查询等 key : 使用的索引 rows : 扫描的行数 优化数据访问1. 减少请求的数据量 只返回必要的列：最好不要使用 SELECT * 语句。 只返回必要的行：使用 LIMIT 语句来限制返回的数据。 缓存重复查询的数据：使用缓存可以避免在数据库中进行查询，特别在要查询的数据经常被重复查询时，缓存带来的查询性能提升将会是非常明显的。 2. 减少服务器端扫描的行数最有效的方式是使用索引来覆盖查询。 重构查询方式1. 切分大查询一个大查询如果一次性执行的话，可能一次锁住很多数据、占满整个事务日志、耗尽系统资源、阻塞很多小的但重要的查询。 1DELEFT FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH); 12345rows_affected = 0do &#123; rows_affected = do_query( &quot;DELETE FROM messages WHERE create &lt; DATE_SUB(NOW(), INTERVAL 3 MONTH) LIMIT 10000&quot;)&#125; while rows_affected &gt; 0 2. 分解大连接查询将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样做的好处有： 让缓存更高效。对于连接查询，如果其中一个表发生变化，那么整个查询缓存就无法使用。而分解后的多个查询，即使其中一个表发生变化，对其它表的查询缓存依然可以使用。 分解成多个单表查询，这些单表查询的缓存结果更可能被其它查询使用到，从而减少冗余记录的查询。 减少锁竞争； 在应用层进行连接，可以更容易对数据库进行拆分，从而更容易做到高性能和可伸缩。 查询本身效率也可能会有所提升。例如下面的例子中，使用 IN() 代替连接查询，可以让 MySQL 按照 ID 顺序进行查询，这可能比随机的连接要更高效。 1234SELECT * FROM tabJOIN tag_post ON tag_post.tag_id=tag.idJOIN post ON tag_post.post_id=post.idWHERE tag.tag=&#x27;mysql&#x27;; 123SELECT * FROM tag WHERE tag=&#x27;mysql&#x27;;SELECT * FROM tag_post WHERE tag_id=1234;SELECT * FROM post WHERE post.id IN (123,456,567,9098,8904); 三、存储引擎InnoDB是 MySQL 默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其它存储引擎。 实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ 间隙锁（Next-Key Locking）防止幻影读。 主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。 内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。 支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。 MyISAM设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。 提供了大量的特性，包括压缩表、空间数据索引等。 不支持事务。 不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。 可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。 如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。 比较 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。 并发：MyISAM 只支持表级锁，而 InnoDB 还支持行级锁。 外键：InnoDB 支持外键。 备份：InnoDB 支持在线热备份。 崩溃恢复：MyISAM 崩溃后发生损坏的概率比 InnoDB 高很多，而且恢复的速度也更慢。 其它特性：MyISAM 支持压缩表和空间数据索引。 四、数据类型整型TINYINT, SMALLINT, MEDIUMINT, INT, BIGINT 分别使用 8, 16, 24, 32, 64 位存储空间，一般情况下越小的列越好。 INT(11) 中的数字只是规定了交互工具显示字符的个数，对于存储和计算来说是没有意义的。 浮点数FLOAT 和 DOUBLE 为浮点类型，DECIMAL 为高精度小数类型。CPU 原生支持浮点运算，但是不支持 DECIMAl 类型的计算，因此 DECIMAL 的计算比浮点类型需要更高的代价。 FLOAT、DOUBLE 和 DECIMAL 都可以指定列宽，例如 DECIMAL(18, 9) 表示总共 18 位，取 9 位存储小数部分，剩下 9 位存储整数部分。 字符串主要有 CHAR 和 VARCHAR 两种类型，一种是定长的，一种是变长的。 VARCHAR 这种变长类型能够节省空间，因为只需要存储必要的内容。但是在执行 UPDATE 时可能会使行变得比原来长，当超出一个页所能容纳的大小时，就要执行额外的操作。MyISAM 会将行拆成不同的片段存储，而 InnoDB 则需要分裂页来使行放进页内。 VARCHAR 会保留字符串末尾的空格，而 CHAR 会删除。 时间和日期MySQL 提供了两种相似的日期时间类型：DATETIME 和 TIMESTAMP。 1. DATETIME能够保存从 1001 年到 9999 年的日期和时间，精度为秒，使用 8 字节的存储空间。 它与时区无关。 默认情况下，MySQL 以一种可排序的、无歧义的格式显示 DATETIME 值，例如“2008-01-16 22:37:08”，这是 ANSI 标准定义的日期和时间表示方法。 2. TIMESTAMP和 UNIX 时间戳相同，保存从 1970 年 1 月 1 日午夜（格林威治时间）以来的秒数，使用 4 个字节，只能表示从 1970 年到 2038 年。 它和时区有关，也就是说一个时间戳在不同的时区所代表的具体时间是不同的。 MySQL 提供了 FROM_UNIXTIME() 函数把 UNIX 时间戳转换为日期，并提供了 UNIX_TIMESTAMP() 函数把日期转换为 UNIX 时间戳。 默认情况下，如果插入时没有指定 TIMESTAMP 列的值，会将这个值设置为当前时间。 应该尽量使用 TIMESTAMP，因为它比 DATETIME 空间效率更高。 五、切分水平切分水平切分又称为 Sharding，它是将同一个表中的记录拆分到多个结构相同的表中。 当一个表的数据不断增多时，Sharding 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。 垂直切分垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。 在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。 Sharding 策略 哈希取模：hash(key) % N； 范围：可以是 ID 范围也可以是时间范围； 映射表：使用单独的一个数据库来存储映射关系。 Sharding 存在的问题及解决方案1. 事务问题使用分布式事务来解决，比如 XA 接口。 2. JOIN可以将原来的 JOIN 分解成多个单表 JOIN 查询，然后在用户程序中进行 JOIN。 3. ID 唯一性 使用全局唯一 ID：GUID 为每个分片指定一个 ID 范围 分布式 ID 生成器 (如 Twitter 的 Snowflake 算法) 六、复制主从复制主要涉及三个线程：binlog 线程、I&#x2F;O 线程和 SQL 线程。 binlog 线程 ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。 I&#x2F;O 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。 SQL 线程 ：负责读取重放日志并重放其中的 SQL 语句。 读写分离主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。 读写分离能提高性能的原因在于： 主从服务器负责各自的读和写，极大程度缓解了锁的争用； 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销； 增加冗余，提高可用性。 读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。 参考资料 BaronScbwartz, PeterZaitsev, VadimTkacbenko, 等. 高性能 MySQL[M]. 电子工业出版社, 2013. 姜承尧. MySQL 技术内幕: InnoDB 存储引擎 [M]. 机械工业出版社, 2011. 20+ 条 MySQL 性能优化的最佳经验 服务端指南 数据存储篇 | MySQL（09） 分库与分表带来的分布式困境与应对之策 How to create unique row ID in sharded databases? SQL Azure Federation – Introduction MySQL 索引背后的数据结构及算法原理 MySQL 性能优化神器 Explain 使用分析 How Sharding Works 大众点评订单系统分库分表实践","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"https://blog.jugg.xyz/tags/MySQL/"}]},{"title":"HTTP 基础知识","slug":"repost/HTTP","date":"2018-06-05T10:30:02.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2018/06/05/repost/HTTP/","permalink":"https://blog.jugg.xyz/2018/06/05/repost/HTTP/","excerpt":"","text":"本文转载自 CS-Note 项目 一 、基础概念URLURI 包含 URL 和 URN，目前 WEB 只有 URL 比较流行，所以见到的基本都是 URL。 URI（Uniform Resource Identifier，统一资源标识符） URL（Uniform Resource Locator，统一资源定位符） URN（Uniform Resource Name，统一资源名称） 请求和响应报文1. 请求报文 2. 响应报文 二、HTTP 方法客户端发送的 请求报文 第一行为请求行，包含了方法字段。 GET 获取资源 当前网络请求中，绝大部分使用的是 GET 方法。 HEAD 获取报文首部 和 GET 方法一样，但是不返回报文实体主体部分。 主要用于确认 URL 的有效性以及资源更新的日期时间等。 POST 传输实体主体 POST 主要用来传输数据，而 GET 主要用来获取资源。 更多 POST 与 GET 的比较请见第八章。 PUT 上传文件 由于自身不带验证机制，任何人都可以上传文件，因此存在安全性问题，一般不使用该方法。 123456PUT /new.html HTTP/1.1Host: example.comContent-type: text/htmlContent-length: 16&lt;p&gt;New File&lt;/p&gt; PATCH 对资源进行部分修改 PUT 也可以用于修改资源，但是只能完全替代原始资源，PATCH 允许部分修改。 1234567PATCH /file.txt HTTP/1.1Host: www.example.comContent-Type: application/exampleIf-Match: &quot;e0023aa4e&quot;Content-Length: 100[description of changes] DELETE 删除文件 与 PUT 功能相反，并且同样不带验证机制。 1DELETE /file.html HTTP/1.1 OPTIONS 查询支持的方法 查询指定的 URL 能够支持的方法。 会返回 Allow: GET, POST, HEAD, OPTIONS 这样的内容。 CONNECT 要求在与代理服务器通信时建立隧道 使用 SSL（Secure Sockets Layer，安全套接层）和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。 1CONNECT www.example.com:443 HTTP/1.1 TRACE 追踪路径 服务器会将通信路径返回给客户端。 发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。 通常不会使用 TRACE，并且它容易受到 XST 攻击（Cross-Site Tracing，跨站追踪）。 三、HTTP 状态码服务器返回的 响应报文 中第一行为状态行，包含了状态码以及原因短语，用来告知客户端请求的结果。 状态码 类别 原因短语 1XX Informational（信息性状态码） 接收的请求正在处理 2XX Success（成功状态码） 请求正常处理完毕 3XX Redirection（重定向状态码） 需要进行附加操作以完成请求 4XX Client Error（客户端错误状态码） 服务器无法处理请求 5XX Server Error（服务器错误状态码） 服务器处理请求出错 1XX 信息 100 Continue ：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。 2XX 成功 200 OK 204 No Content ：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。 206 Partial Content ：表示客户端进行了范围请求，响应报文包含由 Content-Range 指定范围的实体内容。 3XX 重定向 301 Moved Permanently ：永久性重定向 302 Found ：临时性重定向 303 See Other ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。 注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。 304 Not Modified ：如果请求报文首部包含一些条件，例如：If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since，如果不满足条件，则服务器会返回 304 状态码。 307 Temporary Redirect ：临时重定向，与 302 的含义类似，但是 307 要求浏览器不会把重定向请求的 POST 方法改成 GET 方法。 4XX 客户端错误 400 Bad Request ：请求报文中存在语法错误。 401 Unauthorized ：该状态码表示发送的请求需要有认证信息（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。 403 Forbidden ：请求被拒绝。 404 Not Found 5XX 服务器错误 500 Internal Server Error ：服务器正在执行请求时发生错误。 503 Service Unavailable ：服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 四、HTTP 首部有 4 种类型的首部字段：通用首部字段、请求首部字段、响应首部字段和实体首部字段。 各种首部字段及其含义如下（不需要全记，仅供查阅）： 通用首部字段 首部字段名 说明 Cache-Control 控制缓存的行为 Connection 控制不再转发给代理的首部字段、管理持久连接 Date 创建报文的日期时间 Pragma 报文指令 Trailer 报文末端的首部一览 Transfer-Encoding 指定报文主体的传输编码方式 Upgrade 升级为其他协议 Via 代理服务器的相关信息 Warning 错误通知 请求首部字段 首部字段名 说明 Accept 用户代理可处理的媒体类型 Accept-Charset 优先的字符集 Accept-Encoding 优先的内容编码 Accept-Language 优先的语言（自然语言） Authorization Web 认证信息 Expect 期待服务器的特定行为 From 用户的电子邮箱地址 Host 请求资源所在服务器 If-Match 比较实体标记（ETag） If-Modified-Since 比较资源的更新时间 If-None-Match 比较实体标记（与 If-Match 相反） If-Range 资源未更新时发送实体 Byte 的范围请求 If-Unmodified-Since 比较资源的更新时间（与 If-Modified-Since 相反） Max-Forwards 最大传输逐跳数 Proxy-Authorization 代理服务器要求客户端的认证信息 Range 实体的字节范围请求 Referer 对请求中 URI 的原始获取方 TE 传输编码的优先级 User-Agent HTTP 客户端程序的信息 响应首部字段 首部字段名 说明 Accept-Ranges 是否接受字节范围请求 Age 推算资源创建经过时间 ETag 资源的匹配信息 Location 令客户端重定向至指定 URI Proxy-Authenticate 代理服务器对客户端的认证信息 Retry-After 对再次发起请求的时机要求 Server HTTP 服务器的安装信息 Vary 代理服务器缓存的管理信息 WWW-Authenticate 服务器对客户端的认证信息 实体首部字段 首部字段名 说明 Allow 资源可支持的 HTTP 方法 Content-Encoding 实体主体适用的编码方式 Content-Language 实体主体的自然语言 Content-Length 实体主体的大小 Content-Location 替代对应资源的 URI Content-MD5 实体主体的报文摘要 Content-Range 实体主体的位置范围 Content-Type 实体主体的媒体类型 Expires 实体主体过期的日期时间 Last-Modified 资源的最后修改日期时间 五、具体应用CookieHTTP 协议是无状态的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP&#x2F;1.1 引入 Cookie 来保存状态信息。 Cookie 是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。由于之后每次请求都会需要携带 Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。 Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被淘汰。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 Web storage API （本地存储和会话存储）或 IndexedDB。 1. 用途 会话状态管理（如用户登录状态、购物车、游戏分数或其它需要记录的信息） 个性化设置（如用户自定义设置、主题等） 浏览器行为跟踪（如跟踪分析用户行为等） 2. 创建过程服务器发送的响应报文包含 Set-Cookie 首部字段，客户端得到响应报文后把 Cookie 内容保存到浏览器中。 123456HTTP/1.0 200 OKContent-type: text/htmlSet-Cookie: yummy_cookie=chocoSet-Cookie: tasty_cookie=strawberry[page content] 客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并通过 Cookie 请求首部字段发送给服务器。 123GET /sample_page.html HTTP/1.1Host: www.example.orgCookie: yummy_cookie=choco; tasty_cookie=strawberry 3. 分类 会话期 Cookie：浏览器关闭之后它会被自动删除，也就是说它仅在会话期内有效。 持久性 Cookie：指定一个特定的过期时间（Expires）或有效期（max-age）之后就成为了持久性的 Cookie。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; 4. JavaScript 获取 Cookie通过 Document.cookie 属性可创建新的 Cookie，也可通过该属性访问非 HttpOnly 标记的 Cookie。 123document.cookie = &quot;yummy_cookie=choco&quot;;document.cookie = &quot;tasty_cookie=strawberry&quot;;console.log(document.cookie); 5. Secure 和 HttpOnly标记为 Secure 的 Cookie 只能通过被 HTTPS 协议加密过的请求发送给服务端。但即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。 标记为 HttpOnly 的 Cookie 不能被 JavaScript 脚本调用。跨站脚本攻击 (XSS) 常常使用 JavaScript 的 Document.cookie API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免 XSS 攻击。 1Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly 6. 作用域Domain 标识指定了哪些主机可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain&#x3D;mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）。 Path 标识指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F (“&#x2F;“) 作为路径分隔符，子路径也会被匹配。例如，设置 Path&#x3D;&#x2F;docs，则以下地址都会匹配： &#x2F;docs &#x2F;docs&#x2F;Web&#x2F; &#x2F;docs&#x2F;Web&#x2F;HTTP 7. Session除了可以将用户信息通过 Cookie 存储在用户浏览器中，也可以利用 Session 存储在服务器端，存储在服务器端的信息更加安全。 Session 可以存储在服务器上的文件、数据库或者内存中。也可以将 Session 存储在 Redis 这种内存型数据库中，效率会更高。 使用 Session 维护用户登录状态的过程如下： 用户进行登录时，用户提交包含用户名和密码的表单，放入 HTTP 请求报文中； 服务器验证该用户名和密码； 如果正确则把用户信息存储到 Redis 中，它在 Redis 中的 Key 称为 Session ID； 服务器返回的响应报文的 Set-Cookie 首部字段包含了这个 Session ID，客户端收到响应报文之后将该 Cookie 值存入浏览器中； 客户端之后对同一个服务器进行请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。 应该注意 Session ID 的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的 Session ID 值。此外，还需要经常重新生成 Session ID。在对安全性要求极高的场景下，例如转账等操作，除了使用 Session 管理用户状态之外，还需要对用户进行重新验证，比如重新输入密码，或者使用短信验证码等方式。 8. 浏览器禁用 Cookie此时无法使用 Cookie 来保存用户信息，只能使用 Session。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用 URL 重写技术，将 Session ID 作为 URL 的参数进行传递。 9. Cookie 与 Session 选择 Cookie 只能存储 ASCII 码字符串，而 Session 则可以存取任何类型的数据，因此在考虑数据复杂性时首选 Session； Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将 Cookie 值进行加密，然后在服务器进行解密； 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中。 缓存1. 优点 缓解服务器压力； 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存在地理位置上也有可能比源服务器来得近，例如浏览器缓存。 2. 实现方法 让代理服务器进行缓存； 让客户端浏览器进行缓存。 3. Cache-ControlHTTP&#x2F;1.1 通过 Cache-Control 首部字段来控制缓存。 （一）禁止进行缓存 no-store 指令规定不能对请求或响应的任何一部分进行缓存。 1Cache-Control: no-store （二）强制确认缓存 no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效才将能使用该缓存对客户端的请求进行响应。 1Cache-Control: no-cache （三）私有缓存和公共缓存 private 指令规定了将资源作为私有缓存，只能被单独用户所使用，一般存储在用户浏览器中。 1Cache-Control: private public 指令规定了将资源作为公共缓存，可以被多个用户所使用，一般存储在代理服务器中。 1Cache-Control: public （四）缓存过期机制 max-age 指令出现在请求报文中，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。 max-age 指令出现在响应报文中，表示缓存资源在缓存服务器中保存的时间。 1Cache-Control: max-age=31536000 Expires 首部字段也可以用于告知缓存服务器该资源什么时候会过期。 在 HTTP&#x2F;1.1 中，会优先处理 max-age 指令； 在 HTTP&#x2F;1.0 中，max-age 指令会被忽略掉。 1Expires: Wed, 04 Jul 2012 08:26:05 GMT 4. 缓存验证需要先了解 ETag 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 http://www.google.com/ 有中文和英文两个资源，只有 ETag 才能对这两个资源进行唯一标识。 1ETag: &quot;82e22293907ce725faf67773957acd12&quot; 可以将缓存资源的 ETag 值放入 If-None-Match 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。 1If-None-Match: &quot;82e22293907ce725faf67773957acd12&quot; Last-Modified 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有消息主体的 304 Not Modified 响应。 1Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT 1If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT 连接管理 1. 短连接与长连接当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。 长连接只需要建立一次 TCP 连接就能进行多次 HTTP 通信。 从 HTTP&#x2F;1.1 开始默认是长连接的，如果要断开连接，需要由客户端或者服务器端提出断开，使用 Connection : close； 在 HTTP&#x2F;1.1 之前默认是短连接的，如果需要使用长连接，则使用 Connection : Keep-Alive。 2. 流水线默认情况下，HTTP 请求是按顺序发出的，下一个请求只有在当前请求收到响应之后才会被发出。由于会受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。 流水线是在同一条长连接上发出连续的请求，而不用等待响应返回，这样可以避免连接延迟。 内容协商通过内容协商返回最合适的内容，例如根据浏览器的默认语言选择返回中文界面还是英文界面。 1. 类型（一）服务端驱动型 客户端设置特定的 HTTP 首部字段，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Languag，服务器根据这些字段返回特定的资源。 它存在以下问题： 服务器很难知道客户端浏览器的全部信息； 客户端提供的信息相当冗长（HTTP&#x2F;2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）； 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂。 （二）代理驱动型 服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。 2. Vary1Vary: Accept-Language 在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。 例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 Vary: Accept-Language 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。 内容编码内容编码将实体主体进行压缩，从而减少传输的数据量。 常用的内容编码有：gzip、compress、deflate、identity。 浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，在响应的 Vary 首部至少要包含 Content-Encoding。 范围请求如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器未发送的那部分数据，从而避免服务器重新发送所有数据。 1. Range在请求报文中添加 Range 首部字段指定请求的范围。 123GET /z4d4kWk.jpg HTTP/1.1Host: i.imgur.comRange: bytes=0-1023 请求成功的话服务器返回的响应包含 206 Partial Content 状态码。 12345HTTP/1.1 206 Partial ContentContent-Range: bytes 0-1023/146515Content-Length: 1024...(binary content) 2. Accept-Ranges响应首部字段 Accept-Ranges 用于告知客户端是否能处理范围请求，可以处理使用 bytes，否则使用 none。 1Accept-Ranges: bytes 3. 响应状态码 在请求成功的情况下，服务器会返回 206 Partial Content 状态码。 在请求的范围越界的情况下，服务器会返回 416 Requested Range Not Satisfiable 状态码。 在不支持范围请求的情况下，服务器会返回 200 OK 状态码。 分块传输编码Chunked Transfer Coding，可以把数据分割成多块，让浏览器逐步显示页面。 多部分对象集合一份报文主体内可含有多种类型的实体同时发送，每个部分之间用 boundary 字段定义的分隔符进行分隔，每个部分都可以有首部字段。 例如，上传多个表单时可以使用如下方式： 123456789101112Content-Type: multipart/form-data; boundary=AaB03x--AaB03xContent-Disposition: form-data; name=&quot;submit-name&quot;Larry--AaB03xContent-Disposition: form-data; name=&quot;files&quot;; filename=&quot;file1.txt&quot;Content-Type: text/plain... contents of file1.txt ...--AaB03x-- 虚拟主机HTTP&#x2F;1.1 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器。 通信数据转发1. 代理代理服务器接受客户端的请求，并且转发给其它服务器。 使用代理的主要目的是： 缓存 负载均衡 网络访问控制 访问日志记录 代理服务器分为正向代理和反向代理两种： 用户察觉得到正向代理的存在。 而反向代理一般位于内部网络中，用户察觉不到。 2. 网关与代理服务器不同的是，网关服务器会将 HTTP 转化为其它协议进行通信，从而请求其它非 HTTP 服务器的服务。 3. 隧道使用 SSL 等加密手段，在客户端和服务器之间建立一条安全的通信线路。 六、HTTPsHTTP 有以下安全性问题： 使用明文进行通信，内容可能会被窃听； 不验证通信方的身份，通信方的身份有可能遭遇伪装； 无法证明报文的完整性，报文有可能遭篡改。 HTTPs 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，也就是说 HTTPs 使用了隧道进行通信。 通过使用 SSL，HTTPs 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）。 加密1. 对称密钥加密对称密钥加密（Symmetric-Key Encryption），加密和解密使用同一密钥。 优点：运算速度快； 缺点：无法安全地将密钥传输给通信方。 2.非对称密钥加密非对称密钥加密，又称公开密钥加密（Public-Key Encryption），加密和解密使用不同的密钥。 公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。 非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。 优点：可以更安全地将公开密钥传输给通信发送方； 缺点：运算速度慢。 3. HTTPs 采用的加密方式HTTPs 采用混合的加密机制，使用非对称密钥加密用于传输对称密钥来保证传输过程的安全性，之后使用对称密钥加密进行通信来保证通信过程的效率。（下图中的 Session Key 就是对称密钥） 认证通过使用 证书 来对通信方进行认证。 数字证书认证机构（CA，Certificate Authority）是客户端与服务器双方都可信赖的第三方机构。 服务器的运营人员向 CA 提出公开密钥的申请，CA 在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名，然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。 进行 HTTPs 通信时，服务器会把证书发送给客户端。客户端取得其中的公开密钥之后，先使用数字签名进行验证，如果验证通过，就可以开始通信了。 通信开始时，客户端需要使用服务器的公开密钥将自己的私有密钥传输给服务器，之后再进行对称密钥加密。 完整性保护SSL 提供报文摘要功能来进行完整性保护。 HTTP 也提供了 MD5 报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。 HTTPs 的报文摘要功能之所以安全，是因为它结合了加密和认证这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。 HTTPs 的缺点 因为需要进行加密解密等过程，因此速度会更慢； 需要支付证书授权的高额费用。 配置 HTTPsNginx 配置 HTTPS 服务器 七、HTTP&#x2F;2.0HTTP&#x2F;1.x 缺陷 HTTP&#x2F;1.x 实现简单是以牺牲性能为代价的： 客户端需要使用多个连接才能实现并发和缩短延迟； 不会压缩请求和响应首部，从而导致不必要的网络流量； 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。 二进制分帧层HTTP&#x2F;2.0 将报文分成 HEADERS 帧和 DATA 帧，它们都是二进制格式的。 在通信过程中，只会有一个 TCP 连接存在，它承载了任意数量的双向数据流（Stream）。 一个数据流都有一个唯一标识符和可选的优先级信息，用于承载双向信息。 消息（Message）是与逻辑请求或响应消息对应的完整的一系列帧。 帧（Fram）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装。 服务端推送HTTP&#x2F;2.0 在客户端请求一个资源时，会把相关的资源一起发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。 首部压缩HTTP&#x2F;1.1 的首部带有大量信息，而且每次都要重复发送。 HTTP&#x2F;2.0 要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，从而避免了重复传输。 不仅如此，HTTP&#x2F;2.0 也使用 Huffman 编码对首部字段进行压缩。 八、GET 和 POST 比较作用GET 用于获取资源，而 POST 用于传输实体主体。 参数GET 和 POST 的请求都能使用额外的参数，但是 GET 的参数是以查询字符串出现在 URL 中，而 POST 的参数存储在实体主体中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。 因为 URL 只支持 ASCII 码，因此 GET 的参数中如果存在中文等字符就需要先进行编码。例如 中文 会转换为 %E4%B8%AD%E6%96%87，而空格会转换为 %20。POST 参考支持标准字符集。 1GET /test/demo_form.asp?name1=value1&amp;name2=value2 HTTP/1.1 123POST /test/demo_form.asp HTTP/1.1Host: w3schools.comname1=value1&amp;name2=value2 安全安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。 GET 方法是安全的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。 安全的方法除了 GET 之外还有：HEAD、OPTIONS。 不安全的方法除了 POST 之外还有 PUT、DELETE。 幂等性幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。 所有的安全方法也都是幂等的。 在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是。 GET &#x2F;pageX HTTP&#x2F;1.1 是幂等的，连续调用多次，客户端接收到的结果都是一样的： 1234GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1GET /pageX HTTP/1.1 POST &#x2F;add_row HTTP&#x2F;1.1 不是幂等的，如果调用多次，就会增加多行记录： 123POST /add_row HTTP/1.1 -&gt; Adds a 1nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 2nd rowPOST /add_row HTTP/1.1 -&gt; Adds a 3rd row DELETE &#x2F;idX&#x2F;delete HTTP&#x2F;1.1 是幂等的，即便不同的请求接收到的状态码不一样： 123DELETE /idX/delete HTTP/1.1 -&gt; Returns 200 if idX existsDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 as it just got deletedDELETE /idX/delete HTTP/1.1 -&gt; Returns 404 可缓存如果要对响应进行缓存，需要满足以下条件： 请求报文的 HTTP 方法本身是可缓存的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。 响应报文的状态码是可缓存的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。 响应报文的 Cache-Control 首部字段没有指定不进行缓存。 XMLHttpRequest为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest： XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。 而 GET 方法 Header 和 Data 会一起发送。 九、HTTP&#x2F;1.0 与 HTTP&#x2F;1.1 的区别 详细内容请见上文 HTTP&#x2F;1.1 默认是长连接 HTTP&#x2F;1.1 支持管线化处理 HTTP&#x2F;1.1 支持同时打开多个 TCP 连接 HTTP&#x2F;1.1 支持虚拟主机 HTTP&#x2F;1.1 新增状态码 100 HTTP&#x2F;1.1 支持分块传输编码 HTTP&#x2F;1.1 新增缓存处理指令 max-age 参考资料 上野宣. 图解 HTTP[M]. 人民邮电出版社, 2014. MDN : HTTP HTTP&#x2F;2 简介 htmlspecialchars Difference between file URI and URL in java How to Fix SQL Injection Using Java PreparedStatement &amp; CallableStatement 浅谈 HTTP 中 Get 与 Post 的区别 Are http:&#x2F;&#x2F; and www really necessary? HTTP (HyperText Transfer Protocol) Web-VPN: Secure Proxies with SPDY &amp; Chrome File:HTTP persistent connection.svg Proxy server What Is This HTTPS&#x2F;SSL Thing And Why Should You Care? What is SSL Offloading? Sun Directory Server Enterprise Edition 7.0 Reference - Key Encryption An Introduction to Mutual SSL Authentication The Difference Between URLs and URIs Cookie 与 Session 的区别 COOKIE 和 SESSION 有什么区别 Cookie&#x2F;Session 的机制与安全 HTTPS 证书原理 What is the difference between a URI, a URL and a URN? XMLHttpRequest XMLHttpRequest (XHR) Uses Multiple Packets for HTTP POST? Symmetric vs. Asymmetric Encryption – What are differences? Web 性能优化与 HTTP&#x2F;2 HTTP&#x2F;2 简介","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"HTTP","slug":"HTTP","permalink":"https://blog.jugg.xyz/tags/HTTP/"}]},{"title":"计算机网络基础知识","slug":"repost/Computer-Network","date":"2018-04-17T14:29:20.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2018/04/17/repost/Computer-Network/","permalink":"https://blog.jugg.xyz/2018/04/17/repost/Computer-Network/","excerpt":"","text":"本文转载自 CS-Note 项目 一、概述网络的网络网络把主机连接起来，而互联网是把多种不同的网络连接起来，因此互联网是网络的网络。 ISP互联网服务提供商 ISP 可以从互联网管理机构获得许多 IP 地址，同时拥有通信线路以及路由器等联网设备，个人或机构向 ISP 缴纳一定的费用就可以接入互联网。 目前的互联网是一种多层次 ISP 结构，ISP 根据覆盖面积的大小分为第一层 ISP、区域 ISP 和接入 ISP。互联网交换点 IXP 允许两个 ISP 直接相连而不用经过第三个 ISP。 主机之间的通信方式 客户-服务器（C&#x2F;S）：客户是服务的请求方，服务器是服务的提供方。 对等（P2P）：不区分客户和服务器。 电路交换与分组交换1. 电路交换电路交换用于电话通信系统，两个用户要通信之前需要建立一条专用的物理链路，并且在整个通信过程中始终占用该链路。由于通信的过程中不可能一直在使用传输线路，因此电路交换对线路的利用率很低，往往不到 10%。 2. 分组交换每个分组都有首部和尾部，包含了源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组互相不会影响，因此在同一条传输线路上允许同时传输多个分组，也就是说分组交换不需要占用传输线路。 在一个邮局通信系统中，邮局收到一份邮件之后，先存储下来，然后把相同目的地的邮件一起转发到下一个目的地，这个过程就是存储转发过程，分组交换也使用了存储转发过程。 时延总时延 &#x3D; 传输时延 + 传播时延 + 处理时延 + 排队时延 1. 传输时延主机或路由器传输数据帧所需要的时间。 其中 l 表示数据帧的长度，v 表示传输速率。 2. 传播时延电磁波在信道中传播所需要花费的时间，电磁波传播的速度接近光速。 其中 l 表示信道长度，v 表示电磁波在信道上的传播速度。 3. 处理时延主机或路由器收到分组时进行处理所需要的时间，例如分析首部、从分组中提取数据、进行差错检验或查找适当的路由等。 4. 排队时延分组在路由器的输入队列和输出队列中排队等待的时间，取决于网络当前的通信量。 计算机网络体系结构* 1. 五层协议 应用层 ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等。数据单位为报文。 运输层 ：提供的是进程间的通用数据传输服务。由于应用层协议很多，定义通用的运输层协议就可以支持不断增多的应用层协议。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。 网络层 ：为主机间提供数据传输服务，而运输层协议是为主机中的进程提供服务。网络层把运输层传递下来的报文段或者用户数据报封装成分组。 数据链路层 ：网络层针对的还是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供服务。数据链路层把网络层传下来的分组封装成帧。 物理层 ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。 2. OSI其中表示层和会话层用途如下： 表示层 ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。 会话层 ：建立及管理会话。 五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。 3. TCP&#x2F;IP它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。 TCP&#x2F;IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层。 TCP&#x2F;IP 协议族是一种沙漏形状，中间小两边大，IP 协议在其中占用举足轻重的地位。 4. 数据在各层之间的传递过程在向下的过程中，需要添加下层协议所需要的首部或者尾部，而在向上的过程中不断拆开首部和尾部。 路由器只有下面三层协议，因为路由器位于网络核心中，不需要为进程或者应用程序提供服务，因此也就不需要运输层和应用层。 二、物理层通信方式根据信息在传输线上的传送方向，分为以下三种通信方式： 单工通信：单向传输 半双工通信：双向交替传输 全双工通信：双向同时传输 带通调制模拟信号是连续的信号，数字信号是离散的信号。带通调制把数字信号转换为模拟信号。 三、数据链路层基本问题1. 封装成帧将网络层传下来的分组添加首部和尾部，用于标记帧的开始和结束。 2. 透明传输透明表示一个实际存在的事物看起来好像不存在一样。 帧使用首部和尾部进行定界，如果帧的数据部分含有和首部尾部相同的内容，那么帧的开始和结束位置就会被错误的判定。需要在数据部分出现首部尾部相同的内容前面插入转义字符。如果数据部分出现转义字符，那么就在转义字符前面再加个转义字符。在接收端进行处理之后可以还原出原始数据。这个过程透明传输的内容是转义字符，用户察觉不到转义字符的存在。 3. 差错检测目前数据链路层广泛使用了循环冗余检验（CRC）来检查比特差错。 信道分类1. 广播信道一对多通信，一个节点发送的数据能够被广播信道上所有的节点接收到。 所有的节点都在同一个广播信道上发送数据，因此需要有专门的控制方法进行协调，避免发生冲突（冲突也叫碰撞）。 主要有两种控制方法进行协调，一个是使用信道复用技术，一是使用 CSMA&#x2F;CD 协议。 2. 点对点信道一对一通信。 因为不会发生碰撞，因此也比较简单，使用 PPP 协议进行控制。 信道复用技术1. 频分复用频分复用的所有主机在相同的时间占用不同的频率带宽资源。 2. 时分复用时分复用的所有主机在不同的时间占用相同的频率带宽资源。 使用频分复用和时分复用进行通信，在通信的过程中主机会一直占用一部分信道资源。但是由于计算机数据的突发性质，通信过程没必要一直占用信道资源而不让出给其它用户使用，因此这两种方式对信道的利用率都不高。 3. 统计时分复用是对时分复用的一种改进，不固定每个用户在时分复用帧中的位置，只要有数据就集中起来组成统计时分复用帧然后发送。 4. 波分复用光的频分复用。由于光的频率很高，因此习惯上用波长而不是频率来表示所使用的光载波。 5. 码分复用为每个用户分配 m bit 的码片，并且所有的码片正交，对于任意两个码片 和 有 为了讨论方便，取 m&#x3D;8，设码片 为 00011011。在拥有该码片的用户发送比特 1 时就发送该码片，发送比特 0 时就发送该码片的反码 11100100。 在计算时将 00011011 记作 (-1 -1 -1 +1 +1 -1 +1 +1)，可以得到 其中 为 的反码。 利用上面的式子我们知道，当接收端使用码片 对接收到的数据进行内积运算时，结果为 0 的是其它用户发送的数据，结果为 1 的是用户发送的比特 1，结果为 -1 的是用户发送的比特 0。 码分复用需要发送的数据量为原先的 m 倍。 CSMA&#x2F;CD 协议*CSMA&#x2F;CD 表示载波监听多点接入 &#x2F; 碰撞检测。 多点接入 ：说明这是总线型网络，许多主机以多点的方式连接到总线上。 载波监听 ：每个主机都必须不停地监听信道。在发送前，如果监听到信道正在使用，就必须等待。 碰撞检测 ：在发送中，如果监听到信道已有其它主机正在发送数据，就表示发生了碰撞。虽然每个主机在发送数据之前都已经监听到信道为空闲，但是由于电磁波的传播时延的存在，还是有可能会发生碰撞。 记端到端的传播时延为 τ，最先发送的站点最多经过 2τ 就可以知道是否发生了碰撞，称 2τ 为 争用期 。只有经过争用期之后还没有检测到碰撞，才能肯定这次发送不会发生碰撞。 当发生碰撞时，站点要停止发送，等待一段时间再发送。这个时间采用 截断二进制指数退避算法 来确定。从离散的整数集合 {0, 1, .., (2k-1)} 中随机取出一个数，记作 r，然后取 r 倍的争用期作为重传等待时间。 PPP 协议互联网用户通常需要连接到某个 ISP 之后才能接入到互联网，PPP 协议是用户计算机和 ISP 进行通信时所使用的数据链路层协议。 PPP 的帧格式： F 字段为帧的定界符 A 和 C 字段暂时没有意义 FCS 字段是使用 CRC 的检验序列 信息部分的长度不超过 1500 MAC 地址MAC 地址是链路层地址，长度为 6 字节（48 位），用于唯一标识网络适配器（网卡）。 一台主机拥有多少个适配器就有多少个 MAC 地址。例如笔记本电脑普遍存在无线网络适配器和有线网络适配器，因此就有两个 MAC 地址。 局域网局域网是一种典型的广播信道，主要特点是网络为一个单位所拥有，且地理范围和站点数目均有限。 主要有以太网、令牌环网、FDDI 和 ATM 等局域网技术，目前以太网占领着有线局域网市场。 可以按照网络拓扑结构对局域网进行分类： 以太网*以太网是一种星型拓扑结构局域网。 早期使用集线器进行连接，集线器是一种物理层设备，作用于比特而不是帧，当一个比特到达接口时，集线器重新生成这个比特，并将其能量强度放大，从而扩大网络的传输距离，之后再将这个比特发送到其它所有接口。如果集线器同时收到同时从两个不同接口的帧，那么就发生了碰撞。 目前以太网使用交换机替代了集线器，交换机是一种链路层设备，它不会发生碰撞，能根据 MAC 地址进行存储转发。 以太网帧格式： 类型 ：标记上层使用的协议； 数据 ：长度在 46-1500 之间，如果太小则需要填充； FCS ：帧检验序列，使用的是 CRC 检验方法； 前同步码 ：只是为了计算 FCS 临时加入的，计算结束之后会丢弃。 交换机*交换机具有自学习能力，学习的是交换表的内容，交换表中存储着 MAC 地址到接口的映射。 正是由于这种自学习能力，因此交换机是一种即插即用设备，不需要网络管理员手动配置交换表内容。 下图中，交换机有 4 个接口，主机 A 向主机 B 发送数据帧时，交换机把主机 A 到接口 1 的映射写入交换表中。为了发送数据帧到 B，先查交换表，此时没有主机 B 的表项，那么主机 A 就发送广播帧，主机 C 和主机 D 会丢弃该帧。主机 B 收下之后，查找交换表得到主机 A 映射的接口为 1，就发送数据帧到接口 1，同时交换机添加主机 B 到接口 3 的映射。 虚拟局域网虚拟局域网可以建立与物理位置无关的逻辑组，只有在同一个虚拟局域网中的成员才会收到链路层广播信息。 例如下图中 (A1, A2, A3, A4) 属于一个虚拟局域网，A1 发送的广播会被 A2、A3、A4 收到，而其它站点收不到。 使用 VLAN 干线连接来建立虚拟局域网，每台交换机上的一个特殊接口被设置为干线接口，以互连 VLAN 交换机。IEEE 定义了一种扩展的以太网帧格式 802.1Q，它在标准以太网帧上加进了 4 字节首部 VLAN 标签，用于表示该帧属于哪一个虚拟局域网。 四、网络层*概述因为网络层是整个互联网的核心，因此应当让网络层尽可能简单。网络层向上只提供简单灵活的、无连接的、尽最大努力交互的数据报服务。 使用 IP 协议，可以把异构的物理网络连接起来，使得在网络层看起来好像是一个统一的网络。 与 IP 协议配套使用的还有三个协议： 地址解析协议 ARP（Address Resolution Protocol） 网际控制报文协议 ICMP（Internet Control Message Protocol） 网际组管理协议 IGMP（Internet Group Management Protocol） IP 数据报格式 版本 : 有 4（IPv4）和 6（IPv6）两个值； 首部长度 : 占 4 位，因此最大值为 15。值为 1 表示的是 1 个 32 位字的长度，也就是 4 字节。因为首部固定长度为 20 字节，因此该值最小为 5。如果可选字段的长度不是 4 字节的整数倍，就用尾部的填充部分来填充。 区分服务 : 用来获得更好的服务，一般情况下不使用。 总长度 : 包括首部长度和数据部分长度。 生存时间 ：TTL，它的存在是为了防止无法交付的数据报在互联网中不断兜圈子。以路由器跳数为单位，当 TTL 为 0 时就丢弃数据报。 协议 ：指出携带的数据应该上交给哪个协议进行处理，例如 ICMP、TCP、UDP 等。 首部检验和 ：因为数据报每经过一个路由器，都要重新计算检验和，因此检验和不包含数据部分可以减少计算的工作量。 标识 : 在数据报长度过长从而发生分片的情况下，相同数据报的不同分片具有相同的标识符。 片偏移 : 和标识符一起，用于发生分片的情况。片偏移的单位为 8 字节。 IP 地址编址方式IP 地址的编址方式经历了三个历史阶段： 分类 子网划分 无分类 1. 分类由两部分组成，网络号和主机号，其中不同分类具有不同的网络号长度，并且是固定的。 IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 主机号 &gt;} 2. 子网划分通过在主机号字段中拿一部分作为子网号，把两级 IP 地址划分为三级 IP 地址。 IP 地址 ::&#x3D; {&lt; 网络号 &gt;, &lt; 子网号 &gt;, &lt; 主机号 &gt;} 要使用子网，必须配置子网掩码。一个 B 类地址的默认子网掩码为 255.255.0.0，如果 B 类地址的子网占两个比特，那么子网掩码为 11111111 11111111 11000000 00000000，也就是 255.255.192.0。 注意，外部网络看不到子网的存在。 3. 无分类无分类编址 CIDR 消除了传统 A 类、B 类和 C 类地址以及划分子网的概念，使用网络前缀和主机号来对 IP 地址进行编码，网络前缀的长度可以根据需要变化。 IP 地址 ::&#x3D; {&lt; 网络前缀号 &gt;, &lt; 主机号 &gt;} CIDR 的记法上采用在 IP 地址后面加上网络前缀长度的方法，例如 128.14.35.7&#x2F;20 表示前 20 位为网络前缀。 CIDR 的地址掩码可以继续称为子网掩码，子网掩码首 1 长度为网络前缀的长度。 一个 CIDR 地址块中有很多地址，一个 CIDR 表示的网络就可以表示原来的很多个网络，并且在路由表中只需要一个路由就可以代替原来的多个路由，减少了路由表项的数量。把这种通过使用网络前缀来减少路由表项的方式称为路由聚合，也称为 构成超网 。 在路由表中的项目由“网络前缀”和“下一跳地址”组成，在查找时可能会得到不止一个匹配结果，应当采用最长前缀匹配来确定应该匹配哪一个。 地址解析协议 ARP网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，IP 数据报的源地址和目的地址始终不变，而 MAC 地址随着链路的改变而改变。 ARP 实现由 IP 地址得到 MAC 地址。 每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。 如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射。 网际控制报文协议 ICMPICMP 是为了更有效地转发 IP 数据报和提高交付成功的机会。它封装在 IP 数据报中，但是不属于高层协议。 ICMP 报文分为差错报告报文和询问报文。 1. PingPing 是 ICMP 的一个重要应用，主要用来测试两台主机之间的连通性。 Ping 的原理是通过向目的主机发送 ICMP Echo 请求报文，目的主机收到之后会发送 Echo 回答报文。Ping 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。 2. TracerouteTraceroute 是 ICMP 的另一个应用，用来跟踪一个分组从源点到终点的路径。 Traceroute 发送的 IP 数据报封装的是无法交付的 UDP 用户数据报，并由目的主机发送终点不可达差错报告报文。 源主机向目的主机发送一连串的 IP 数据报。第一个数据报 P1 的生存时间 TTL 设置为 1，当 P1 到达路径上的第一个路由器 R1 时，R1 收下它并把 TTL 减 1，此时 TTL 等于 0，R1 就把 P1 丢弃，并向源主机发送一个 ICMP 时间超过差错报告报文； 源主机接着发送第二个数据报 P2，并把 TTL 设置为 2。P2 先到达 R1，R1 收下后把 TTL 减 1 再转发给 R2，R2 收下后也把 TTL 减 1，由于此时 TTL 等于 0，R2 就丢弃 P2，并向源主机发送一个 ICMP 时间超过差错报文。 不断执行这样的步骤，直到最后一个数据报刚刚到达目的主机，主机不转发数据报，也不把 TTL 值减 1。但是因为数据报封装的是无法交付的 UDP，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文。 之后源主机知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。 虚拟专用网 VPN由于 IP 地址的紧缺，一个机构能申请到的 IP 地址数往往远小于本机构所拥有的主机数。并且一个机构并不需要把所有的主机接入到外部的互联网中，机构内的计算机可以使用仅在本机构有效的 IP 地址（专用地址）。 有三个专用地址块： 10.0.0.0 ~ 10.255.255.255 172.16.0.0 ~ 172.31.255.255 192.168.0.0 ~ 192.168.255.255 VPN 使用公用的互联网作为本机构各专用网之间的通信载体。专用指机构内的主机只与本机构内的其它主机通信；虚拟指“好像是”，而实际上并不是，它有经过公用的互联网。 下图中，场所 A 和 B 的通信经过互联网，如果场所 A 的主机 X 要和另一个场所 B 的主机 Y 通信，IP 数据报的源地址是 10.1.0.1，目的地址是 10.2.0.3。数据报先发送到与互联网相连的路由器 R1，R1 对内部数据进行加密，然后重新加上数据报的首部，源地址是路由器 R1 的全球地址 125.1.2.3，目的地址是路由器 R2 的全球地址 194.4.5.6。路由器 R2 收到数据报后将数据部分进行解密，恢复原来的数据报，此时目的地址为 10.2.0.3，就交付给 Y。 网络地址转换 NAT专用网内部的主机使用本地 IP 地址又想和互联网上的主机通信时，可以使用 NAT 来将本地 IP 转换为全球 IP。 在以前，NAT 将本地 IP 和全球 IP 一一对应，这种方式下拥有 n 个全球 IP 地址的专用网内最多只可以同时有 n 台主机接入互联网。为了更有效地利用全球 IP 地址，现在常用的 NAT 转换表把运输层的端口号也用上了，使得多个专用网内部的主机共用一个全球 IP 地址。使用端口号的 NAT 也叫做网络地址与端口转换 NAPT。 路由器的结构路由器从功能上可以划分为：路由选择和分组转发。 分组转发结构由三个部分组成：交换结构、一组输入端口和一组输出端口。 路由器分组转发流程 从数据报的首部提取目的主机的 IP 地址 D，得到目的网络地址 N。 若 N 就是与此路由器直接相连的某个网络地址，则进行直接交付； 若路由表中有目的地址为 D 的特定主机路由，则把数据报传送给表中所指明的下一跳路由器； 若路由表中有到达网络 N 的路由，则把数据报传送给路由表中所指明的下一跳路由器； 若路由表中有一个默认路由，则把数据报传送给路由表中所指明的默认路由器； 报告转发分组出错。 路由选择协议路由选择协议都是自适应的，能随着网络通信量和拓扑结构的变化而自适应地进行调整。 互联网可以划分为许多较小的自治系统 AS，一个 AS 可以使用一种和别的 AS 不同的路由选择协议。 可以把路由选择协议划分为两大类： 自治系统内部的路由选择：RIP 和 OSPF 自治系统间的路由选择：BGP 1. 内部网关协议 RIPRIP 是一种基于距离向量的路由选择协议。距离是指跳数，直接相连的路由器跳数为 1。跳数最多为 15，超过 15 表示不可达。 RIP 按固定的时间间隔仅和相邻路由器交换自己的路由表，经过若干次交换之后，所有路由器最终会知道到达本自治系统中任何一个网络的最短距离和下一跳路由器地址。 距离向量算法： 对地址为 X 的相邻路由器发来的 RIP 报文，先修改报文中的所有项目，把下一跳字段中的地址改为 X，并把所有的距离字段加 1； 对修改后的 RIP 报文中的每一个项目，进行以下步骤： 若原来的路由表中没有目的网络 N，则把该项目添加到路由表中； 否则：若下一跳路由器地址是 X，则把收到的项目替换原来路由表中的项目；否则：若收到的项目中的距离 d 小于路由表中的距离，则进行更新（例如原始路由表项为 Net2, 5, P，新表项为 Net2, 4, X，则更新）；否则什么也不做。 若 3 分钟还没有收到相邻路由器的更新路由表，则把该相邻路由器标为不可达，即把距离置为 16。 RIP 协议实现简单，开销小。但是 RIP 能使用的最大距离为 15，限制了网络的规模。并且当网络出现故障时，要经过比较长的时间才能将此消息传送到所有路由器。 2. 内部网关协议 OSPF开放最短路径优先 OSPF，是为了克服 RIP 的缺点而开发出来的。 开放表示 OSPF 不受某一家厂商控制，而是公开发表的；最短路径优先表示使用了 Dijkstra 提出的最短路径算法 SPF。 OSPF 具有以下特点： 向本自治系统中的所有路由器发送信息，这种方法是洪泛法。 发送的信息就是与相邻路由器的链路状态，链路状态包括与哪些路由器相连以及链路的度量，度量用费用、距离、时延、带宽等来表示。 只有当链路状态发生变化时，路由器才会发送信息。 所有路由器都具有全网的拓扑结构图，并且是一致的。相比于 RIP，OSPF 的更新过程收敛的很快。 3. 外部网关协议 BGPBGP（Border Gateway Protocol，边界网关协议） AS 之间的路由选择很困难，主要是由于： 互联网规模很大； 各个 AS 内部使用不同的路由选择协议，无法准确定义路径的度量； AS 之间的路由选择必须考虑有关的策略，比如有些 AS 不愿意让其它 AS 经过。 BGP 只能寻找一条比较好的路由，而不是最佳路由。 每个 AS 都必须配置 BGP 发言人，通过在两个相邻 BGP 发言人之间建立 TCP 连接来交换路由信息。 五、运输层*网络层只把分组发送到目的主机，但是真正通信的并不是主机而是主机中的进程。运输层提供了进程间的逻辑通信，运输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是在两个运输层实体之间有一条端到端的逻辑通信信道。 UDP 和 TCP 的特点 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。 UDP 首部格式 首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。 TCP 首部格式 序号 ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。 确认号 ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。 数据偏移 ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。 确认 ACK ：当 ACK&#x3D;1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。 同步 SYN ：在连接建立时用来同步序号。当 SYN&#x3D;1，ACK&#x3D;0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN&#x3D;1，ACK&#x3D;1。 终止 FIN ：用来释放一个连接，当 FIN&#x3D;1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。 窗口 ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。 TCP 的三次握手 假设 A 为客户端，B 为服务器端。 首先 B 处于 LISTEN（监听）状态，等待客户的连接请求。 A 向 B 发送连接请求报文，SYN&#x3D;1，ACK&#x3D;0，选择一个初始的序号 x。 B 收到连接请求报文，如果同意建立连接，则向 A 发送连接确认报文，SYN&#x3D;1，ACK&#x3D;1，确认号为 x+1，同时也选择一个初始的序号 y。 A 收到 B 的连接确认报文后，还要向 B 发出确认，确认号为 y+1，序号为 x+1。 B 收到 A 的确认后，连接建立。 三次握手的原因 第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。 TCP 的四次挥手 以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。 A 发送连接释放报文，FIN&#x3D;1。 B 收到之后发出确认，此时 TCP 属于半关闭状态，B 能向 A 发送数据但是 A 不能向 B 发送数据。 当 B 不再需要连接时，发送连接释放报文，FIN&#x3D;1。 A 收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。 B 收到 A 的确认后释放连接。 四次挥手的原因 客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。 TIME_WAIT 客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由： 确保最后一个确认报文能够到达。如果 B 没收到 A 发送来的确认报文，那么就会重新发送连接释放请求报文，A 等待一段时间就是为了处理这种情况的发生。 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。 TCP 可靠传输TCP 使用超时重传来实现可靠传输：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。 一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下： 超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下： 其中 RTTd 为偏差。 TCP 滑动窗口窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。 发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。 接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31} 按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。 TCP 流量控制流量控制是为了控制发送方发送速率，保证接收方来得及接收。 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。 TCP 拥塞控制如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。 TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。 发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。 为了便于讨论，做如下假设： 接收方有足够大的接收缓存，因此不会发生流量控制； 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。 1. 慢开始与拥塞避免发送的最初执行慢开始，令 cwnd &#x3D; 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 … 注意到慢开始每个轮次都将 cwnd 加倍，这样会让 cwnd 增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能性也就更高。设置一个慢开始门限 ssthresh，当 cwnd &gt;&#x3D; ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh &#x3D; cwnd &#x2F; 2，然后重新执行慢开始。 2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。 在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh &#x3D; cwnd &#x2F; 2 ，cwnd &#x3D; ssthresh，注意到此时直接进入拥塞避免。 慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd 设定为 ssthresh。 六、应用层域名系统DNS 是一个分布式数据库，提供了主机名和 IP 地址之间相互转换的服务。这里的分布式数据库是指，每个站点只保留它自己的那部分数据。 域名具有层次结构，从上到下依次为：根域名、顶级域名、二级域名。 DNS 可以使用 UDP 或者 TCP 进行传输，使用的端口号都为 53。大多数情况下 DNS 使用 UDP 进行传输，这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。在两种情况下会使用 TCP 进行传输： 如果返回的响应超过的 512 字节（UDP 最大只支持 512 字节的数据）。 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。 文件传送协议FTP 使用 TCP 进行连接，它需要两个连接来传送一个文件： 控制连接：服务器打开端口号 21 等待客户端的连接，客户端主动建立连接后，使用这个连接将客户端的命令传送给服务器，并传回服务器的应答。 数据连接：用来传送一个文件数据。 根据数据连接是否是服务器端主动建立，FTP 有主动和被动两种模式： 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 20，客户端的端口号随机，但是必须大于 1024，因为 0~1023 是熟知端口号。 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。 主动模式要求客户端开放端口号给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是被动模式会导致服务器端的安全性减弱，因为开放了过多的端口号。 动态主机配置协议DHCP (Dynamic Host Configuration Protocol) 提供了即插即用的连网方式，用户不再需要去手动配置 IP 地址等信息。 DHCP 配置的内容不仅是 IP 地址，还包括子网掩码、网关 IP 地址。 DHCP 工作过程如下： 客户端发送 Discover 报文，该报文的目的地址为 255.255.255.255:67，源地址为 0.0.0.0:68，被放入 UDP 中，该报文被广播到同一个子网的所有主机上。如果客户端和 DHCP 服务器不在同一个子网，就需要使用中继代理。 DHCP 服务器收到 Discover 报文之后，发送 Offer 报文给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到多个 DHCP 服务器提供的信息，因此客户端需要进行选择。 如果客户端选择了某个 DHCP 服务器提供的信息，那么就发送 Request 报文给该 DHCP 服务器。 DHCP 服务器发送 Ack 报文，表示客户端此时可以使用提供给它的信息。 远程登录协议TELNET 用于登录到远程主机上，并且远程主机上的输出也会返回。 TELNET 可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。 电子邮件协议一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。 邮件协议包含发送协议和读取协议，发送协议常用 SMTP，读取协议常用 POP3 和 IMAP。 1. SMTPSMTP 只能发送 ASCII 码，而互联网邮件扩充 MIME 可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。 2. POP3POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。 3. IMAPIMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。 常用端口 应用 应用层协议 端口号 运输层协议 备注 域名解析 DNS 53 UDP&#x2F;TCP 长度超过 512 字节时使用 TCP 动态主机配置协议 DHCP 67&#x2F;68 UDP 简单网络管理协议 SNMP 161&#x2F;162 UDP 文件传送协议 FTP 20&#x2F;21 TCP 控制连接 21，数据连接 20 远程终端协议 TELNET 23 TCP 超文本传送协议 HTTP 80 TCP 简单邮件传送协议 SMTP 25 TCP 邮件读取协议 POP3 110 TCP 网际报文存取协议 IMAP 143 TCP Web 页面请求过程1. DHCP 配置主机信息 假设主机最开始没有 IP 地址以及其它信息，那么就需要先使用 DHCP 来获取。 主机生成一个 DHCP 请求报文，并将这个报文放入具有目的端口 67 和源端口 68 的 UDP 报文段中。 该报文段则被放入在一个具有广播 IP 目的地址(255.255.255.255) 和源 IP 地址（0.0.0.0）的 IP 数据报中。 该数据报则被放置在 MAC 帧中，该帧具有目的地址 FF:FF:FF:FF:FF:FF，将广播到与交换机连接的所有设备。 连接在交换机的 DHCP 服务器收到广播帧之后，不断地向上分解得到 IP 数据报、UDP 报文段、DHCP 请求报文，之后生成 DHCP ACK 报文，该报文包含以下信息：IP 地址、DNS 服务器的 IP 地址、默认网关路由器的 IP 地址和子网掩码。该报文被放入 UDP 报文段中，UDP 报文段有被放入 IP 数据报中，最后放入 MAC 帧中。 该帧的目的地址是请求主机的 MAC 地址，因为交换机具有自学习能力，之前主机发送了广播帧之后就记录了 MAC 地址到其转发接口的交换表项，因此现在交换机就可以直接知道应该向哪个接口发送该帧。 主机收到该帧后，不断分解得到 DHCP 报文。之后就配置它的 IP 地址、子网掩码和 DNS 服务器的 IP 地址，并在其 IP 转发表中安装默认网关。 2. ARP 解析 MAC 地址 主机通过浏览器生成一个 TCP 套接字，套接字向 HTTP 服务器发送 HTTP 请求。为了生成该套接字，主机需要知道网站的域名对应的 IP 地址。 主机生成一个 DNS 查询报文，该报文具有 53 号端口，因为 DNS 服务器的端口号是 53。 该 DNS 查询报文被放入目的地址为 DNS 服务器 IP 地址的 IP 数据报中。 该 IP 数据报被放入一个以太网帧中，该帧将发送到网关路由器。 DHCP 过程只知道网关路由器的 IP 地址，为了获取网关路由器的 MAC 地址，需要使用 ARP 协议。 主机生成一个包含目的地址为网关路由器 IP 地址的 ARP 查询报文，将该 ARP 查询报文放入一个具有广播目的地址（FF:FF:FF:FF:FF:FF）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。 网关路由器接收到该帧后，不断向上分解得到 ARP 报文，发现其中的 IP 地址与其接口的 IP 地址匹配，因此就发送一个 ARP 回答报文，包含了它的 MAC 地址，发回给主机。 3. DNS 解析域名 知道了网关路由器的 MAC 地址之后，就可以继续 DNS 的解析过程了。 网关路由器接收到包含 DNS 查询报文的以太网帧后，抽取出 IP 数据报，并根据转发表决定该 IP 数据报应该转发的路由器。 因为路由器具有内部网关协议（RIP、OSPF）和外部网关协议（BGP）这两种路由选择协议，因此路由表中已经配置了网关路由器到达 DNS 服务器的路由表项。 到达 DNS 服务器之后，DNS 服务器抽取出 DNS 查询报文，并在 DNS 数据库中查找待解析的域名。 找到 DNS 记录之后，发送 DNS 回答报文，将该回答报文放入 UDP 报文段中，然后放入 IP 数据报中，通过路由器反向转发回网关路由器，并经过以太网交换机到达主机。 4. HTTP 请求页面 有了 HTTP 服务器的 IP 地址之后，主机就能够生成 TCP 套接字，该套接字将用于向 Web 服务器发送 HTTP GET 报文。 在生成 TCP 套接字之前，必须先与 HTTP 服务器进行三次握手来建立连接。生成一个具有目的端口 80 的 TCP SYN 报文段，并向 HTTP 服务器发送该报文段。 HTTP 服务器收到该报文段之后，生成 TCP SYN ACK 报文段，发回给主机。 连接建立之后，浏览器生成 HTTP GET 报文，并交付给 HTTP 服务器。 HTTP 服务器从 TCP 套接字读取 HTTP GET 报文，生成一个 HTTP 响应报文，将 Web 页面内容放入报文主体中，发回给主机。 浏览器收到 HTTP 响应报文后，抽取出 Web 页面内容，之后进行渲染，显示 Web 页面。 参考资料 计算机网络, 谢希仁 JamesF.Kurose, KeithW.Ross, 库罗斯, 等. 计算机网络: 自顶向下方法 [M]. 机械工业出版社, 2014. W.RichardStevens. TCP&#x2F;IP 详解. 卷 1, 协议 [M]. 机械工业出版社, 2006. Active vs Passive FTP Mode: Which One is More Secure? Active and Passive FTP Transfers Defined - KB Article #1138 Traceroute ping How DHCP works and DHCP Interview Questions and Answers What is process of DORA in DHCP? What is DHCP Server ? Tackling emissions targets in Tokyo What does my ISP know when I use Tor? Technology-Computer Networking[1]-Computer Networks and the Internet P2P 网络概述. Circuit Switching (a) Circuit switching. (b) Packet switching.","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"数据通信","slug":"数据通信","permalink":"https://blog.jugg.xyz/tags/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"},{"name":"网络协议","slug":"网络协议","permalink":"https://blog.jugg.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"}]},{"title":"计算机操作系统基础知识","slug":"repost/Operating-System","date":"2018-04-06T10:30:02.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2018/04/06/repost/Operating-System/","permalink":"https://blog.jugg.xyz/2018/04/06/repost/Operating-System/","excerpt":"","text":"本文转载自 CS-Note 项目 一、概述基本特征1. 并发并发是指宏观上在一段时间内能同时运行多个程序，而并行则指同一时刻能运行多个指令。 并行需要硬件支持，如多流水线或者多处理器。 操作系统通过引入进程和线程，使得程序能够并发运行。 2. 共享共享是指系统中的资源可以被多个并发进程共同使用。 有两种共享方式：互斥共享和同时共享。 互斥共享的资源称为临界资源，例如打印机等，在同一时间只允许一个进程访问，需要用同步机制来实现对临界资源的访问。 3. 虚拟虚拟技术把一个物理实体转换为多个逻辑实体。 主要有两种虚拟技术：时分复用技术和空分复用技术。 多个进程能在同一个处理器上并发执行使用了时分复用技术，让每个进程轮流占有处理器，每次只执行一小个时间片并快速切换。 虚拟内存使用了空分复用技术，它将物理内存抽象为地址空间，每个进程都有各自的地址空间。地址空间和物理内存使用页进行交换，地址空间的页并不需要全部在物理内存中，当使用到一个没有在物理内存的页时，执行页面置换算法，将该页置换到内存中。 4. 异步异步指进程不是一次性执行完毕，而是走走停停，以不可知的速度向前推进。 基本功能1. 进程管理进程控制、进程同步、进程通信、死锁处理、处理机调度等。 2. 内存管理内存分配、地址映射、内存保护与共享、虚拟内存等。 3. 文件管理文件存储空间的管理、目录管理、文件读写管理和保护等。 4. 设备管理完成用户的 I&#x2F;O 请求，方便用户使用各种设备，并提高设备的利用率。 主要包括缓冲管理、设备分配、设备处理、虛拟设备等。 系统调用如果一个进程在用户态需要使用内核态的功能，就进行系统调用从而陷入内核，由操作系统代为完成。 Linux 的系统调用主要有以下这些： Task Commands 进程控制 fork(); exit(); wait(); 进程通信 pipe(); shmget(); mmap(); 文件操作 open(); read(); write(); 设备操作 ioctl(); read(); write(); 信息维护 getpid(); alarm(); sleep(); 安全 chmod(); umask(); chown(); 大内核和微内核1. 大内核大内核是将操作系统功能作为一个紧密结合的整体放到内核。 由于各模块共享信息，因此有很高的性能。 2. 微内核由于操作系统不断复杂，因此将一部分操作系统功能移出内核，从而降低内核的复杂性。移出的部分根据分层的原则划分成若干服务，相互独立。 在微内核结构下，操作系统被划分成小的、定义良好的模块，只有微内核这一个模块运行在内核态，其余模块运行在用户态。 因为需要频繁地在用户态和核心态之间进行切换，所以会有一定的性能损失。 中断分类1. 外中断由 CPU 执行指令以外的事件引起，如 I&#x2F;O 完成中断，表示设备输入&#x2F;输出处理已经完成，处理器能够发送下一个输入&#x2F;输出请求。此外还有时钟中断、控制台中断等。 2. 异常由 CPU 执行指令的内部事件引起，如非法操作码、地址越界、算术溢出等。 3. 陷入在用户程序中使用系统调用。 二、进程管理进程与线程1. 进程进程是资源分配的基本单位。 进程控制块 (Process Control Block, PCB) 描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 PCB 的操作。 下图显示了 4 个程序创建了 4 个进程，这 4 个进程可以并发地执行。 2. 线程线程是独立调度的基本单位。 一个进程中可以有多个线程，它们共享进程资源。 QQ 和浏览器是两个进程，浏览器进程里面有很多线程，例如 HTTP 请求线程、事件响应线程、渲染线程等等，线程的并发执行使得在浏览器中点击一个新链接从而发起 HTTP 请求时，浏览器还可以响应用户的其它事件。 3. 区别（一）拥有资源 进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。 （二）调度 线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程内的线程切换到另一个进程中的线程时，会引起进程切换。 （三）系统开销 由于创建或撤销进程时，系统都要为之分配或回收资源，如内存空间、I&#x2F;O 设备等，所付出的开销远大于创建或撤销线程时的开销。类似地，在进行进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。 （四）通信方面 进程间通信 (IPC) 需要进程同步和互斥手段的辅助，以保证数据的一致性。而线程间可以通过直接读&#x2F;写同一进程中的数据段（如全局变量）来进行通信。 进程状态的切换 就绪状态（ready）：等待被调度 运行状态（running） 阻塞状态（waiting）：等待资源 应该注意以下内容： 只有就绪态和运行态可以相互转换，其它的都是单向转换。就绪状态的进程通过调度算法从而获得 CPU 时间，转为运行状态；而运行状态的进程，在分配给它的 CPU 时间片用完之后就会转为就绪状态，等待下一次调度。 阻塞状态是缺少需要的资源从而由运行状态转换而来，但是该资源不包括 CPU 时间，缺少 CPU 时间会从运行态转换为就绪态。 进程调度算法不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。 1. 批处理系统批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。 1.1 先来先服务 first-come first-serverd（FCFS） 按照请求的顺序进行调度。 有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。 1.2 短作业优先 shortest job first（SJF） 按估计运行时间最短的顺序进行调度。 长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。 1.3 最短剩余时间优先 shortest remaining time next（SRTN） 按估计剩余时间最短的顺序进行调度。 2. 交互式系统交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。 2.1 时间片轮转 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。 时间片轮转算法的效率和时间片的大小有很大关系： 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。 而如果时间片过长，那么实时性就不能得到保证。 2.2 优先级调度 为每个进程分配一个优先级，按优先级进行调度。 为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。 2.3 多级反馈队列 如果一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。 多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。 每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。 可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。 3. 实时系统实时系统要求一个请求在一个确定时间内得到响应。 分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。 进程同步1. 临界区对临界资源进行访问的那段代码称为临界区。 为了互斥访问临界资源，每个进程在进入临界区之前，需要先进行检查。 123// entry section// critical section;// exit section 2. 同步与互斥 同步：多个进程按一定顺序执行； 互斥：多个进程在同一时刻只有一个进程能进入临界区。 3. 信号量信号量（Semaphore）是一个整型变量，可以对其执行 down 和 up 操作，也就是常见的 P 和 V 操作。 down : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0； up ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。 down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。 如果信号量的取值只能为 0 或者 1，那么就成为了 互斥量（Mutex） ，0 表示临界区已经加锁，1 表示临界区解锁。 12345678910111213typedef int semaphore;semaphore mutex = 1;void P1() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125;void P2() &#123; down(&amp;mutex); // 临界区 up(&amp;mutex);&#125; 使用信号量实现生产者-消费者问题 问题描述：使用一个缓冲区来保存物品，只有缓冲区没有满，生产者才可以放入物品；只有缓冲区不为空，消费者才可以拿走物品。 因为缓冲区属于临界资源，因此需要使用一个互斥量 mutex 来控制对缓冲区的互斥访问。 为了同步生产者和消费者的行为，需要记录缓冲区中物品的数量。数量可以使用信号量来进行统计，这里需要使用两个信号量：empty 记录空缓冲区的数量，full 记录满缓冲区的数量。其中，empty 信号量是在生产者进程中使用，当 empty 不为 0 时，生产者才可以放入物品；full 信号量是在消费者进程中使用，当 full 信号量不为 0 时，消费者才可以取走物品。 注意，不能先对缓冲区进行加锁，再测试信号量。也就是说，不能先执行 down(mutex) 再执行 down(empty)。如果这么做了，那么可能会出现这种情况：生产者对缓冲区加锁后，执行 down(empty) 操作，发现 empty &#x3D; 0，此时生产者睡眠。消费者不能进入临界区，因为生产者对缓冲区加锁了，消费者就无法执行 up(empty) 操作，empty 永远都为 0，导致生产者永远等待下，不会释放锁，消费者因此也会永远等待下去。 123456789101112131415161718192021222324252627#define N 100typedef int semaphore;semaphore mutex = 1;semaphore empty = N;semaphore full = 0;void producer() &#123; while(TRUE) &#123; int item = produce_item(); down(&amp;empty); down(&amp;mutex); insert_item(item); up(&amp;mutex); up(&amp;full); &#125;&#125;void consumer() &#123; while(TRUE) &#123; down(&amp;full); down(&amp;mutex); int item = remove_item(); up(&amp;mutex); up(&amp;empty); consume_item(item); &#125;&#125; 4. 管程使用信号量机制实现的生产者消费者问题需要客户端代码做很多控制，而管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。 c 语言不支持管程，下面的示例代码使用了类 Pascal 语言来描述管程。示例代码的管程提供了 insert() 和 remove() 方法，客户端代码通过调用这两个方法来解决生产者-消费者问题。 1234567891011121314monitor ProducerConsumer integer i; condition c; procedure insert(); begin // ... end; procedure remove(); begin // ... end;end monitor; 管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否者其它进程永远不能使用管程。 管程引入了 条件变量 以及相关的操作：wait() 和 signal() 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。 使用管程实现生产者-消费者问题 123456789101112131415161718192021222324252627282930313233343536373839404142// 管程monitor ProducerConsumer condition full, empty; integer count := 0; condition c; procedure insert(item: integer); begin if count = N then wait(full); insert_item(item); count := count + 1; if count = 1 then signal(empty); end; function remove: integer; begin if count = 0 then wait(empty); remove = remove_item; count := count - 1; if count = N -1 then signal(full); end;end monitor;// 生产者客户端procedure producerbegin while true do begin item = produce_item; ProducerConsumer.insert(item); endend;// 消费者客户端procedure consumerbegin while true do begin item = ProducerConsumer.remove; consume_item(item); endend; 经典同步问题生产者和消费者问题前面已经讨论过了。 1. 读者-写者问题允许多个进程同时对数据进行读操作，但是不允许读和写以及写和写操作同时发生。 一个整型变量 count 记录在对数据进行读操作的进程数量，一个互斥量 count_mutex 用于对 count 加锁，一个互斥量 data_mutex 用于对读写的数据加锁。 1234567891011121314151617181920212223242526typedef int semaphore;semaphore count_mutex = 1;semaphore data_mutex = 1;int count = 0;void reader() &#123; while(TRUE) &#123; down(&amp;count_mutex); count++; if(count == 1) down(&amp;data_mutex); // 第一个读者需要对数据进行加锁，防止写进程访问 up(&amp;count_mutex); read(); down(&amp;count_mutex); count--; if(count == 0) up(&amp;data_mutex); up(&amp;count_mutex); &#125;&#125;void writer() &#123; while(TRUE) &#123; down(&amp;data_mutex); write(); up(&amp;data_mutex); &#125;&#125; 2. 哲学家进餐问题 五个哲学家围着一张圆桌，每个哲学家面前放着食物。哲学家的生活有两种交替活动：吃饭以及思考。当一个哲学家吃饭时，需要先拿起自己左右两边的两根筷子，并且一次只能拿起一根筷子。 下面是一种错误的解法，考虑到如果所有哲学家同时拿起左手边的筷子，那么就无法拿起右手边的筷子，造成死锁。 123456789101112#define N 5void philosopher(int i) &#123; while(TRUE) &#123; think(); take(i); // 拿起左边的筷子 take((i+1)%N); // 拿起右边的筷子 eat(); put(i); put((i+1)%N); &#125;&#125; 为了防止死锁的发生，可以设置两个条件： 必须同时拿起左右两根筷子； 只有在两个邻居都没有进餐的情况下才允许进餐。 123456789101112131415161718192021222324252627282930313233343536373839404142#define N 5#define LEFT (i + N - 1) % N // 左邻居#define RIGHT (i + 1) % N // 右邻居#define THINKING 0#define HUNGRY 1#define EATING 2typedef int semaphore;int state[N]; // 跟踪每个哲学家的状态semaphore mutex = 1; // 临界区的互斥semaphore s[N]; // 每个哲学家一个信号量void philosopher(int i) &#123; while(TRUE) &#123; think(); take_two(i); eat(); put_tow(i); &#125;&#125;void take_two(int i) &#123; down(&amp;mutex); state[i] = HUNGRY; test(i); up(&amp;mutex); down(&amp;s[i]);&#125;void put_tow(i) &#123; down(&amp;mutex); state[i] = THINKING; test(LEFT); test(RIGHT); up(&amp;mutex);&#125;void test(i) &#123; // 尝试拿起两把筷子 if(state[i] == HUNGRY &amp;&amp; state[LEFT] != EATING &amp;&amp; state[RIGHT] !=EATING) &#123; state[i] = EATING; up(&amp;s[i]); &#125;&#125; 进程通信进程同步与进程通信很容易混淆，它们的区别在于： 进程同步：控制多个进程按一定顺序执行； 进程通信：进程间传输信息。 进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。 1. 管道管道是通过调用 pipe 函数创建的，fd[0] 用于读，fd[1] 用于写。 12#include &lt;unistd.h&gt;int pipe(int fd[2]); 它具有以下限制： 只支持半双工通信（单向交替传输）； 只能在父子进程中使用。 2. FIFO也称为命名管道，去除了管道只能在父子进程中使用的限制。 123#include &lt;sys/stat.h&gt;int mkfifo(const char *path, mode_t mode);int mkfifoat(int fd, const char *path, mode_t mode); FIFO 常用于客户-服务器应用程序中，FIFO 用作汇聚点，在客户进程和服务器进程之间传递数据。 3. 消息队列相比于 FIFO，消息队列具有以下优点： 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难； 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法； 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。 4. 信号量它是一个计数器，用于为多个进程提供对共享数据对象的访问。 5. 共享存储允许多个进程共享一个给定的存储区。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。 需要使用信号量用来同步对共享存储的访问。 多个进程可以将同一个文件映射到它们的地址空间从而实现共享内存。另外 XSI 共享内存不是使用文件，而是使用使用内存的匿名段。 6. 套接字与其它通信机制不同的是，它可用于不同机器间的进程通信。 三、死锁死锁的必要条件 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。 占有和等待：已经得到了某个资源的进程可以再请求新的资源。 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。 死锁的处理方法1. 鸵鸟策略把头埋在沙子里，假装根本没发生问题。 因为解决死锁问题的代价很高，因此鸵鸟策略这种不采取任务措施的方案会获得更高的性能。当发生死锁时不会对用户造成多大影响，或发生死锁的概率很低，可以采用鸵鸟策略。 大多数操作系统，包括 Unix，Linux 和 Windows，处理死锁问题的办法仅仅是忽略它。 2. 死锁检测与死锁恢复不试图阻止死锁，而是当检测到死锁发生时，采取措施进行恢复。 （一）每种类型一个资源的死锁检测 上图为资源分配图，其中方框表示资源，圆圈表示进程。资源指向进程表示该资源已经分配给该进程，进程指向资源表示进程请求获取该资源。 图 a 可以抽取出环，如图 b，它满足了环路等待条件，因此会发生死锁。 每种类型一个资源的死锁检测算法是通过检测有向图是否存在环来实现，从一个节点出发进行深度优先搜索，对访问过的节点进行标记，如果访问了已经标记的节点，就表示有向图存在环，也就是检测到死锁的发生。 （二）每种类型多个资源的死锁检测 上图中，有三个进程四个资源，每个数据代表的含义如下： E 向量：资源总量 A 向量：资源剩余量 C 矩阵：每个进程所拥有的资源数量，每一行都代表一个进程拥有资源的数量 R 矩阵：每个进程请求的资源数量 进程 P1 和 P2 所请求的资源都得不到满足，只有进程 P3 可以，让 P3 执行，之后释放 P3 拥有的资源，此时 A &#x3D; (2 2 2 0)。P2 可以执行，执行后释放 P2 拥有的资源，A &#x3D; (4 2 2 1) 。P1 也可以执行。所有进程都可以顺利执行，没有死锁。 算法总结如下： 每个进程最开始时都不被标记，执行过程有可能被标记。当算法结束时，任何没有被标记的进程都是死锁进程。 寻找一个没有标记的进程 Pi，它所请求的资源小于等于 A。 如果找到了这样一个进程，那么将 C 矩阵的第 i 行向量加到 A 中，标记该进程，并转回 1。 如果没有这样一个进程，算法终止。 （三）死锁恢复 利用抢占恢复 利用回滚恢复 通过杀死进程恢复 3. 死锁预防在程序运行之前预防发生死锁。 （一）破坏互斥条件 例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。 （二）破坏占有和等待条件 一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。 （三）破坏不可抢占条件 （四）破坏环路等待 给资源统一编号，进程只能按编号顺序来请求资源。 4. 死锁避免在程序运行时避免发生死锁。 （一）安全状态 图 a 的第二列 Has 表示已拥有的资源数，第三列 Max 表示总共需要的资源数，Free 表示还有可以使用的资源数。从图 a 开始出发，先让 B 拥有所需的所有资源（图 b），运行结束后释放 B，此时 Free 变为 5（图 c）；接着以同样的方式运行 C 和 A，使得所有进程都能成功运行，因此可以称图 a 所示的状态时安全的。 定义：如果没有死锁发生，并且即使所有进程突然请求对资源的最大需求，也仍然存在某种调度次序能够使得每一个进程运行完毕，则称该状态是安全的。 安全状态的检测与死锁的检测类似，因为安全状态必须要求不能发生死锁。下面的银行家算法与死锁检测算法非常类似，可以结合着做参考对比。 （二）单个资源的银行家算法 一个小城镇的银行家，他向一群客户分别承诺了一定的贷款额度，算法要做的是判断对请求的满足是否会进入不安全状态，如果是，就拒绝请求；否则予以分配。 上图 c 为不安全状态，因此算法会拒绝之前的请求，从而避免进入图 c 中的状态。 （三）多个资源的银行家算法 上图中有五个进程，四个资源。左边的图表示已经分配的资源，右边的图表示还需要分配的资源。最右边的 E、P 以及 A 分别表示：总资源、已分配资源以及可用资源，注意这三个为向量，而不是具体数值，例如 A&#x3D;(1020)，表示 4 个资源分别还剩下 1&#x2F;0&#x2F;2&#x2F;0。 检查一个状态是否安全的算法如下： 查找右边的矩阵是否存在一行小于等于向量 A。如果不存在这样的行，那么系统将会发生死锁，状态是不安全的。 假若找到这样一行，将该进程标记为终止，并将其已分配资源加到 A 中。 重复以上两步，直到所有进程都标记为终止，则状态时安全的。 如果一个状态不是安全的，需要拒绝进入这个状态。 四、内存管理虚拟内存虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。 为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。 从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序称为可能。例如有一台计算机可以产生 16 位地址，那么一个程序的地址空间范围是 0~64K。该计算机只有 32KB 的物理内存，虚拟内存技术允许该计算机运行一个 64K 大小的程序。 分页系统地址映射内存管理单元（MMU）管理着地址空间和物理内存的转换，其中的页表（Page table）存储着页（程序地址空间）和页框（物理内存空间）的映射表。 下图的页表存放着 16 个页，这 16 个页需要用 4 个比特位来进行索引定位，也就是存储页面号，剩下 12 个比特位存储偏移量。 例如对于虚拟地址（0010 000000000100），前 4 位是存储页面号 2，读取表项内容为（110 1）。该页在内存中，并且页框的地址为 （110 000000000100）。 页面置换算法在程序运行过程中，如果要访问的页面不在内存中，就发生缺页中断从而将该页调入内存中。此时如果内存已无空闲空间，系统必须从内存中调出一个页面到磁盘对换区中来腾出空间。 页面置换算法和缓存淘汰策略类似，可以将内存看成磁盘的缓存。在缓存系统中，缓存的大小有限，当有新的缓存到达时，需要淘汰一部分已经存在的缓存，这样才有空间存放新的缓存数据。 页面置换算法的主要目标是使页面置换频率最低（也可以说缺页率最低）。 1. 最佳 Optimal 所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。 是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。 举例：一个系统为某进程分配了三个物理块，并有如下页面引用序列： 开始运行时，先将 7, 0, 1 三个页面装入内存。当进程要访问页面 2 时，产生缺页中断，会将页面 7 换出，因为页面 7 再次被访问的时间最长。 2. 最近最久未使用 LRU, Least Recently Used 虽然无法知道将来要使用的页面情况，但是可以知道过去使用页面的情况。LRU 将最近最久未使用的页面换出。 为了实现 LRU，需要在内存中维护一个所有页面的链表。当一个页面被访问时，将这个页面移到链表表头。这样就能保证链表表尾的页面时最近最久未访问的。 因为每次访问都需要更新链表，因此这种方式实现的 LRU 代价很高。 3. 最近未使用 NRU, Not Recently Used 每个页面都有两个状态位：R 与 M，当页面被访问时设置页面的 R&#x3D;1，当页面被修改时设置 M&#x3D;1。其中 R 位会定时被清零。可以将页面分成以下四类： R&#x3D;0，M&#x3D;0 R&#x3D;0，M&#x3D;1 R&#x3D;1，M&#x3D;0 R&#x3D;1，M&#x3D;1 当发生缺页中断时，NRU 算法随机地从类编号最小的非空类中挑选一个页面将它换出。 NRU 优先换出已经被修改的脏页面（R&#x3D;0，M&#x3D;1），而不是被频繁使用的干净页面（R&#x3D;1，M&#x3D;0）。 4. 先进先出 FIFO, First In First Out 选择换出的页面是最先进入的页面。 该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。 5. 第二次机会算法FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改： 当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。 6. 时钟 Clock 第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。 分段虚拟内存采用的是分页技术，也就是将地址空间划分成固定大小的页，每一页再与内存进行映射。 下图为一个编译器在编译过程中建立的多个表，有 4 个表是动态增长的，如果使用分页系统的一维地址空间，动态增长的特点会导致覆盖问题的出现。 分段的做法是把每个表分成段，一个段构成一个独立的地址空间。每个段的长度可以不同，并且可以动态增长。 段页式程序的地址空间划分成多个拥有独立地址空间的段，每个段上的地址空间划分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。 分页与分段的比较 对程序员的透明性：分页透明，但是分段需要程序员显示划分每个段。 地址空间的维度：分页是一维地址空间，分段是二维的。 大小是否可以改变：页的大小不可变，段的大小可以动态改变。 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。 五、设备管理磁盘结构 盘面（Platter）：一个磁盘有多个盘面； 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道； 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小； 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）； 制动手臂（Actuator arm）：用于在磁道之间移动磁头； 主轴（Spindle）：使整个盘面转动。 磁盘调度算法读写一个磁盘块的时间的影响因素有： 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上） 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上） 实际的数据传输时间 其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。 1. 先来先服务 FCFS, First Come First Served 按照磁盘请求的顺序进行调度。 优点是公平和简单。缺点也很明显，因为未对寻道做任何优化，使平均寻道时间可能较长。 2. 最短寻道时间优先 SSTF, Shortest Seek Time First 优先调度与当前磁头所在磁道距离最近的磁道。 虽然平均寻道时间比较低，但是不够公平。如果新到达的磁道请求总是比一个在等待的磁道请求近，那么在等待的磁道请求会一直等待下去，也就是出现饥饿现象。具体来说，两边的磁道请求更容易出现饥饿现象。 3. 电梯算法 SCAN 电梯总是保持一个方向运行，直到该方向没有请求为止，然后改变运行方向。 电梯算法（扫描算法）和电梯的运行过程类似，总是按一个方向来进行磁盘调度，直到该方向上没有未完成的磁盘请求，然后改变方向。 因为考虑了移动方向，因此所有的磁盘请求都会被满足，解决了 SSTF 的饥饿问题。 六、链接编译系统以下是一个 hello.c 程序： 1234567#include &lt;stdio.h&gt;int main()&#123; printf(&quot;hello, world\\n&quot;); return 0;&#125; 在 Unix 系统上，由编译器把源文件转换为目标文件。 1gcc -o hello hello.c 这个过程大致如下： 预处理阶段：处理以 # 开头的预处理命令； 编译阶段：翻译成汇编文件； 汇编阶段：将汇编文件翻译成可重定向目标文件； 链接阶段：将可重定向目标文件和 printf.o 等单独预编译好的目标文件进行合并，得到最终的可执行目标文件。 静态链接静态连接器以一组可重定向目标文件为输入，生成一个完全链接的可执行目标文件作为输出。链接器主要完成以下两个任务： 符号解析：每个符号对应于一个函数、一个全局变量或一个静态变量，符号解析的目的是将每个符号引用与一个符号定义关联起来。 重定位：链接器通过把每个符号定义与一个内存位置关联起来，然后修改所有对这些符号的引用，使得它们指向这个内存位置。 目标文件 可执行目标文件：可以直接在内存中执行； 可重定向目标文件：可与其它可重定向目标文件在链接阶段合并，创建一个可执行目标文件； 共享目标文件：这是一种特殊的可重定向目标文件，可以在运行时被动态加载进内存并链接； 动态链接静态库有以下两个问题： 当静态库更新时那么整个程序都要重新进行链接； 对于 printf 这种标准函数库，如果每个程序都要有代码，这会极大浪费资源。 共享库是为了解决静态库的这两个问题而设计的，在 Linux 系统中通常用 .so 后缀来表示，Windows 系统上它们被称为 DLL。它具有以下特点： 在给定的文件系统中一个库只有一个文件，所有引用该库的可执行目标文件都共享这个文件，它不会被复制到引用它的可执行文件中； 在内存中，一个共享库的 .text 节（已编译程序的机器代码）的一个副本可以被不同的正在运行的进程共享。 参考资料 Tanenbaum A S, Bos H. Modern operating systems[M]. Prentice Hall Press, 2014. 汤子瀛, 哲凤屏, 汤小丹. 计算机操作系统[M]. 西安电子科技大学出版社, 2001. Bryant, R. E., &amp; O’Hallaron, D. R. (2004). 深入理解计算机系统. 史蒂文斯. UNIX 环境高级编程 [M]. 人民邮电出版社, 2014. Operating System Notes Operating-System Structures Processes Inter Process Communication Presentation[1] Decoding UCS Invicta – Part 1","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jugg.xyz/tags/Linux/"},{"name":"UNIX","slug":"UNIX","permalink":"https://blog.jugg.xyz/tags/UNIX/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.jugg.xyz/tags/Windows/"}]},{"title":"让 Hexo 博客支持 PWA","slug":"frontend/PWA-for-hexo","date":"2018-04-04T15:59:49.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2018/04/04/frontend/PWA-for-hexo/","permalink":"https://blog.jugg.xyz/2018/04/04/frontend/PWA-for-hexo/","excerpt":"","text":"Progressive Web Apps (PWAs) are web applications that are regular web pages or websites, but can appear to the user like traditional applications or native mobile applications. The application type attempts to combine features offered by most modern browsers with the benefits of a mobile experience. –摘自维基百科 支持 HTTPS支持 PWA 的第一步，就是全站 HTTPS。我的个人博客呢，是用 Hexo 生成静态页面，然后再通过 Nginx 进行代理，所以直接申请个免费的 SSL 证书就好了。（但是被图床的 HTTP 资源折腾了一下，&#x3D;。&#x3D;这个暂且不谈。） 配置 hexo-pwa 插件Hexo 支持 PWA 非常方便，因为已经有了专门的模块 hexo-pwa，直接在博客目录用一行命令安装就行了： 1$ npm install --save hexo-pwa 然后再配置站点的_config.yml文件，在最后添加 PWA 配置： 1234567891011121314151617181920212223242526pwa: manifest: path: /manifest.json body: name: hexo short_name: hexo icons: - src: /images/android-chrome-192x192.png sizes: 192x192 type: image/png serviceWorker: path: /sw.js preload: urls: - /* posts: 5 opts: networkTimeoutSeconds: 5 routes: - pattern: !!js/regexp /hm.baidu.com/ strategy: networkOnly - pattern: !!js/regexp /.*\\.(js|css|jpg|jpeg|png|gif)$/ strategy: cacheFirst - pattern: !!js/regexp /\\// strategy: networkFirst priority: 5 配置内容介绍这里的配置中，第一段 manifest，里面的path就是你的 manifest.json 的位置；body 则是 manifest.json 的内容，可以写满，也可以为空。为空的话就会按照你的 path 设置去读取你的 manifest.json 文件内容。这个 manifest.json 也是 PWA 的关键内容，如果嫌配置麻烦的话，可以用 App Manifest Generator 这个网站一键生成。把生成完的配置文件丢到 &#x2F;source 文件夹下就行了。 第二段的 serviceWorker 是 service worker 的配置文件，path 还是填写你的 sw.js 的位置。preload 则是填写你想要缓存的网址，设置为 &#x2F;* 则是缓存所有页面，里面的 posts 是则是你想要缓存的页面数量上限。opts 和 routes 可以通过 sw-toolbox 了解。 最后的 priority 是插件优先级的设置，相关内容可以点 plugin priority 深入了解。 这里还有一个坑，就是在 Safari 如果添加到主页，他默认会选择你添加的那个页面的截图作为图标，而不是你设置的图标，所以这里需要单独为 iOS 用户生成一个图标: source&#x2F;apple-touch-icon.png(ps.iOS 默认用黑色填充透明图层，所以建议不要选择又透明图层的图片作为图标，或者手动用白色填充下)。更多配置参考 Configuring Web Applications。iOS上的坑还有很多，诸如状态栏外观、链接到外部程序等，这也是#TODO的一部分，日后再谈。作为示例，这是我的 manifest.json 。 当然了，这只是初步支持 PWA，日后支持推送、弹窗等功能后我再继续更新吧。（逃 学习资料：百度 LAVAS 、Progressive Web Apps (PWA) 中文版","categories":[{"name":"前端","slug":"前端","permalink":"https://blog.jugg.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"Node.js","slug":"Node-js","permalink":"https://blog.jugg.xyz/tags/Node-js/"},{"name":"PWA","slug":"PWA","permalink":"https://blog.jugg.xyz/tags/PWA/"}]},{"title":"Linux 基础知识","slug":"repost/Linux","date":"2018-04-03T07:53:30.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2018/04/03/repost/Linux/","permalink":"https://blog.jugg.xyz/2018/04/03/repost/Linux/","excerpt":"","text":"本文转载自 CS-Note 项目 一、常用操作以及概念快捷键 Tab：命令和文件名补全； Ctrl+C：中断正在运行的程序； Ctrl+D：结束键盘输入（End Of File，EOF） 求助1. –help指令的基本用法与选项介绍。 2. manman 是 manual 的缩写，将指令的具体信息显示出来。 当执行man date时，有 DATE(1) 出现，其中的数字代表指令的类型，常用的数字及其类型如下： 代号 类型 1 用户在 shell 环境中可以操作的指令或者可执行文件 5 配置文件 8 系统管理员可以使用的管理指令 3. infoinfo 与 man 类似，但是 info 将文档分成一个个页面，每个页面可以进行跳转。 4. doc&#x2F;usr&#x2F;share&#x2F;doc 存放着软件的一整套说明文件。 关机1. who在关机前需要先使用 who 命令查看有没有其它用户在线。 2. sync为了加快对磁盘文件的读写速度，位于内存中的文件数据不会立即同步到磁盘上，因此关机之前需要先进行 sync 同步操作。 3. shutdown12345# shutdown [-krhc] 时间 [信息]-k ： 不会关机，只是发送警告信息，通知所有在线的用户-r ： 将系统的服务停掉后就重新启动-h ： 将系统的服务停掉后就立即关机-c ： 取消已经在进行的 shutdown 指令内容 PATH可以在环境变量 PATH 中声明可执行文件的路径，路径之间用 : 分隔。 1/usr/local/bin:/usr/bin:/usr/local/sbin:/usr/sbin:/home/dmtsai/.local/bin:/home/dmtsai/bin sudosudo 允许一般用户使用 root 可执行的命令，不过只有在 &#x2F;etc&#x2F;sudoers 配置文件中添加的用户才能使用该指令。 包管理工具RPM 和 DPKG 为最常见的两类软件包管理工具： RPM 全称为 Redhat Package Manager，最早由 Red Hat 公司制定实施，随后被 GNU 开源操作系统接受并成为很多 Linux 系统 (RHEL) 的既定软件标准。 与 RPM 进行竞争的是基于 Debian 操作系统 (Ubuntu) 的 DEB 软件包管理工具 DPKG，全称为 Debian Package，功能方面与 RPM 相似。 YUM 基于 RPM，具有依赖管理功能，并具有软件升级的功能。 发行版Linux 发行版是 Linux 内核及各种应用软件的集成版本。 基于的包管理工具 商业发行版 社区发行版 RPM Red Hat Fedora &#x2F; CentOS DPKG Ubuntu Debian VIM 三个模式 一般指令模式（Command mode）：VIM 的默认模式，可以用于移动游标查看内容； 编辑模式（Insert mode）：按下 “i” 等按键之后进入，可以对文本进行编辑； 指令列模式（Bottom-line mode）：按下 “:” 按键之后进入，用于保存退出等操作。 在指令列模式下，有以下命令用于离开或者保存文件。 命令 作用 :w 写入磁盘 :w! 当文件为只读时，强制写入磁盘。到底能不能写入，与用户对该文件的权限有关 :q 离开 :q! 强制离开不保存 :wq 写入磁盘后离开 :wq! 强制写入磁盘后离开 GNUGNU 计划，译为革奴计划，它的目标是创建一套完全自由的操作系统，称为 GNU，其内容软件完全以 GPL 方式发布。其中 GPL 全称为 GNU 通用公共许可协议，包含了以下内容： 以任何目的运行此程序的自由； 再复制的自由； 改进此程序，并公开发布改进的自由。 开源协议 Choose an open source license 如何选择开源许可证？ 二、磁盘磁盘接口1. IDEIDE（ATA）全称 Advanced Technology Attachment，接口速度最大为 133MB&#x2F;s，因为并口线的抗干扰性太差，且排线占用空间较大，不利电脑内部散热，已逐渐被 SATA 所取代。 2. SATASATA 全称 Serial ATA，也就是使用串口的 ATA 接口，抗干扰性强，且对数据线的长度要求比 ATA 低很多，支持热插拔等功能。SATA-II 的接口速度为 300MiB&#x2F;s，而新的 SATA-III 标准可达到 600MiB&#x2F;s 的传输速度。SATA 的数据线也比 ATA 的细得多，有利于机箱内的空气流通，整理线材也比较方便。 3. SCSISCSI 全称是 Small Computer System Interface（小型机系统接口），经历多代的发展，从早期的 SCSI-II 到目前的 Ultra320 SCSI 以及 Fiber-Channel（光纤通道），接口型式也多种多样。SCSI 硬盘广为工作站级个人电脑以及服务器所使用，因此会使用较为先进的技术，如碟片转速 15000rpm 的高转速，且传输时 CPU 占用率较低，但是单价也比相同容量的 ATA 及 SATA 硬盘更加昂贵。 4. SASSAS（Serial Attached SCSI）是新一代的 SCSI 技术，和 SATA 硬盘相同，都是采取序列式技术以获得更高的传输速度，可达到 6Gb&#x2F;s。此外也透过缩小连接线改善系统内部空间等。 磁盘的文件名Linux 中每个硬件都被当做一个文件，包括磁盘。磁盘以磁盘接口类型进行命名，常见磁盘的文件名如下： IDE 磁盘：&#x2F;dev&#x2F;hd[a-d] SATA&#x2F;SCSI&#x2F;SAS 磁盘：&#x2F;dev&#x2F;sd[a-p] 其中文件名后面的序号的确定与系统检测到磁盘的顺序有关，而与磁盘所插入的插槽位置无关。 三、分区分区表磁盘分区表主要有两种格式，一种是限制较多的 MBR 分区表，一种是较新且限制较少的 GPT 分区表。 1. MBRMBR 中，第一个扇区最重要，里面有主要开机记录（Master boot record, MBR）及分区表（partition table），其中主要开机记录占 446 bytes，分区表占 64 bytes。 分区表只有 64 bytes，最多只能存储 4 个分区，这 4 个分区为主分区（Primary）和扩展分区（Extended）。其中扩展分区只有一个，它使用其它扇区用记录额外的分区表，因此通过扩展分区可以分出更多分区，这些分区称为逻辑分区。 Linux 也把分区当成文件，分区文件的命名方式为：磁盘文件名 + 编号，例如 &#x2F;dev&#x2F;sda1。注意，逻辑分区的编号从 5 开始。 2. GPT不同的磁盘有不同的扇区大小，例如 512 bytes 和最新磁盘的 4 k。GPT 为了兼容所有磁盘，在定义扇区上使用逻辑区块地址（Logical Block Address, LBA），LBA 默认大小为 512 bytes。 GPT 第 1 个区块记录了主要开机记录（MBR），紧接着是 33 个区块记录分区信息，并把最后的 33 个区块用于对分区信息进行备份。这 33 个区块第一个为 GPT 表头纪录，这个部份纪录了分区表本身的位置与大小和备份分区的位置，同时放置了分区表的校验码 (CRC32)，操作系统可以根据这个校验码来判断 GPT 是否正确。若有错误，可以使用备份分区进行恢复。 GPT 没有扩展分区概念，都是主分区，每个 LAB 可以分 4 个分区，因此总共可以分 4 * 32 &#x3D; 128 个分区。 MBR 不支持 2.2 TB 以上的硬盘，GPT 则最多支持到 233 TB &#x3D; 8 ZB。 开机检测程序1. BIOSBIOS（Basic Input&#x2F;Output System，基本输入输出系统），它是一个固件（嵌入在硬件中的软件），BIOS 程序存放在断电后内容不会丢失的只读内存中。 BIOS 是开机的时候计算机执行的第一个程序，这个程序知道可以开机的磁盘，并读取磁盘第一个扇区的主要开机记录（MBR），由主要开机记录（MBR）执行其中的开机管理程序，这个开机管理程序会加载操作系统的核心文件。 主要开机记录（MBR）中的开机管理程序提供以下功能：选单、载入核心文件以及转交其它开机管理程序。转交这个功能可以用来实现了多重引导，只需要将另一个操作系统的开机管理程序安装在其它分区的启动扇区上，在启动开机管理程序时，就可以通过选单选择启动当前的操作系统或者转交给其它开机管理程序从而启动另一个操作系统。 下图中，第一扇区的主要开机记录（MBR）中的开机管理程序提供了两个选单：M1、M2，M1 指向了 Windows 操作系统，而 M2 指向其它分区的启动扇区，里面包含了另外一个开机管理程序，提供了一个指向 Linux 的选单。 安装多重引导，最好先安装 Windows 再安装 Linux。因为安装 Windows 时会覆盖掉主要开机记录（MBR），而 Linux 可以选择将开机管理程序安装在主要开机记录（MBR）或者其它分区的启动扇区，并且可以设置开机管理程序的选单。 2. UEFIBIOS 不可以读取 GPT 分区表，而 UEFI 可以。 四、文件系统分区与文件系统对分区进行格式化是为了在分区上建立文件系统。一个分区通常只能格式化为一个文件系统，但是磁盘阵列等技术可以将一个分区格式化为多个文件系统。 组成最主要的几个组成部分如下： inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号； block：记录文件的内容，文件太大时，会占用多个 block。 除此之外还包括： superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等； block bitmap：记录 block 是否被使用的位域。 文件读取对于 Ext2 文件系统，当要读取一个文件的内容时，先在 inode 中去查找文件内容所在的所有 block，然后把所有 block 的内容读出来。 而对于 FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。 磁盘碎片指一个文件内容所在的 block 过于分散。 block在 Ext2 文件系统中所支持的 block 大小有 1K，2K 及 4K 三种，不同的大小限制了单个文件和文件系统的最大大小。 大小 1KB 2KB 4KB 最大单一文件 16GB 256GB 2TB 最大文件系统 2TB 8TB 16TB 一个 block 只能被一个文件所使用，未使用的部分直接浪费了。因此如果需要存储大量的小文件，那么最好选用比较小的 block。 inodeinode 具体包含以下信息： 权限 (read&#x2F;write&#x2F;excute)； 拥有者与群组 (owner&#x2F;group)； 容量； 建立或状态改变的时间 (ctime)； 最近一次的读取时间 (atime)； 最近修改的时间 (mtime)； 定义文件特性的旗标 (flag)，如 SetUID…； 该文件真正内容的指向 (pointer)。 inode 具有以下特点： 每个 inode 大小均固定为 128 bytes (新的 ext4 与 xfs 可设定到 256 bytes)； 每个文件都仅会占用一个 inode。 inode 中记录了文件内容所在的 block 编号，但是每个 block 非常小，一个大文件随便都需要几十万的 block。而一个 inode 大小有限，无法直接引用这么多 block 编号。因此引入了间接、双间接、三间接引用。间接引用是指，让 inode 记录的引用 block 块记录引用信息。 目录建立一个目录时，会分配一个 inode 与至少一个 block。block 记录的内容是目录下所有文件的 inode 编号以及文件名。 可以看出文件的 inode 本身不记录文件名，文件名记录在目录中，因此新增文件、删除文件、更改文件名这些操作与目录的 w 权限有关。 日志如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。 ext3&#x2F;ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。 挂载挂载利用目录作为文件系统的进入点，也就是说，进入目录之后就可以读取文件系统的数据。 目录配置为了使不同 Linux 发行版本的目录结构保持一致性，Filesystem Hierarchy Standard (FHS) 规定了 Linux 的目录结构。最基础的三个目录如下： &#x2F; (root, 根目录) &#x2F;usr (unix software resource)：所有系统默认软件都会安装到这个目录； &#x2F;var (variable)：存放系统或程序运行过程中的数据文件。 五、文件文件属性用户分为三种：文件拥有者、群组以及其它人，对不同的用户有不同的文件权限。 使用 ls 查看一个文件时，会显示一个文件的信息，例如 drwxr-xr-x. 3 root root 17 May 6 00:14 .config，对这个信息的解释如下： drwxr-xr-x：文件类型以及权限，第 1 位为文件类型字段，后 9 位为文件权限字段 3：链接数 root：文件拥有者 root：所属群组 17：文件大小 May 6 00:14：文件最后被修改的时间 .config：文件名 常见的文件类型及其含义有： d：目录 -：文件 l：链接文件 9 位的文件权限字段中，每 3 个为一组，共 3 组，每一组分别代表对文件拥有者、所属群组以及其它人的文件权限。一组权限中的 3 位分别为 r、w、x 权限，表示可读、可写、可执行。 文件时间有以下三种： modification time (mtime)：文件的内容更新就会更新； status time (ctime)：文件的状态（权限、属性）更新就会更新； access time (atime)：读取文件时就会更新。 文件与目录的基本操作1. ls列出文件或者目录的信息，目录的信息就是其中包含的文件。 1234# ls [-aAdfFhilnrRSt] file|dir-a ：列出全部的文件-d ：仅列出目录本身-l ：以长数据串行列出，包含文件的属性与权限等等数据 2. cd更换当前目录。 1cd [相对路径或绝对路径] 3. mkdir创建目录。 123# mkdir [-mp] 目录名称-m ：配置目录权限-p ：递归创建目录 4. rmdir删除目录，目录必须为空。 12rmdir [-p] 目录名称-p ：递归删除目录 5. touch更新文件时间或者建立新文件。 123456# touch [-acdmt] filename-a ： 更新 atime-c ： 更新 ctime，若该文件不存在则不建立新文件-m ： 更新 mtime-d ： 后面可以接更新日期而不使用当前日期，也可以使用 --date=&quot;日期或时间&quot;-t ： 后面可以接更新时间而不使用当前时间，格式为[YYYYMMDDhhmm] 6. cp复制文件。 如果源文件有两个以上，则目的文件一定要是目录才行。 12345678cp [-adfilprsu] source destination-a ：相当于 -dr --preserve=all 的意思，至于 dr 请参考下列说明-d ：若来源文件为链接文件，则复制链接文件属性而非文件本身-i ：若目标文件已经存在时，在覆盖前会先询问-p ：连同文件的属性一起复制过去-r ：递归持续复制-u ：destination 比 source 旧才更新 destination，或 destination 不存在的情况下才复制--preserve=all ：除了 -p 的权限相关参数外，还加入 SELinux 的属性, links, xattr 等也复制了 7. rm删除文件。 12# rm [-fir] 文件或目录-r ：递归删除 8. mv移动文件。 123# mv [-fiu] source destination# mv [options] source1 source2 source3 .... directory-f ： force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖 修改权限可以将一组权限用数字来表示，此时一组权限的 3 个位当做二进制数字的位，从左到右每个位的权值为 4、2、1，即每个权限对应的数字权值为 r : 4、w : 2、x : 1。 1# chmod [-R] xyz dirname/filename 示例：将 .bashrc 文件的权限修改为 -rwxr-xr–。 1# chmod 754 .bashrc 也可以使用符号来设定权限。 12345678# chmod [ugoa] [+-=] [rwx] dirname/filename- u：拥有者- g：所属群组- o：其他人- a：所有人- +：添加权限- -：移除权限- =：设定权限 示例：为 .bashrc 文件的所有用户添加写权限。 1# chmod a+w .bashrc 文件默认权限 文件默认权限：文件默认没有可执行权限，因此为 666，也就是 -rw-rw-rw- 。 目录默认权限：目录必须要能够进入，也就是必须拥有可执行权限，因此为 777 ，也就是 drwxrwxrwx。 可以通过 umask 设置或者查看文件的默认权限，通常以掩码的形式来表示，例如 002 表示其它用户的权限去除了一个 2 的权限，也就是写权限，因此建立新文件时默认的权限为 -rw-rw-r–。 目录的权限文件名不是存储在一个文件的内容中，而是存储在一个文件所在的目录中。因此，拥有文件的 w 权限并不能对文件名进行修改。 目录存储文件列表，一个目录的权限也就是对其文件列表的权限。因此，目录的 r 权限表示可以读取文件列表；w 权限表示可以修改文件列表，具体来说，就是添加删除文件，对文件名进行修改；x 权限可以让该目录成为工作目录，x 权限是 r 和 w 权限的基础，如果不能使一个目录成为工作目录，也就没办法读取文件列表以及对文件列表进行修改了。 链接123# ln [-sf] source_filename dist_filename-s ：默认是 hard link，加 -s 为 symbolic link-f ：如果目标文件存在时，先删除目标文件 1. 实体链接在目录下创建一个条目，记录着文件名与 inode 编号，这个 inode 就是源文件的 inode。 删除任意一个条目，文件还是存在，只要引用数量不为 0。 有以下限制：不能跨越文件系统、不能对目录进行链接。 1234# ln /etc/crontab .# ll -i /etc/crontab crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 crontab34474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab 2. 符号链接符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 Windows 的快捷方式。 当源文件被删除了，链接文件就打不开了。 可以为目录建立链接。 123# ll -i /etc/crontab /root/crontab234474855 -rw-r--r--. 2 root root 451 Jun 10 2014 /etc/crontab53745909 lrwxrwxrwx. 1 root root 12 Jun 23 22:31 /root/crontab2 -&gt; /etc/crontab 获取文件内容1. cat取得文件内容。 12# cat [-AbEnTv] filename-n ：打印出行号，连同空白行也会有行号，-b 不会 2. tac是 cat 的反向操作，从最后一行开始打印。 3. more和 cat 不同的是它可以一页一页查看文件内容，比较适合大文件的查看。 4. less和 more 类似，但是多了一个向前翻页的功能。 5. head取得文件前几行。 12# head [-n number] filename-n ：后面接数字，代表显示几行的意思 6. tail是 head 的反向操作，只是取得是后几行。 7. od以字符或者十六进制的形式显示二进制文件。 指令与文件搜索1. which指令搜索。 12# which [-a] command-a ：将所有指令列出，而不是只列第一个 2. whereis文件搜索。速度比较快，因为它只搜索几个特定的目录。 1# whereis [-bmsu] dirname/filename 3. locate文件搜索。可以用关键字或者正则表达式进行搜索。 locate 使用 &#x2F;var&#x2F;lib&#x2F;mlocate&#x2F; 这个数据库来进行搜索，它存储在内存中，并且每天更新一次，所以无法用 locate 搜索新建的文件。可以使用 updatedb 来立即更新数据库。 12# locate [-ir] keyword-r：正则表达式 4. find文件搜索。可以使用文件的属性和权限进行搜索。 12# find [basedir] [option]example: find . -name &quot;shadow*&quot; （一）与时间有关的选项 1234-mtime n ：列出在 n 天前的那一天修改过内容的文件-mtime +n ：列出在 n 天之前 (不含 n 天本身) 修改过内容的文件-mtime -n ：列出在 n 天之内 (含 n 天本身) 修改过内容的文件-newer file ： 列出比 file 更新的文件 +4、4 和 -4 的指示的时间范围如下： （二）与文件拥有者和所属群组有关的选项 123456-uid n-gid n-user name-group name-nouser ：搜索拥有者不存在 /etc/passwd 的文件-nogroup：搜索所属群组不存在于 /etc/group 的文件 （三）与文件权限和名称有关的选项 123456-name filename-size [+-]SIZE：搜寻比 SIZE 还要大 (+) 或小 (-) 的文件。这个 SIZE 的规格有：c: 代表 byte，k: 代表 1024bytes。所以，要找比 50KB 还要大的文件，就是 -size +50k-type TYPE-perm mode ：搜索权限等于 mode 的文件-perm -mode ：搜索权限包含 mode 的文件-perm /mode ：搜索权限包含任一 mode 的文件 六、压缩与打包压缩文件名Linux 底下有很多压缩文件名，常见的如下： 扩展名 压缩程序 *.Z compress *.zip zip *.gz gzip *.bz2 bzip2 *.xz xz *.tar tar 程序打包的数据，没有经过压缩 *.tar.gz tar 程序打包的文件，经过 gzip 的压缩 *.tar.bz2 tar 程序打包的文件，经过 bzip2 的压缩 *.tar.xz tar 程序打包的文件，经过 xz 的压缩 压缩指令1. gzipgzip 是 Linux 使用最广的压缩指令，可以解开 compress、zip 与 gzip 所压缩的文件。 经过 gzip 压缩过，源文件就不存在了。 有 9 个不同的压缩等级可以使用。 可以使用 zcat、zmore、zless 来读取压缩文件的内容。 123456$ gzip [-cdtv#] filename-c ：将压缩的数据输出到屏幕上-d ：解压缩-t ：检验压缩文件是否出错-v ：显示压缩比等信息-# ： # 为数字的意思，代表压缩等级，数字越大压缩比越高，默认为 6 2. bzip2提供比 gzip 更高的压缩比。 查看命令：bzcat、bzmore、bzless、bzgrep。 12$ bzip2 [-cdkzv#] filename-k ：保留源文件 3. xz提供比 bzip2 更佳的压缩比。 可以看到，gzip、bzip2、xz 的压缩比不断优化。不过要注意的是，压缩比越高，压缩的时间也越长。 查看命令：xzcat、xzmore、xzless、xzgrep。 1$ xz [-dtlkc#] filename 打包压缩指令只能对一个文件进行压缩，而打包能够将多个文件打包成一个大文件。tar 不仅可以用于打包，也可以使用 gip、bzip2、xz 将打包文件进行压缩。 123456789101112$ tar [-z|-j|-J] [cv] [-f 新建的 tar 文件] filename... ==打包压缩$ tar [-z|-j|-J] [tv] [-f 已有的 tar 文件] ==查看$ tar [-z|-j|-J] [xv] [-f 已有的 tar 文件] [-C 目录] ==解压缩-z ：使用 zip；-j ：使用 bzip2；-J ：使用 xz；-c ：新建打包文件；-t ：查看打包文件里面有哪些文件；-x ：解打包或解压缩的功能；-v ：在压缩/解压缩的过程中，显示正在处理的文件名；-f : filename：要处理的文件；-C 目录 ： 在特定目录解压缩。 使用方式 命令 打包压缩 tar -jcv -f filename.tar.bz2 要被压缩的文件或目录名称 查 看 tar -jtv -f filename.tar.bz2 解压缩 tar -jxv -f filename.tar.bz2 -C 要解压缩的目录 七、Bash可以通过 Shell 请求内核提供服务，Bash 正是 Shell 的一种。 特性 命令历史：记录使用过的命令 命令与文件补全：快捷键：tab 命名别名：例如 lm 是 ls -al 的别名 shell scripts 通配符：例如 ls -l &#x2F;usr&#x2F;bin&#x2F;X* 列出 &#x2F;usr&#x2F;bin 下面所有以 X 开头的文件 变量操作对一个变量赋值直接使用 &#x3D;。 对变量取用需要在变量前加上 $ ，也可以用 ${} 的形式； 输出变量使用 echo 命令。 123$ x=abc$ echo $x$ echo $&#123;x&#125; 变量内容如果有空格，必须使用双引号或者单引号。 双引号内的特殊字符可以保留原本特性，例如 x&#x3D;”lang is $LANG”，则 x 的值为 lang is zh_TW.UTF-8； 单引号内的特殊字符就是特殊字符本身，例如 x&#x3D;’lang is $LANG’，则 x 的值为 lang is $LANG。 可以使用 `指令` 或者 $(指令) 的方式将指令的执行结果赋值给变量。例如 version&#x3D;$(uname -r)，则 version 的值为 4.15.0-22-generic。 可以使用 export 命令将自定义变量转成环境变量，环境变量可以在子程序中使用，所谓子程序就是由当前 Bash 而产生的子 Bash。 Bash 的变量可以声明为数组和整数数字。注意数字类型没有浮点数。如果不进行声明，默认是字符串类型。变量的声明使用 declare 命令： 12345$ declare [-aixr] variable-a ： 定义为数组类型-i ： 定义为整数类型-x ： 定义为环境变量-r ： 定义为 readonly 类型 使用 [ ] 来对数组进行索引操作： 123$ array[1]=a$ array[2]=b$ echo $&#123;array[1]&#125; 指令搜索顺序 以绝对或相对路径来执行指令，例如 &#x2F;bin&#x2F;ls 或者 .&#x2F;ls ； 由别名找到该指令来执行； 由 Bash 内建的指令来执行； 按 $PATH 变量指定的搜索路径的顺序找到第一个指令来执行。 数据流重定向重定向指的是使用文件代替标准输入、标准输出和标准错误输出。 1 代码 运算符 标准输入 (stdin) 0 &lt; 或 &lt;&lt; 标准输出 (stdout) 1 &gt; 或 &gt;&gt; 标准错误输出 (stderr) 2 2&gt; 或 2&gt;&gt; 其中，有一个箭头的表示以覆盖的方式重定向，而有两个箭头的表示以追加的方式重定向。 可以将不需要的标准输出以及标准错误输出重定向到 &#x2F;dev&#x2F;null，相当于扔进垃圾箱。 如果需要将标准输出以及标准错误输出同时重定向到一个文件，需要将某个输出转换为另一个输出，例如 2&gt;&amp;1 表示将标准错误输出转换为标准输出。 1$ find /home -name .bashrc &gt; list 2&gt;&amp;1 八、管线指令管线是将一个命令的标准输出作为另一个命令的标准输入，在数据需要经过多个步骤的处理之后才能得到我们想要的内容时就可以使用管线。 在命令之间使用 | 分隔各个管线命令。 1$ ls -al /etc | less 提取指令cut 对数据进行切分，取出想要的部分。 切分过程一行一行地进行。 1234$ cut-d ：分隔符-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间-c ：以字符为单位取出区间 示例 1：last 显示登入者的信息，取出用户名。 123456$ lastroot pts/1 192.168.201.101 Sat Feb 7 12:35 still logged inroot pts/1 192.168.201.101 Fri Feb 6 12:13 - 18:46 (06:33)root pts/1 192.168.201.254 Thu Feb 5 22:37 - 23:53 (01:16)$ last | cut -d &#x27; &#x27; -f 1 示例 2：将 export 输出的信息，取出第 12 字符以后的所有字符串。 12345678$ exportdeclare -x HISTCONTROL=&quot;ignoredups&quot;declare -x HISTSIZE=&quot;1000&quot;declare -x HOME=&quot;/home/dmtsai&quot;declare -x HOSTNAME=&quot;study.centos.vbird&quot;.....(其他省略).....$ export | cut -c 12- 排序指令sort 用于排序。 123456789$ sort [-fbMnrtuk] [file or stdin]-f ：忽略大小写-b ：忽略最前面的空格-M ：以月份的名字来排序，例如 JAN，DEC-n ：使用数字-r ：反向排序-u ：相当于 unique，重复的内容只出现一次-t ：分隔符，默认为 tab-k ：指定排序的区间 示例：&#x2F;etc&#x2F;passwd 文件内容以 : 来分隔，要求以第三列进行排序。 12345$ cat /etc/passwd | sort -t &#x27;:&#x27; -k 3root:x:0:0:root:/root:/bin/bashdmtsai:x:1000:1000:dmtsai:/home/dmtsai:/bin/bashalex:x:1001:1002::/home/alex:/bin/basharod:x:1002:1003::/home/arod:/bin/bash uniq 可以将重复的数据只取一个。 123$ uniq [-ic]-i ：忽略大小写-c ：进行计数 示例：取得每个人的登录总次数 1234567$ last | cut -d &#x27; &#x27; -f 1 | sort | uniq -c16 (unknown47 dmtsai4 reboot7 root1 wtmp 双向输出重定向输出重定向会将输出内容重定向到文件中，而 tee 不仅能够完成这个功能，还能保留屏幕上的输出。也就是说，使用 tee 指令，一个输出会同时传送到文件和屏幕上。 1$ tee [-a] file 字符转换指令tr 用来删除一行中的字符，或者对字符进行替换。 12$ tr [-ds] SET1 ...-d ： 删除行中 SET1 这个字符串 示例，将 last 输出的信息所有小写转换为大写。 1$ last | tr &#x27;[a-z]&#x27; &#x27;[A-Z]&#x27; col 将 tab 字符转为空格字符。 12$ col [-xb]-x ： 将 tab 键转换成对等的空格键 expand 将 tab 转换一定数量的空格，默认是 8 个。 12$ expand [-t] file-t ：tab 转为空格的数量 join 将有相同数据的那一行合并在一起。 12345$ join [-ti12] file1 file2-t ：分隔符，默认为空格-i ：忽略大小写的差异-1 ：第一个文件所用的比较字段-2 ：第二个文件所用的比较字段 paste 直接将两行粘贴在一起。 12$ paste [-d] file1 file2-d ：分隔符，默认为 tab 分区指令split 将一个文件划分成多个文件。 1234$ split [-bl] file PREFIX-b ：以大小来进行分区，可加单位，例如 b, k, m 等-l ：以行数来进行分区。- PREFIX ：分区文件的前导名称 九、正则表达式grepg&#x2F;re&#x2F;p（globally search a regular expression and print)，使用正则表示式进行全局查找并打印。 123456$ grep [-acinv] [--color=auto] 搜寻字符串 filename-c ： 统计个数-i ： 忽略大小写-n ： 输出行号-v ： 反向选择，也就是显示出没有 搜寻字符串 内容的那一行--color=auto ：找到的关键字加颜色显示 示例：把含有 the 字符串的行提取出来（注意默认会有 –color&#x3D;auto 选项，因此以下内容在 Linux 中有颜色显示 the 字符串） 123456$ grep -n &#x27;the&#x27; regular_express.txt8:I can&#x27;t finish the test.12:the symbol &#x27;*&#x27; is represented as start.15:You are the best is mean you are the no. 1.16:The world Happy is the same with &quot;glad&quot;.18:google is the best tools for search keyword 因为 { 和 } 在 shell 是有特殊意义的，因此必须要使用转义字符进行转义。 1$ grep -n &#x27;go\\&#123;2,5\\&#125;g&#x27; regular_express.txt printf用于格式化输出。 它不属于管道命令，在给 printf 传数据时需要使用 $( ) 形式。 1234$ printf &#x27;%10s %5i %5i %5i %8.2f \\n&#x27; $(cat printf.txt) DmTsai 80 60 92 77.33 VBird 75 55 80 70.00 Ken 60 90 70 73.33 awk是由 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 创造，awk 这个名字就是这三个创始人名字的首字母。 awk 每次处理一行，处理的最小单位是字段，每个字段的命名方式为：$n，n 为字段号，从 1 开始，$0 表示一整行。 示例：取出登录用户的用户名和 IP 123456$ last -n 5dmtsai pts/0 192.168.1.100 Tue Jul 14 17:32 still logged indmtsai pts/0 192.168.1.100 Thu Jul 9 23:36 - 02:58 (03:22)dmtsai pts/0 192.168.1.100 Thu Jul 9 17:23 - 23:36 (06:12)dmtsai pts/0 192.168.1.100 Thu Jul 9 08:02 - 08:17 (00:14)dmtsai tty1 Fri May 29 11:55 - 12:11 (00:15) 1$ last -n 5 | awk &#x27;&#123;print $1 &quot;\\t&quot; $3&#125;&#x27; 可以根据字段的某些条件进行匹配，例如匹配字段小于某个值的那一行数据。 1$ awk &#x27;条件类型 1 &#123;动作 1&#125; 条件类型 2 &#123;动作 2&#125; ...&#x27; filename 示例：&#x2F;etc&#x2F;passwd 文件第三个字段为 UID，对 UID 小于 10 的数据进行处理。 1234$ cat /etc/passwd | awk &#x27;BEGIN &#123;FS=&quot;:&quot;&#125; $3 &lt; 10 &#123;print $1 &quot;\\t &quot; $3&#125;&#x27;root 0bin 1daemon 2 awk 变量： 变量名称 代表意义 NF 每一行拥有的字段总数 NR 目前所处理的是第几行数据 FS 目前的分隔字符，默认是空格键 示例：显示正在处理的行号以及每一行有多少字段 123456$ last -n 5 | awk &#x27;&#123;print $1 &quot;\\t lines: &quot; NR &quot;\\t columns: &quot; NF&#125;&#x27;dmtsai lines: 1 columns: 10dmtsai lines: 2 columns: 10dmtsai lines: 3 columns: 10dmtsai lines: 4 columns: 10dmtsai lines: 5 columns: 9 十、进程管理查看进程1. ps查看某个时间点的进程信息 示例一：查看自己的进程 1# ps -l 示例二：查看系统所有进程 1# ps aux 示例三：查看特定的进程 1# ps aux | grep threadx 2. top实时显示进程信息 示例：两秒钟刷新一次 1# top -d 2 3. pstree查看进程树 示例：查看所有进程树 1# pstree -A 4. netstat查看占用端口的进程 示例：查看特定端口的进程 1# netstat -anp | grep port 进程状态 状态 说明 R running or runnable (on run queue) D uninterruptible sleep (usually I&#x2F;O) S interruptible sleep (waiting for an event to complete) Z zombie (terminated but not reaped by its parent) T stopped (either by a job control signal or because it is being traced) SIGCHLD当一个子进程改变了它的状态时（停止运行，继续运行或者退出），有两件事会发生在父进程中： 得到 SIGCHLD 信号； waitpid() 或者 wait() 调用会返回。 其中子进程发送的 SIGCHLD 信号包含了子进程的信息，包含了进程 ID、进程状态、进程使用 CPU 的时间等。 在子进程退出时，它的进程描述符不会立即释放，这是为了让父进程得到子进程信息，父进程通过 wait() 和 waitpid() 来获得一个已经退出的子进程的信息。 wait()1pid_t wait(int *status) 父进程调用 wait() 会一直阻塞，直到收到一个子进程退出的 SIGCHLD 信号，之后 wait() 函数会销毁子进程并返回。 如果成功，返回被收集的子进程的进程 ID；如果调用进程没有子进程，调用就会失败，此时返回 -1，同时 errno 被置为 ECHILD。 参数 status 用来保存被收集的子进程退出时的一些状态，如果对这个子进程是如何死掉的毫不在意，只想把这个子进程消灭掉，可以设置这个参数为 NULL。 waitpid()1pid_t waitpid(pid_t pid, int *status, int options) 作用和 wait() 完全相同，但是多了两个可由用户控制的参数 pid 和 options。 pid 参数指示一个子进程的 ID，表示只关心这个子进程退出的 SIGCHLD 信号。如果 pid&#x3D;-1 时，那么和 wait() 作用相同，都是关心所有子进程退出的 SIGCHLD 信号。 options 参数主要有 WNOHANG 和 WUNTRACED 两个选项，WNOHANG 可以使 waitpid() 调用变成非阻塞的，也就是说它会立即返回，父进程可以继续执行其它任务。 孤儿进程一个父进程退出，而它的一个或多个子进程还在运行，那么这些子进程将成为孤儿进程。 孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。 由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。 僵尸进程一个子进程的进程描述符在子进程退出时不会释放，只有当父进程通过 wait() 或 waitpid() 获取了子进程信息后才会释放。如果子进程退出，而父进程并没有调用 wait() 或 waitpid()，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。 僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。 系统所能使用的进程号是有限的，如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。 要消灭系统中大量的僵尸进程，只需要将其父进程杀死，此时僵尸进程就会变成孤儿进程，从而被 init 所收养，这样 init 就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。 参考资料 鸟哥. 鸟 哥 的 Linux 私 房 菜 基 础 篇 第 三 版[J]. 2009. Linux 平台上的软件包管理 Linux 之守护进程、僵死进程与孤儿进程 What is the difference between a symbolic link and a hard link? Linux process states GUID Partition Table 详解 wait 和 waitpid 函数 IDE、SATA、SCSI、SAS、FC、SSD 硬盘类型介绍 Akai IB-301S SCSI Interface for S2800,S3000 Parallel ATA ADATA XPG SX900 256GB SATA 3 SSD Review – Expanded Capacity and SandForce Driven Speed Decoding UCS Invicta – Part 1 硬盘 Difference between SAS and SATA BIOS File system design case studies Programming Project #4 FILE SYSTEM DESIGN","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"https://blog.jugg.xyz/tags/Linux/"},{"name":"Shell","slug":"Shell","permalink":"https://blog.jugg.xyz/tags/Shell/"}]},{"title":"提问的智慧","slug":"repost/How-To-Ask-Questions-The-Smart-Way","date":"2018-04-03T03:23:04.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2018/04/03/repost/How-To-Ask-Questions-The-Smart-Way/","permalink":"https://blog.jugg.xyz/2018/04/03/repost/How-To-Ask-Questions-The-Smart-Way/","excerpt":"","text":"#提问的智慧 How To Ask Questions The Smart Way Copyright © 2001,2006,2014 Eric S. Raymond, Rick Moen 本指南英文版版权为 Eric S. Raymond, Rick Moen 所有。 原文网址:http://www.catb.org/~esr&#x2F;faqs&#x2F;smart-questions.html Copyleft 2001 by D.H.Grand(nOBODY&#x2F;Ginux), 2010 by Gasolin, 2015 by Ryan Wu 本中文指南是基于原文 3.10 版以及 2010 年由 Gasolin 所翻译版本的最新翻译； 协助指出翻译问题，请发Issue，或直接发Pull Request给我。 本文另有繁体中文版: https://github.com/ryanhanwu/How-To-Ask-Questions-The-Smart-Way 原文版本历史声明许多项目在他们的使用协助&#x2F;说明网页中链接了本指南，这么做很好，我们也鼓励大家都这么做。但如果你是负责管理这个项目网页的人，请在超链接附近的显着位置上注明： 本指南不提供此项目的实际支持服务！ 我们已经深刻领教到少了上述声明所带来的痛苦。因为少了这点声明，我们不停地被一些白痴纠缠。这些白痴认为既然我们发布了这本指南，那么我们就有责任解决世上所有的技术问题。 如果你是因为需要某些协助而正在阅读这本指南，并且最后离开是因为发现从本指南作者们身上得不到直接的协助，那么你就是我们所说的那些白痴之一。别问我们问题，我们只会忽略你。我们在这本指南中是教你如何从那些真正懂得你所遇到软件或硬件问题的人取得协助，而99%的情况下那不会是我们。除非你确定本指南的作者之一刚好是你所遇到的问题领域的专家，否则请不要打扰我们，这样大家都会开心一点。 简介在黑客的世界里，当你拋出一个技术问题时，最终是否能得到有用的回答，往往取决于你所提问和追问的方式。本指南将教你如何正确的提问以获得你满意的答案。 不只是黑客，现在开放源代码（Open Source）软件已经相当盛行，你常常也可以由其他有经验的使用者身上得到好答案，这是件**好事**；使用者比起黑客来，往往对那些新手常遇到的问题更宽容一些。然而，将有经验的使用者视为黑客，并采用本指南所提的方法与他们沟通，同样也是能从他们身上得到满意回答的最有效方式。 首先你应该明白，黑客们喜爱有挑战性的问题，或者能激发我们思维的好问题。如果我们并非如此，那我们也不会成为你想询问的对象。如果你给了我们一个值得反复咀嚼玩味的好问题，我们自会对你感激不尽。好问题是激励，是厚礼。好问题可以提高我们的理解力，而且通常会暴露我们以前从没意识到或者思考过的问题。对黑客而言，”好问题！”是诚挚的大力称赞。 尽管如此，黑客们有着蔑视或傲慢面对简单问题的坏名声，这有时让我们看起来对新手、无知者似乎较有敌意，但其实不是那样的。 我们不讳言我们对那些不愿思考、或者在发问前不做他们该做的事的人的蔑视。那些人是时间杀手 -– 他们只想索取，从不付出，消耗我们可用在更有趣的问题或更值得回答的人身上的时间。我们称这样的人为 失败者（撸瑟） （由于历史原因，我们有时把它拼作 lusers）。 我们意识到许多人只是想使用我们写的软件，他们对学习技术细节没有兴趣。对大多数人而言，电脑只是种工具，是种达到目的的手段而已。他们有自己的生活并且有更要紧的事要做。我们了解这点，也从不指望每个人都对这些让我们着迷的技术问题感兴趣。尽管如此，我们回答问题的风格是指向那些真正对此有兴趣并愿意主动参与解决问题的人，这一点不会变，也不该变。如果连这都变了，我们就是在降低做自己最擅长的事情上的效率。 我们（在很大程度上）是自愿的，从繁忙的生活中抽出时间来解答疑惑，而且时常被提问淹没。所以我们无情的滤掉一些话题，特别是拋弃那些看起来像失败者的家伙，以便更高效的利用时间来回答赢家（winner）的问题。 如果你厌恶我们的态度，高高在上，或过于傲慢，不妨也设身处地想想。我们并没有要求你向我们屈服 – 事实上，我们大多数人非常乐意与你平等地交流，只要你付出小小努力来满足基本要求，我们就会欢迎你加入我们的文化。但让我们帮助那些不愿意帮助自己的人是没有效率的。无知没有关系，但装白痴就是不行。 所以，你不必在技术上很在行才能吸引我们的注意，但你必须表现出能引导你变得在行的特质 – 机敏、有想法、善于观察、乐于主动参与解决问题。如果你做不到这些使你与众不同的事情，我们建议你花点钱找家商业公司签个技术支持服务合同，而不是要求黑客个人无偿地帮助你。 如果你决定向我们求助，当然你也不希望被视为失败者，更不愿成为失败者中的一员。能立刻得到快速并有效答案的最好方法，就是像赢家那样提问 – 聪明、自信、有解决问题的思路，只是偶尔在特定的问题上需要获得一点帮助。 （欢迎对本指南提出改进意见。你可以 email 你的建议至 esr@thyrsus.com 或 respond-auto@linuxmafia.com。然而请注意，本文并非网络礼节的通用指南，而我们通常会拒绝无助于在技术论坛得到有用答案的建议。） 在提问之前在你准备要通过电子邮件、新闻群组或者聊天室提出技术问题前，请先做到以下事情： 尝试在你准备提问的论坛的旧文章中搜索答案。 尝试上网搜索以找到答案。 尝试阅读手册以找到答案。 尝试阅读常见问题文件（FAQ）以找到答案。 尝试自己检查或试验以找到答案 向你身边的强者朋友打听以找到答案。 如果你是程序开发者，请尝试阅读源代码以找到答案 当你提出问题的时候，请先表明你已经做了上述的努力；这将有助于树立你并不是一个不劳而获且浪费别人的时间的提问者。如果你能一并表达在做了上述努力的过程中所**学到**的东西会更好，因为我们更乐于回答那些表现出能从答案中学习的人的问题。 运用某些策略，比如先用Google搜索你所遇到的各种错误信息（既搜索Google论坛，也搜索网页），这样很可能直接就找到了能解决问题的文件或邮件列表线索。即使没有结果，在邮件列表或新闻组寻求帮助时加上一句 我在Google中搜过下列句子但没有找到什么有用的东西 也是件好事，即使它只是表明了搜索引擎不能提供哪些帮助。这么做（加上搜索过的字串）也让遇到相似问题的其他人能被搜索引擎引导到你的提问来。 别着急，不要指望几秒钟的Google搜索就能解决一个复杂的问题。在向专家求助之前，再阅读一下常见问题文件（FAQ）、放轻松、坐舒服一些，再花点时间思考一下这个问题。相信我们，他们能从你的提问看出你做了多少阅读与思考，如果你是有备而来，将更有可能得到解答。不要将所有问题一股脑拋出，只因你的第一次搜索没有找到答案（或者找到太多答案）。 准备好你的问题，再将问题仔细的思考过一遍，因为草率的发问只能得到草率的回答，或者根本得不到任何答案。越是能表现出在寻求帮助前你为解决问题所付出的努力，你越有可能得到实质性的帮助。 小心别问错了问题。如果你的问题基于错误的假设，某个普通黑客（J. Random Hacker）多半会一边在心里想着蠢问题…， 一边用无意义的字面解释来答复你，希望着你会从问题的回答（而非你想得到的答案）中汲取教训。 绝不要自以为**够格得到答案，你没有；你并没有。毕竟你没有为这种服务支付任何报酬。你将会是自己去挣到**一个答案，靠提出有内涵的、有趣的、有思维激励作用的问题 –一个有潜力能贡献社区经验的问题，而不仅仅是被动的从他人处索取知识。 另一方面，表明你愿意在找答案的过程中做点什么是一个非常好的开端。谁能给点提示？、我的这个例子里缺了什么？以及我应该检查什么地方比请把我需要的确切的过程贴出来更容易得到答复。因为你表现出只要有人能指个正确方向，你就有完成它的能力和决心。 当你提问时慎选提问的论坛小心选择你要提问的场合。如果你做了下述的事情，你很可能被忽略掉或者被看作失败者： 在与主题不合的论坛上贴出你的问题 在探讨进阶技术问题的论坛张贴非常初级的问题；反之亦然 在太多的不同新闻群组上重复转贴同样的问题（cross-post） 向既非熟人也没有义务解决你问题的人发送私人电邮 黑客会剔除掉那些搞错场合的问题，以保护他们沟通的渠道不被无关的东西淹没。你不会想让这种事发生在自己身上的。 因此，第一步是找到对的论坛。再说一次，Google和其它搜索引擎还是你的朋友，用它们来找到与你遭遇到困难的软硬件问题最相关的网站。通常那儿都有常见问题（FAQ）、邮件列表及相关说明文件的链接。如果你的努力（包括**阅读**FAQ）都没有结果，网站上也许还有报告Bug（Bug-reporting）的流程或链接，如果是这样，连过去看看。 向陌生的人或论坛发送邮件最可能是风险最大的事情。举例来说，别假设一个提供丰富内容的网页的作者会想充当你的免费顾问。不要对你的问题是否会受到欢迎做太乐观的估计 – 如果你不确定，那就向别处发送，或者压根别发。 在选择论坛、新闻群组或邮件列表时，别太相信名字，先看看FAQ或者许可书以弄清楚你的问题是否切题。发文前先翻翻已有的话题，这样可以让你感受一下那里的文化。事实上，事先在新闻组或邮件列表的历史记录中搜索与你问题相关的关键词是个极好的主意，也许这样就找到答案了。即使没有，也能帮助你归纳出更好的问题。 别像机关枪似的一次”扫射”所有的帮助渠道，这就像大喊大叫一样会使人不快。要一个一个地来。 搞清楚你的主题！最典型的错误之一是在某种致力于跨平台可移植的语言、套件或工具的论坛中提关于Unix或Windows操作系统程序界面的问题。如果你不明白为什么这是大错，最好在搞清楚这之间差异之前什么也别问。 一般来说，在仔细挑选的公共论坛中提问，会比在私有论坛中提同样的问题更容易得到有用的回答。有几个理由可以支持这点，一是看潜在的回复者有多少，二是看观众有多少。黑客较愿意回答那些能帮助到许多人的问题。 可以理解的是，老练的黑客和一些热门软件的作者正在接受过多的错发信息。就像那根最后压垮骆驼背的稻草一样，你的加入也有可能使情况走向极端 – 已经好几次了，一些热门软件的作者从自己软件的支持中抽身出来，因为伴随而来涌入其私人邮箱的无用邮件变得无法忍受。 Stack Overflow搜索，**然后** 在 Stack Exchange 问。 近年来，Stack Exchange community 社区已经成为回答技术及其他问题的主要渠道，尤其是那些开放源码的项目。 因为 Google 索引是即时的，在看 Stack Exchange 之前先在 Google 搜索。有很高的机率某人已经问了一个类似的问题，而且 Stack Exchange 网站们往往会是搜索结果中最前面几个。如果你在 Google 上没有找到任何答案，你再到特定相关主题的网站去找。用标签（Tag）搜索能让你更缩小你的搜索结果。 Stack Exchange 已经成长到超过一百个网站，以下是最常用的几个站： Super User 是问一些通用的电脑问题，如果你的问题跟代码或是写程序无关，只是一些网络连线之类的，请到这里。 Stack Overflow 是问写程序有关的问题。 Server Fault 是问服务器和网管相关的问题。 网站和IRC论坛本地的使用者群组（user group），或者你所用的 Linux 发行版本也许正在宣传他们的网页论坛或 IRC 频道，并提供新手帮助（在一些非英语国家，新手论坛很可能还是邮件列表）， 这些地方是开始提问的好首选，特别是当你觉得遇到的也许只是相对简单或者很普通的问题时。经过宣传的 IRC 频道是公开欢迎提问的地方，通常可以即时得到回应。 事实上，如果程序出的问题只发生在特定 Linux 发行版提供的版本（这很常见），最好先去该发行版的论坛或邮件列表中提问，再到程序本身的论坛或邮件列表提问。（否则）该项目的黑客可能仅仅回复 “用**我们的**版本”。 在任何论坛发文以前，先确认一下有没有搜索功能。如果有，就试着搜索一下问题的几个关键词，也许这会有帮助。如果在此之前你已做过通用的网页搜索（你也该这样做），还是再搜索一下论坛，搜索引擎有可能没来得及索引此论坛的全部内容。 通过论坛或 IRC 频道来提供使用者支持服务有增长的趋势，电子邮件则大多为项目开发者间的交流而保留。所以最好先在论坛或 IRC 中寻求与该项目相关的协助。 第二步，使用项目邮件列表当某个项目提供开发者邮件列表时，要向列表而不是其中的个别成员提问，即使你确信他能最好地回答你的问题。查一查项目的文件和首页，找到项目的邮件列表并使用它。有几个很好的理由支持我们采用这种办法： 任何好到需要向个别开发者提出的问题，也将对整个项目群组有益。反之，如果你认为自己的问题对整个项目群组来说太愚蠢，也不能成为骚扰个别开发者的理由。 向列表提问可以分散开发者的负担，个别开发者（尤其是项目领导人）也许太忙以至于没法回答你的问题。 大多数邮件列表都会被存档，那些被存档的内容将被搜索引擎索引。如果你向列表提问并得到解答，将来其它人可以通过网页搜索找到你的问题和答案，也就不用再次发问了。 如果某些问题经常被问到，开发者可以利用此信息来改进说明文件或软件本身，以使其更清楚。如果只是私下提问，就没有人能看到最常见问题的完整场景。 如果一个项目既有”使用者” 也有”开发者”（或”黑客”）邮件列表或论坛，而你又不会动到那些源代码，那么就向”使用者”列表或论坛提问。不要假设自己会在开发者列表中受到欢迎，那些人多半会将你的提问视为干扰他们开发的噪音。 然而，如果你**确信**你的问题很特别，而且在”使用者” 列表或论坛中几天都没有回复，可以试试前往”开发者”列表或论坛发问。建议你在张贴前最好先暗地里观察几天以了解那里的行事方式（事实上这是参与任何私有或半私有列表的好主意） 如果你找不到一个项目的邮件列表，而只能查到项目维护者的电子邮件地址，尽管向他发信。即使是在这种情况下，也别假设（项目）邮件列表不存在。在你的电子邮件中，请陈述你已经试过但没有找到合适的邮件列表，也提及你不反对将自己的邮件转发给他人（许多人认为，即使没什么秘密，私人电子邮件也不应该被公开。通过允许将你的电子邮件转发他人，你给了相应人员处置你邮件的选择）。 使用有意义且描述明确的标题在邮件列表、新闻群组或论坛中，大约50字以内的标题是抓住资深专家注意力的好机会。别用喋喋不休的帮帮忙、跪求、急（更别说救命啊！！！！这样让人反感的话，用这种标题会被条件反射式地忽略）来浪费这个机会。不要妄想用你的痛苦程度来打动我们，而是在这点空间中使用极简单扼要的描述方式来提出问题。 一个好标题范例是目标 – 差异式的描述，许多技术支持组织就是这样做的。在目标部分指出是哪一个或哪一组东西有问题，在差异部分则描述与期望的行为不一致的地方。 蠢问题：救命啊！我的笔电不能正常显示了！ 聪明问题：X.org 6.8.1的鼠标游标会变形，某牌显卡 MV1005 芯片组。 更聪明问题：X.org 6.8.1的鼠标游标，在某牌显卡 MV1005 芯片组环境下 - 会变形。 编写目标 – 差异 式描述的过程有助于你组织对问题的细緻思考。是什么被影响了？ 仅仅是鼠标游标或者还有其它图形？只在 X.org 的 X 版中出现？或只是出现在6.8.1版中？ 是针对某牌显卡芯片组？或者只是其中的 MV1005 型号？ 一个黑客只需瞄一眼就能够立即明白你的环境**和**你遇到的问题。 总而言之，请想像一下你正在一个只显示标题的存档讨论串（Thread）索引中查寻。让你的标题更好地反映问题，可使下一个搜索类似问题的人能够关注这个讨论串，而不用再次提问相同的问题。 如果你想在回复中提出问题，记得要修改内容标题，以表明你是在问一个问题， 一个看起来像 Re: 测试 或者 Re: 新bug 的标题很难引起足够重视。另外，在不影响连贯性之下，适当引用并删减前文的内容，能给新来的读者留下线索。 对于讨论串，不要直接点击回复来开始一个全新的讨论串，这将限制你的观众。因为有些邮件阅读程序，比如 mutt ，允许使用者按讨论串排序并通过折叠讨论串来隐藏消息，这样做的人永远看不到你发的消息。 仅仅改变标题还不够。mutt 和其它一些邮件阅读程序还会检查邮件标题以外的其它信息，以便为其指定讨论串。所以宁可发一个全新的邮件。 在网页论坛上，好的提问方式稍有不同，因为讨论串与特定的信息紧密结合，并且通常在讨论串外就看不到里面的内容，故通过回复提问，而非改变标题是可接受的。不是所有论坛都允许在回复中出现分离的标题，而且这样做了基本上没有人会去看。不过，通过回复提问，这本身就是暧昧的做法，因为它们只会被正在查看该标题的人读到。所以，除非你**只想**在该讨论串当前活跃的人群中提问，不然还是另起炉灶比较好。 使问题容易回复以请将你的回复寄到……来结束你的问题多半会使你得不到回答。如果你觉得花几秒钟在邮件客户端设置一下回复地址都麻烦，我们也觉得花几秒钟思考你的问题更麻烦。如果你的邮件程序不支持这样做，换个好点的；如果是操作系统不支持这种邮件程序，也换个好点的。 在论坛，要求通过电子邮件回复是非常无礼的，除非你相信回复的信息可能比较敏感（而且有人会为了某些未知的原因，只让你而不是整个论坛知道答案）。如果你只是想在有人回复讨论串时得到电子邮件提醒，可以要求网页论坛发送给你。几乎所有论坛都支持诸如追踪此讨论串、有回复时发送邮件提醒等功能。 用清晰、正确、精准并语法正确的语句我们从经验中发现，粗心的提问者通常也会粗心的写程序与思考（我敢打包票）。回答粗心大意者的问题很不值得，我们宁愿把时间耗在别处。 正确的拼字、标点符号和大小写是很重要的。一般来说，如果你觉得这样做很麻烦，不想在乎这些，那我们也觉得麻烦，不想在乎你的提问。花点额外的精力斟酌一下字句，用不着太僵硬与正式 – 事实上，黑客文化很看重能准确地使用非正式、俚语和幽默的语句。但它**必须很**准确，而且有迹象表明你是在思考和关注问题。 正确地拼写、使用标点和大小写，不要将its混淆为it’s，loose搞成lose或者将discrete弄成discreet。不要全部用大写，这会被视为无礼的大声嚷嚷（全部小写也好不到哪去，因为不易阅读。Alan Cox也许可以这样做，但你不行。） 更白话的说，如果你写得像是个半文盲[译注：小白]），那多半得不到理睬。也不要使用即时通讯中的简写或火星文，如将的简化为ㄉ会使你看起来像一个为了少打几个键而省字的小白。更糟的是，如果像个小孩似地鬼画符那绝对是在找死，可以肯定没人会理你（或者最多是给你一大堆指责与挖苦）。 如果在使用非母语的论坛提问，你可以犯点拼写和语法上的小错，但决不能在思考上马虎（没错，我们通常能弄清两者的分别）。同时，除非你知道回复者使用的语言，否则请使用英语书写。繁忙的黑客一般会直接删除用他们看不懂语言写的消息。在网络上英语是通用语言，用英语书写可以将你的问题在尚未被阅读就被直接删除的可能性降到最低。 如果英文是你的外语（Second language），提示潜在回复者你有潜在的语言困难是很好的：[译注：以下附上原文以供使用] English is not my native language; please excuse typing errors. 英文不是我的母语，请原谅我的错字或语法 If you speak $LANGUAGE, please email&#x2F;PM me;I may need assistance translating my question. 如果你说某语言，请寄信&#x2F;私讯给我；我需要有人协助我翻译我的问题 I am familiar with the technical terms,but some slang expressions and idioms are difficult for me. 我对技术名词很熟悉，但对于俗语或是特别用法比较不甚了解。 I’ve posted my question in $LANGUAGE and English.I’ll be glad to translate responses, if you only use one or the other. 我把我的问题用某语言和英文写出来，如果你只用一种语言回答，我会乐意将其翻译成另一种。 使用易于读取且标准的文件格式发送问题如果你人为地将问题搞得难以阅读，它多半会被忽略，人们更愿读易懂的问题，所以： 使用纯文字而不是HTML (关闭HTML并不难） 使用MIME附件通常是可以的，前提是真正有内容（譬如附带的源代码或patch），而不仅仅是邮件程序生成的模板（譬如只是信件内容的拷贝）。 不要发送一段文字只是单行句子但多次断行的邮件（这使得回复部分内容非常困难）。设想你的读者是在80个字符宽的终端机上阅读邮件，最好设置你的断行点小于80字。 但是，也**不要**用任何固定断行资料（譬如日志档案拷贝或会话记录）。档案应该原样包含，让回复者有信心他们看到的是和你看到的一样的东西。 在英语论坛中，不要使用Quoted-Printable MIME编码发送消息。这种编码对于张贴非ASCII语言可能是必须的，但很多邮件程序并不支持这种编码。当它们分断时，那些文本中四处散布的**&#x3D;20**符号既难看也分散注意力，甚至有可能破坏内容的语意。 绝对，**永远**不要指望黑客们阅读使用封闭格式编写的文档，像是微软公司的Word或Excel文件等。大多数黑客对此的反应就像有人将还在冒热气的猪粪倒在你门口阶梯上时你的反应一样。即便他们能够处理，他们也很厌恶这么做。 如果你从使用Windows的电脑发送电子邮件，关闭微软愚蠢的智能引号功能 （从[选项] &gt; [校订] &gt; [自动校正选项], 按掉智能引号单选框），以免在你的邮件中到处散布垃圾字符。 在论坛，勿滥用表情符号和HTML功能（当它们提供时）。一两个表情符号通常没有问题，但花哨的彩色文本倾向于使人认为你是个无能之辈。过滥地使用表情符号、色彩和字体会使你看来像个傻笑的小姑娘。这通常不是个好主意，除非你只是对sex而不是有用的回复更有兴趣。 如果你使用图形用户界面的邮件程序（如微软公司的Outlook或者其它类似的），注意它们的默认设置不一定满足这些要求。大多数这类程序有基于选单的查看源代码命令，用它来检查发送文件夹中的消息，以确保发送的是没有多余杂质的纯文本文件。 精确的描述问题并言之有物 仔细、清楚地描述你的问题或Bug的症状。 描述问题发生的环境（机器配置、操作系统、应用程序、以及相关的信息），提供经销商的发行版和版本号（如：Fedora Core 4、Slackware 9.1等）。 描述在提问前你是怎样去研究和理解这个问题的。 描述在提问前为确定问题而采取的诊断步骤。 描述最近做过什么可能相关的硬件或软件变更。 尽可能的提供一个可以重现这个问题的既定环境的方法 尽量去揣测一个黑客会怎样反问你，在他提问的时候预先给他答案。 以上几点中，当你报告的是你认为可能在代码中的问题时，给黑客一个可以重现你的问题的环境尤其重要。当你这么做时，你得到有效的回答的机会和速度都会大大的提升。 Simon Tatham写过一篇名为《如何有效的报告Bug》的出色文章。强力推荐你也读一读。 话不在多而在精你需要提供精确有内容的信息。这并不是要求你简单的把成堆的出错代码或者资料完全转录到你的提问中。如果你有庞大而复杂的测试样例能重现程序挂掉的情境，尽量将它剪裁得越小越好。 这样做的用处至少有三点。第一，表现出你为简化问题付出了努力，这可以使你得到回答的机会增加；第二，简化问题使你更有可能得到**有用**的答案；第三，在精炼你的bug报告的过程中，你很可能就自己找到了解决方法或权宜之计。 别动辄声称找到Bug当你在使用软件中遇到问题，除非你非常、**非常的有根据，不要动辄声称找到了Bug。提示：除非你能提供解决问题的源代码补丁，或者对前一版本的回归测试表现出不正确的行为，否则你都多半不够完全确信。这同样适用在网页和文件，如果你（声称）发现了文件的Bug**，你应该能提供相应位置的修正或替代文件。 请记得，还有许多其它使用者没遇到你发现的问题，否则你在阅读文件或搜索网页时就应该发现了（你在抱怨前已经做了这些，是吧？）。这也意味着很有可能是你弄错了而不是软件本身有问题。 编写软件的人总是非常辛苦地使它尽可能完美。如果你声称找到了Bug，也就是在质疑他们的能力，即使你是对的，也有可能会冒犯到其中某部分人。这尤其严重当你在标题中嚷嚷着有Bug。 提问时，即使你私下非常确信已经发现一个真正的Bug，最好写得像是**你**做错了什么。如果真的有Bug，你会在回复中看到这点。这样做的话，如果真有Bug，维护者就会向你道歉，这总比你惹恼别人然后欠别人一个道歉要好一点。 可以低声下气，但还是要先做功课有些人明白他们不该粗鲁或傲慢的提问并要求得到答复，但他们选择另一个极端 – 低声下气：**我知道我只是个可悲的新手，一个撸瑟，但…**。这既使人困扰，也没有用，尤其是伴随着与实际问题含糊不清的描述时更令人反感。 别用原始灵长类动物的把戏来浪费你我的时间。取而代之的是，尽可能清楚地描述背景条件和你的问题情况。这比低声下气更好地定位了你的位置。 有时网页论坛会设有专为新手提问的版面，如果你真的认为遇到了初学者的问题，到那去就是了，但一样别那么低声下气。 描述问题症状而非猜测告诉黑客们你认为问题是怎样造成的并没什么帮助。（如果你的推断如此有效，还用向别人求助吗？），因此要确信你原原本本告诉了他们问题的症状，而不是你的解释和理论；让黑客们来推测和诊断。如果你认为陈述自己的猜测很重要，清楚地说明这只是你的猜测，并描述为什么它们不起作用。 蠢问题 我在编译内核时接连遇到 SIG11 错误，我怀疑某条飞线搭在主板的走线上了，这种情况应该怎样检查最好？ 聪明问题 我的组装电脑是 FIC-PA2007 主机板搭载 AMD K6&#x2F;233 CPU（威盛 Apollo VP2芯片组），256MB Corsair PC133 SDRAM内存，在编译内核时，从开机20分钟以后就频频产生 SIG11 错误，但是在头20分钟内从没发生过相同的问题。重新启动也没有用，但是关机一晚上就又能工作20分钟。所有内存都换过了，没有效果。相关部分的标准编译记录如下…。 由于以上这点似乎让许多人觉得难以配合，这里有句话可以提醒你：所有的诊断专家都来自密苏里州。 美国国务院的官方座右铭则是：让我看看（出自国会议员 Willard D. Vandiver 在1899年时的讲话：我来自一个出产玉米，棉花，牛蒡和民主党人的国家，滔滔雄辩既不能说服我，也不会让我满意。我来自密苏里州，你必须让我看看。） 针对诊断者而言，这并不是一种怀疑，而只是一种真实而有用的需求，以便让他们看到的是与你看到的原始证据尽可能一致的东西，而不是你的猜测与归纳的结论。所以，大方的展示给我们看吧！ 按发生时间先后列出问题症状问题发生前的一系列操作，往往就是对找出问题最有帮助的线索。因此，你的说明里应该包含你的操作步骤，以及机器和软件的反应，直到问题发生。在命令行处理的情况下，提供一段操作记录（例如运行脚本工具所生成的），并引用相关的若干行（如20行）记录会非常有帮助。 如果挂掉的程序有诊断选项（如 -v 的详述开关），试着选择这些能在记录中增加调试信息的选项。记住，多不等于好。试着选取适当的调试级别以便提供有用的信息而不是让读者淹没在垃圾中。 如果你的说明很长（如超过四个段落），在开头简述问题，接下来再按时间顺序详述会有所帮助。这样黑客们在读你的记录时就知道该注意哪些内容了。 描述目标而不是过程如果你想弄清楚如何做某事（而不是报告一个Bug），在开头就描述你的目标，然后才陈述重现你所卡住的特定步骤。 经常寻求技术帮助的人在心中有个更高层次的目标，而他们在自以为能达到目标的特定道路上被卡住了，然后跑来问该怎么走，但没有意识到这条路本身就有问题。结果要费很大的劲才能搞定。 蠢问题 我怎样才能从某绘图程序的颜色选择器中取得十六进制的的RGB值？ 聪明问题 我正试着用替换一幅图片的色码成自己选定的色码，我现在知道的唯一方法是编辑每个色码区块，但却无法从某绘图程序的颜色选择器取得十六进制的的RGB值。 第二种提问法比较聪明，你可能得到像是建议采用另一个更合适的工具的回复。 别要求使用私人电邮回复黑客们认为问题的解决过程应该公开、透明，此过程中如果更有经验的人注意到不完整或者不当之处，最初的回复才能够、也应该被纠正。同时，作为提供帮助者也能因为能力和学识被其它同行看到而得到某种奖励。 当你要求私下回复时，这个过程和奖励都被中止。别这样做，让**回复者**来决定是否私下回答 – 如果他真这么做了，通常是因为他认为问题编写太差或者太肤浅，以至于对其它人没有兴趣。 这条规则存在一条有限的例外，如果你确信提问可能会引来大量雷同的回复时，那么这个神奇的提问句会是向我发电邮，我将为论坛归纳这些回复。试着将邮件列表或新闻群组从洪水般的雷同回复中解救出来是非常有礼貌的 – 但你必须信守诺言。 清楚明确的表达你的问题以及需求漫无边际的提问近乎无休无止的时间黑洞。最有可能给你有用答案的人通常也正是最忙的人（他们忙是因为要亲自完成大部分工作）。这样的人对无节制的时间黑洞相当厌恶，所以他们也倾向于厌恶那些漫无边际的提问。 如果你明确表述需要回答者做什么（如提供指点、发送一段代码、检查你的补丁、或是其他等等），就最有可能得到有用的答案。因为这会定出一个时间和精力的上限，便于回答者能集中精力来帮你。这么做很棒。 要理解专家们所处的世界，请把专业技能想像为充裕的资源，而回复的时间则是稀缺的资源。你要求他们奉献的时间越少，你越有可能从真正专业而且很忙的专家那里得到解答。 所以，界定一下你的问题，使专家花在辨识你的问题和回答所需要付出的时间减到最少，这技巧对你有用答案相当有帮助 – 但这技巧通常和简化问题有所区别。因此，问我想更好的理解X，可否指点一下哪有好一点说明？通常比问你能解释一下X吗？更好。如果你的代码不能运作，通常请别人看看哪里有问题，比要求别人替你改正要明智得多。 询问有关代码的问题时别要求他人帮你有问题的代码调试而不提示一下应该从何入手。张贴几百行的代码，然后说一声：它不会动会让你完全被忽略。只贴几十行代码，然后说一句：**在第七行以后，我期待它显示 ，但实际出现的是 **比较有可能让你得到回应。 最有效描述程序问题的方法是提供最精简的Bug展示测试示例（bug-demonstrating test case）。什么是最精简的测试示例? 那是问题的缩影；一小个程序片段能刚好展示出程序的异常行为，而不包含其他令人分散注意力的内容。怎么制作最精简的测试示例？如果你知道哪一行或哪一段代码会造成异常的行为，复制下来并加入足够重现这个状况的代码（例如，足以让这段代码能被编译&#x2F;直译&#x2F;被应用程序处理）。如果你无法将问题缩减到一个特定区块，就复制一份代码并移除不影响产生问题行为的部分。总之，测试示例越小越好（查看话不在多而在精一节）。 一般而言，要得到一段相当精简的测试示例并不太容易，但永远先尝试这样做的是种好习惯。这种方式可以帮助你了解如何自行解决这个问题 —- 而且即使你的尝试不成功，黑客们也会看到你在尝试取得答案的过程中付出了努力，这可以让他们更愿意与你合作。 如果你只是想让别人帮忙审查（Review）一下代码，在信的开头就要说出来，并且一定要提到你认为哪一部分特别需要关注以及为什么。 别把自己家庭作业的问题贴上来黑客们很擅长分辨哪些问题是家庭作业式的问题；因为我们中的大多数都曾自己解决这类问题。同样，这些问题得由**你**来搞定，你会从中学到东西。你可以要求给点提示，但别要求得到完整的解决方案。 如果你怀疑自己碰到了一个家庭作业式的问题，但仍然无法解决，试试在使用者群组，论坛或（最后一招）在项目的使用者邮件列表或论坛中提问。尽管黑客们**会**看出来，但一些有经验的使用者也许仍会给你一些提示。 去掉无意义的提问句避免用无意义的话结束提问，例如有人能帮我吗？或者这有答案吗？。 首先：如果你对问题的描述不是很好，这样问更是画蛇添足。 其次：由于这样问是画蛇添足，黑客们会很厌烦你 – 而且通常会用逻辑上正确，但毫无意义的回答来表示他们的蔑视， 例如：没错，有人能帮你或者不，没答案。 一般来说，避免用 是或否、对或错、有或没有类型的问句，除非你想得到是或否类型的回答。 即使你很急也不要在标题写紧急这是你的问题，不是我们的。宣称紧急极有可能事与愿违：大多数黑客会直接删除无礼和自私地企图即时引起关注的问题。更严重的是，紧急这个字（或是其他企图引起关注的标题）通常会被垃圾信过滤器过滤掉 – 你希望能看到你问题的人可能永远也看不到。 有半个例外的情况是，如果你是在一些很高调，会使黑客们兴奋的地方，也许值得这样去做。在这种情况下，如果你有时间压力，也很有礼貌地提到这点，人们也许会有兴趣回答快一点。 当然，这风险很大，因为黑客们兴奋的点多半与你的不同。譬如从 NASA 国际空间站（International Space Station）发这样的标题没有问题，但用自我感觉良好的慈善行为或政治原因发肯定不行。事实上，张贴诸如紧急：帮我救救这个毛绒绒的小海豹！肯定让你被黑客忽略或惹恼他们，即使他们认为毛绒绒的小海豹很重要。 如果你觉得这点很不可思议，最好再把这份指南剩下的内容多读几遍，直到你弄懂了再发文。 礼多人不怪，而且有时还很有帮助彬彬有礼，多用请和谢谢您的关注，或谢谢你的关照。让大家都知道你对他们花时间免费提供帮助心存感激。 坦白说，这一点并没有比清晰、正确、精准并合法语法和避免使用专用格式重要（也不能取而代之）。黑客们一般宁可读有点唐突但技术上鲜明的Bug报告，而不是那种有礼但含糊的报告。（如果这点让你不解，记住我们是按问题能教我们什么来评价问题的价值的） 然而，如果你有一串的问题待解决，客气一点肯定会增加你得到有用回应的机会。 （我们注意到，自从本指南发布后，从资深黑客那里得到的唯一严重缺陷反馈，就是对预先道谢这一条。一些黑客觉得先谢了意味着事后就不用再感谢任何人的暗示。我们的建议是要么先说先谢了，**然后事后再对回复者表示感谢，或者换种方式表达感激，譬如用谢谢你的关注或谢谢你的关照**。） 问题解决后，加个简短的补充说明问题解决后，向所有帮助过你的人发个说明，让他们知道问题是怎样解决的，并再一次向他们表示感谢。如果问题在新闻组或者邮件列表中引起了广泛关注，应该在那里贴一个说明比较恰当。 最理想的方式是向最初提问的话题回复此消息，并在标题中包含已修正，已解决或其它同等含义的明显标记。在人来人往的邮件列表里，一个看见讨论串问题 X和问题的X - 已解决的潜在回复者就明白不用再浪费时间了（除非他个人觉得问题 X的有趣），因此可以利用此时间去解决其它问题。 补充说明不必很长或是很深入；简单的一句你好，原来是网线出了问题！谢谢大家 – Bill比什么也不说要来的好。事实上，除非结论真的很有技术含量，否则简短可爱的小结比长篇大论更好。说明问题是怎样解决的，但大可不必将解决问题的过程复述一遍。 对于有深度的问题，张贴调试记录的摘要是有帮助的。描述问题的最终状态，说明是什么解决了问题，在此**之后**才指明可以避免的盲点。避免盲点的部分应放在正确的解决方案和其它总结材料之后，而不要将此信息搞成侦探推理小说。列出那些帮助过你的名字，会让你交到更多朋友。 除了有礼貌和有内涵以外，这种类型的补充也有助于他人在邮件列表&#x2F;新闻群组&#x2F;论坛中搜索到真正解决你问题的方案，让他们也从中受益。 至少，这种补充有助于让每位参与协助的人因问题的解决而从中得到满足感。如果你自己不是技术专家或者黑客，那就相信我们，这种感觉对于那些你向他们求助的大师或者专家而言，是非常重要的。问题悬而未决会让人灰心；黑客们渴望看到问题被解决。好人有好报，满足他们的渴望，你会在下次提问时尝到甜头。 思考一下怎样才能避免他人将来也遇到类似的问题，自问写一份文件或加个常见问题（FAQ）会不会有帮助。如果是的话就将它们发给维护者。 在黑客中，这种良好的后继行动实际上比传统的礼节更为重要，也是你如何透过善待他人而赢得声誉的方式，这是非常有价值的资产。 如何解读答案 RTFM和STFW：如何知道你已完全搞砸了有一个古老而神圣的传统：如果你收到RTFM （Read The Fucking Manual）的回应，回答者认为你应该去读他妈的手册。当然，基本上他是对的，你应该去读一读。 RTFM 有一个年轻的亲戚。如果你收到STFW（Search The Fucking Web）的回应，回答者认为你应该到他妈的网上搜索过了。那人多半也是对的，去搜索一下吧。（更温和一点的说法是 **Google是你的朋友**！） 在论坛，你也可能被要求去爬爬论坛的旧文。事实上，有人甚至可能热心地为你提供以前解决此问题的讨论串。但不要依赖这种关照，提问前应该先搜索一下旧文。 通常，用这两句之一回答你的人会给你一份包含你需要内容的手册或者一个网址，而且他们打这些字的时候也正在读着。这些答复意味着回答者认为 你需要的信息非常容易获得； 你自己去搜索这些信息比灌给你能让你学到更多。 你不应该因此不爽；依照黑客的标准，他已经表示了对你一定程度的关注，而没有对你的要求视而不见。你应该对他祖母般的慈祥表示感谢。 如果还是搞不懂如果你看不懂回应，别立刻要求对方解释。像你以前试着自己解决问题时那样（利用手册，FAQ，网络，身边的高手），先试着去搞懂他的回应。如果你真的需要对方解释，记得表现出你已经从中学到了点什么。 比方说，如果我回答你：看来似乎是 zentry 卡住了；你应该先清除它。，然后，这是一个**很糟的后续问题回应：zentry是什么？** 好的问法应该是这样：哦~~~我看过说明了但是只有 -z 和 -p 两个参数中提到了 zentries，而且还都没有清楚的解释如何清除它。你是指这两个中的哪一个吗？还是我看漏了什么？ 处理无礼的回应很多黑客圈子中看似无礼的行为并不是存心冒犯。相反，它是直接了当，一针见血式的交流风格，这种风格更注重解决问题，而不是使人感觉舒服而却模模糊糊。 如果你觉得被冒犯了，试着平静地反应。如果有人真的做了出格的事，邮件列表、新闻群组或论坛中的前辈多半会招呼他。如果这**没有发生而你却发火了，那么你发火对象的言语可能在黑客社区中看起来是正常的，而你**将被视为有错的一方，这将伤害到你获取信息或帮助的机会。 另一方面，你偶而真的会碰到无礼和无聊的言行。与上述相反，对真正的冒犯者狠狠地打击，用犀利的语言将其驳得体无完肤都是可以接受的。然而，在行事之前一定要非常非常的有根据。纠正无礼的言论与开始一场毫无意义的口水战仅一线之隔，黑客们自己莽撞地越线的情况并不鲜见。如果你是新手或外人，避开这种莽撞的机会并不高。如果你想得到的是信息而不是消磨时光，这时最好不要把手放在键盘上以免冒险。 （有些人断言很多黑客都有轻度的自闭症或亚斯伯格综合症，缺少用于润滑人类社会正常交往所需的神经。这既可能是真也可能是假的。如果你自己不是黑客，兴许你认为我们脑袋有问题还能帮助你应付我们的古怪行为。只管这么干好了，我们不在乎。我们**喜欢**我们现在这个样子，并且通常对病患标记都有站得住脚的怀疑。） 在下一节，我们会谈到另一个问题，当**你行为不当时所会受到的冒犯**。 如何避免扮演失败者在黑客社区的论坛中有那么几次你可能会搞砸 – 以本指南所描述到的或类似的方式。而你会在公开场合中被告知你是如何搞砸的，也许攻击的言语中还会带点夹七夹八的颜色。 这种事发生以后，你能做的最糟糕的事莫过于哀嚎你的遭遇、宣称被口头攻击、要求道歉、高声尖叫、憋闷气、威胁诉诸法律、向其雇主报怨、忘了关马桶盖等等。相反地，你该这么做： 熬过去，这很正常。事实上，它是有益健康且合理的。 社区的标准不会自行维持，它们是通过参与者积极而**公开地**执行来维持的。不要哭嚎所有的批评都应该通过私下的邮件传送，它不是这样运作的。当有人评论你的一个说法有误或者提出不同看法时，坚持声称受到个人攻击也毫无益处，这些都是失败者的态度。 也有其它的黑客论坛，受过高礼节要求的误导，禁止参与者张贴任何对别人帖子挑毛病的消息，并声称如果你不想帮助用户就闭嘴。 结果造成有想法的参与者纷纷离开，这么做只会使它们沦为毫无意义的嘮叨与无用的技术论坛。 夸张的讲法是：你要的是友善（以上述方式）还是有用？两个里面挑一个。 记着：当黑客说你搞砸了，并且（无论多么刺耳）告诉你别再这样做时，他正在为关心你和他的社区而行动。对他而言，不理你并将你从他的生活中滤掉更简单。如果你无法做到感谢，至少要表现地有点尊严，别大声哀嚎，也别因为自己是个有戏剧性超级敏感的灵魂和自以为有资格的新来者，就指望别人像对待脆弱的洋娃娃那样对你。 有时候，即使你没有搞砸（或者只是在他的想像中你搞砸了），有些人也会无缘无故地攻击你本人。在这种情况下，抱怨倒是**真的**会把问题搞砸。 这些来找麻烦的人要么是毫无办法但自以为是专家的不中用家伙，要么就是测试你是否真会搞砸的心理专家。其它读者要么不理睬，要么用自己的方式对付他们。这些来找麻烦的人在给他们自己找麻烦，这点你不用操心。 也别让自己卷入口水战，最好不要理睬大多数的口水战 – 当然，是在你检验它们只是口水战，而并未指出你有搞砸的地方，且也没有巧妙地将问题真正的答案藏于其后（这也是有可能的）。 不该问的问题以下是几个经典蠢问题，以及黑客没回答时心中所想的： 问题：我能在哪找到 X 程序或 X 资源？ 问题：我怎样用 X 做 Y？ 问题：如何设定我的 shell 提示？ 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 问题：我的程序&#x2F;设定&#x2F;SQL语句没有用 问题：我的 Windows 电脑有问题，你能帮我吗？ 问题：我的程序不会动了，我认为系统工具 X 有问题 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？ 问题：我能在哪找到 X 程序或 X 资源？ 回答：就在我找到它的地方啊，白痴 – 搜索引擎的那一头。天哪！难道还有人不会用 Google 吗？ 问题：我怎样用 X 做 Y？ 回答：如果你想解决的是 Y ，提问时别给出可能并不恰当的方法。这种问题说明提问者不但对 X 完全无知，也对 Y 要解决的问题糊涂，还被特定形势禁锢了思维。最好忽略这种人，等他们把问题搞清楚了再说。 问题：如何设定我的 shell 提示？？ 回答：如果你有足够的智慧提这个问题，你也该有足够的智慧去 RTFM，然后自己去找出来。 问题：我可以用 Bass-o-matic 文件转换工具将 AcmeCorp 档案转换为 TeX 格式吗？ 回答：试试看就知道了。如果你试过，你既知道了答案，就不用浪费我的时间了。 问题：我的程序&#x2F;设定&#x2F;SQL语句没有用 回答：这不算是问题吧，我对要我问你二十个问题才找得出你真正问题的问题没兴趣 – 我有更有意思的事要做呢。在看到这类问题的时候，我的反应通常不外如下三种 你还有什么要补充的吗？ 真糟糕，希望你能搞定。 这关我有什么屁事？ 问题：我的 Windows 电脑有问题，你能帮我吗？ 回答：能啊，扔掉萎软的垃圾，换个像 Linux 或 BSD 的开放源代码操作系统吧。 注意：如果程序有官方版 Windows 或者与 Windows 有互动（如Samba），你**可以**问与Windows相关的问题， 只是别对问题是由 Windows 操作系统而不是程序本身造成的回复感到惊讶， 因为 Windows 一般来说实在太烂，这种说法通常都是对的。 问题：我的程序不会动了，我认为系统工具 X 有问题 回答：你完全有可能是第一个注意到被成千上万用户反复使用的系统调用与函数库档案有明显缺陷的人，更有可能的是你完全没有根据。不同凡响的说法需要不同凡响的证据，当你这样声称时，你必须有清楚而详尽的缺陷说明文件作后盾。 问题：我在安装 Linux（或者 X ）时有问题，你能帮我吗？ 回答：不能，我只有亲自在你的电脑上动手才能找到毛病。还是去找你当地的 Linux 使用群组者寻求实际的指导吧（你能在这儿找到使用者群组的清单）。 注意：如果安装问题与某 Linux 的发行版有关，在它的邮件列表、论坛或本地使用者群组中提问也许是恰当的。此时，应描述问题的准确细节。在此之前，先用 Linux 和**所有**被怀疑的硬件作关键词仔细搜索。 问题：我怎么才能破解 root 帐号&#x2F;窃取 OP 特权&#x2F;读别人的邮件呢？ 回答：想要这样做，说明了你是个卑鄙小人；想找个黑客帮你，说明你是个白痴！ 好问题与蠢问题最后，我将透过举一些例子，来说明怎样聪明的提问；同一个问题的两种问法被放在一起，一种是愚蠢的，另一种才是明智的。 **蠢问题**： 我可以在哪儿找到关于 Foonly Flurbamatic 的资料？ 这种问法无非想得到 STFW 这样的回答。 **聪明问题**： 我用Google搜索过 “Foonly Flurbamatic 2600”，但是没找到有用的结果。谁知道上哪儿去找对这种设备编程的资料？ 这个问题已经 STFW 过了，看起来他真的遇到了麻烦。 蠢问题 我从 foo 项目找来的源码没法编译。它怎么这么烂？ 他觉得都是别人的错，这个傲慢自大的提问者 聪明问题 foo 项目代码在 Nulix 6.2 版下无法编译通过。我读过了 FAQ，但里面没有提到跟 Nulix 有关的问题。这是我编译过程的记录，我有什么做的不对的地方吗？ 提问者已经指明了环境，也读过了FAQ，还列出了错误，并且他没有把问题的责任推到别人头上，他的问题值得被关注。 蠢问题 我的主机板有问题了，谁来帮我？ 某黑客对这类问题的回答通常是：好的，还要帮你拍拍背和换尿布吗？，然后按下删除键。 聪明问题 我在 S2464 主机板上试过了 X 、 Y 和 Z ，但没什么作用，我又试了 A 、 B 和 C 。请注意当我尝试 C 时的奇怪现象。显然 florbish 正在 grommicking，但结果出人意料。通常在 Athlon MP 主机板上引起 grommicking 的原因是什么？有谁知道接下来我该做些什么测试才能找出问题？ 这个家伙，从另一个角度来看，值得去回答他。他表现出了解决问题的能力，而不是坐等天上掉答案。 在最后一个问题中，注意告诉我答案和给我启示，指出我还应该做什么诊断工作之间微妙而又重要的区别。 事实上，后一个问题源自于 2001 年 8 月在 Linux 内核邮件列表（lkml）上的一个真实的提问。我（Eric）就是那个提出问题的人。我在 Tyan S2464 主板上观察到了这种无法解释的锁定现象，列表成员们提供了解决这一问题的重要信息。 通过我的提问方法，我给了别人可以咀嚼玩味的东西；我设法让人们很容易参与并且被吸引进来。我显示了自己具备和他们同等的能力，并邀请他们与我共同探讨。通过告诉他们我所走过的弯路，以避免他们再浪费时间，我也表明了对他们宝贵时间的尊重。 事后，当我向每个人表示感谢，并且赞赏这次良好的讨论经历的时候， 一个 Linux 内核邮件列表的成员表示，他觉得我的问题得到解决并非由于我是这个列表中的**名人**，而是因为我用了正确的方式来提问。 黑客从某种角度来说是拥有丰富知识但缺乏人情味的家伙；我相信他是对的，如果我**像**个乞讨者那样提问，不论我是谁，一定会惹恼某些人或者被他们忽视。他建议我记下这件事，这直接导致了本指南的出现。 如果得不到回答如果仍得不到回答，请不要以为我们觉得无法帮助你。有时只是看到你问题的人不知道答案罢了。没有回应不代表你被忽视，虽然不可否认这种差别很难区分。 总的来说，简单的重复张贴问题是个很糟的点子。这将被视为无意义的喧闹。有点耐心，知道你问题答案的人可能生活在不同的时区，可能正在睡觉，也有可能你的问题一开始就没有组织好。 你可以通过其他渠道获得帮助，这些渠道通常更适合初学者的需要。 有许多网上的以及本地的使用者群组，由热情的软件爱好者（即使他们可能从没亲自写过任何软件）组成。通常人们组建这样的团体来互相帮助并帮助新手。 另外，你可以向很多商业公司寻求帮助，不论公司大还是小。别为要付费才能获得帮助而感到沮丧！毕竟，假使你的汽车发动机汽缸密封圈爆掉了– 完全可能如此 –你还得把它送到修车铺，并且为维修付费。就算软件没花费你一分钱，你也不能强求技术支持总是免费的。 对像是 Linux 这种大众化的软件，每个开发者至少会对应到上万名使用者。根本不可能由一个人来处理来自上万名使用者的求助电话。要知道，即使你要为这些协助付费，和你所购买的同类软件相比，你所付出的也是微不足道的（通常封闭源代码软件的技术支持费用比开放源代码软件的要高得多，且内容也没那么丰富）。 如何更好地回答问题**态度和善一点**。问题带来的压力常使人显得无礼或愚蠢，其实并不是这样。 **对初犯者私下回复**。对那些坦诚犯错之人没有必要当众羞辱，一个真正的新手也许连怎么搜索或在哪找常见问题都不知道。 **如果你不确定，一定要说出来**！一个听起来权威的错误回复比没有还要糟，别因为听起来像个专家很好玩，就给别人乱指路。要谦虚和诚实，给提问者与同行都树个好榜样。 **如果帮不了忙，也别妨碍他**。不要在实际步骤上开玩笑，那样也许会毁了使用者的设置 –有些可怜的呆瓜会把它当成真的指令。 **试探性的反问以引出更多的细节**。如果你做得好，提问者可以学到点东西 –你也可以。试试将蠢问题转变成好问题，别忘了我们都曾是新手。 尽管对那些懒虫抱怨一声 RTFM 是正当的，能指出文件的位置（即使只是建议个 Google 搜索关键词）会更好。 **如果你决定回答，就请给出好的答案**。当别人正在用错误的工具或方法时别建议笨拙的权宜之计（wordaround），应推荐更好的工具，重新界定问题。 **正面的回答问题**！如果这个提问者已经很深入的研究而且也表明已经试过 X 、 Y 、 Z 、 A 、 B 、 C 但没得到结果，回答 试试看 A 或是 B 或者 试试X 、 Y 、 Z 、 A 、 B 、 C 并附上一个链接一点用都没有。 帮助你的社区从问题中学习。当回复一个好问题时，问问自己如何修改相关文件或常见问题文件以免再次解答同样的问题？，接着再向文件维护者发一份补丁。 如果你是在研究一番后才做出的回答，**展现你的技巧而不是直接端出结果。毕竟授人以鱼不如授人以渔**。 相关资源如果你需要个人电脑、Unix 系统和网络如何运作的基础知识，参阅Unix系统和网络基本原理。 当你发布软件或补丁时，试着按软件发布实践操作。 鸣谢Evelyn Mitchel贡献了一些愚蠢问题例子并启发了编写如何更好地回答问题这一节， Mikhail Ramendik贡献了一些特别有价值的建议和改进。","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[]},{"title":"Vim 从入门到精通","slug":"repost/Vim-Galore","date":"2018-02-19T06:49:13.000Z","updated":"2024-03-11T18:14:54.499Z","comments":true,"path":"2018/02/19/repost/Vim-Galore/","permalink":"https://blog.jugg.xyz/2018/02/19/repost/Vim-Galore/","excerpt":"","text":"Vim 从入门到精通 本文主要在翻译 mhinz&#x2F;vim-galore的基础添加了一些我在使用 Vim 及开发 Vim 插件的过程中积累的一些知识和常用插件列表。 Vim 中文同步聊天室 telegram： @VimHub gitter: vim-china&#x2F;Lobby IRC: #vim-china 简介什么是 Vim？Vim 是一个历史悠久的文本编辑器，可以追溯到qed。Bram Moolenaar 于1991 年发布初始版本。 Linux、Mac 用户，可以使用包管理器安装 Vim，对于 Windows 用户，可以从我的网盘 下载。该版本可轻易添加 python 、python3 、lua 等支持，只需要安装 python、lua即可。 项目在 Github 上开发，项目讨论请订阅vim_dev 邮件列表。 通过阅读 Why, oh WHY, do those #?@! nutheads use vi?来对 Vim 进行大致的了解。 Vim 哲学Vim 采用模式编辑的理念，即它提供了多种模式，按键在不同的模式下作用不同。你可以在普通模式 下浏览文件，在插入模式下插入文本，在可视模式下选择行，在命令模式下执行命令等等。起初这听起来可能很复杂，但是这有一个很大的优点：不需要通过同时按住多个键来完成操作，大多数时候你只需要依次按下这些按键即可。越常用的操作，所需要的按键数量越少。 和模式编辑紧密相连的概念是 操作符 和 动作。操作符 指的是开始某个行为，例如：修改、删除或者选择文本，之后你要用一个 动作 来指定需要操作的文本区域。比如，要改变括号内的文本，需要执行 ci( （读做 change inner parentheses）；删除整个段落的内容，需要执行 dap （读做：delete around paragraph）。 如果你能看见 Vim 老司机操作，你会发现他们使用 Vim 脚本语言就如同钢琴师弹钢琴一样。复杂的操作只需要几个按键就能完成。他们甚至不用刻意去想，因为这已经成为肌肉记忆了。这减少认识负荷并帮助人们专注于实际任务。 入门Vim 自带一个交互式的教程，内含你需要了解的最基础的信息，你可以通过终端运行以下命令打开教程： $ vimtutor 不要因为这个看上去很无聊而跳过，按照此教程多练习。你以前用的 IDE 或者其他编辑器很少是有“模式”概念的，因此一开始你会很难适应模式切换。但是你 Vim 使用的越多，肌肉记忆 将越容易形成。 Vim 基于一个 vi 克隆，叫做 Stevie，支持两种运行模式：”compatible” 和 “nocompatible”。在兼容模式下运行 Vim 意味着使用 vi 的默认设置，而不是 Vim 的默认设置。除非你新建一个用户的 vimrc 或者使用 vim -N 命令启动 Vim，否则就是在兼容模式下运行 Vim！请大家不要在兼容模式下运行 Vim。 下一步 创建你自己的 vimrc。 在第一周准备备忘录。 通读基础章节了解 Vim 还有哪些功能。 按需学习！Vim 是学不完的。如果你遇到了问题，先上网寻找解决方案，你的问题可能已经被解决了。Vim 拥有大量的参考文档，知道如何利用这些参考文档很有必要：获取离线帮助。 浏览附加资源。 最后一个建议：使用插件之前，请先掌握 Vim 的基本操作。很多插件都只是对 Vim 自带功能的封装。 返回主目录 :arrow_heading_up: 精简的 vimrc用户的 vimrc 配置文件可以放在 ~/.vimrc，或者为了更好的分离放在 ~/.vim/vimrc，后者更便于通过版本控制软件备份和同步整个配置，比方说 Github。 你可以在网上找到许多精简的 vimrc 配置文件，我的版本可能并不是最简单的版本，但是我的版本提供了一套我认为良好的，非常适合入门的设置。 最终你需要阅读完那些设置，然后自行决定需要使用哪些。:-) 精简的 vimrc 地址：minimal-vimrc 如果你有兴趣，这里是我（原作者）的 vimrc。 建议：大多数插件作者都维护不止一个插件并且将他们的 vimrc 放在 Github 上展示（通常放在叫做 “vim-config” 或者 “dotfiles” 的仓库中），所以当你发现你喜欢的插件时，去插件维护者的 Github 主页看看有没有这样的仓库。 返回主目录 :arrow_heading_up: 我正在使用什么样的 Vim使用 :version 命令将向你展示当前正在运行的 Vim 的所有相关信息，包括它是如何编译的。 第一行告诉你这个二进制文件的编译时间和版本号，比如：7.4。接下来的一行呈现 Included patches: 1-1051，这是补丁版本包。因此你 Vim 确切的版本号是 7.4.1051。 另一行显示着一些像 Tiny version without GUI 或者 Huge version with GUI 的信息。很显然这些信息告诉你当前的 Vim 是否支持 GUI，例如：从终端中运行 gvim 或者从终端模拟器中的 Vim 内运行 :gui 命令。另一个重要的信息是 Tiny 和 Huge。Vim 的特性集区分被叫做 tiny，small，normal，big and huge，所有的都实现不同的功能子集。 :version 主要的输出内容是特性列表。+clipboard 意味这剪贴板功能被编译支持了，-clipboard 意味着剪贴板特性没有被编译支持。 一些功能特性需要编译支持才能正常工作。例如：为了让 :prof 工作，你需要使用 huge 模式编译的 Vim，因为那种模式启用了 +profile 特性。 如果你的输出情况并不是那样，并且你是从包管理器安装 Vim 的，确保你安装了 vim-x，vim-x11，vim-gtk，vim-gnome 这些包或者相似的，因为这些包通常都是 huge 模式编译的。 你也可以运行下面这段代码来测试 Vim 版本以及功能支持： 1234&quot; Do something if running at least Vim 7.4.42 with +profile enabled.if (v:version &gt; 704 || v:version == 704 &amp;&amp; has(&#x27;patch42&#x27;)) &amp;&amp; has(&#x27;profile&#x27;) &quot; do stuffendif 相关帮助： :h :version :h feature-list :h +feature-list :h has-patch 返回主目录 :arrow_heading_up: 备忘录为了避免版权问题，我只贴出链接： http://people.csail.mit.edu/vgod/vim/vim-cheat-sheet-en.png https://cdn.shopify.com/s/files/1/0165/4168/files/preview.png http://www.nathael.org/Data/vi-vim-cheat-sheet.svg http://michael.peopleofhonoronly.com/vim/vim_cheat_sheet_for_programmers_screen.png http://www.rosipov.com/images/posts/vim-movement-commands-cheatsheet.png 或者在 Vim 中快速打开备忘录：vim-cheat40。 返回主目录 :arrow_heading_up: 基础缓冲区，窗口，标签Vim 是一个文本编辑器。每次文本都是作为缓冲区的一部分显示的。每一份文件都是在他们自己独有的缓冲区打开的，插件显示的内容也在它们自己的缓冲区中。 缓冲区有很多属性，比如这个缓冲区的内容是否可以修改，或者这个缓冲区是否和文件相关联，是否需要同步保存到磁盘上。 窗口 是缓冲区上一层的视窗。如果你想同时查看几个文件或者查看同一文件的不同位置，那样你会需要窗口。 请别把他们叫做 分屏 。你可以把一个窗口分割成两个，但是这并没有让这两个窗口完全 分离 。 窗口可以水平或者竖直分割并且现有窗口的高度和宽度都是可以被调节设置的，因此，如果你需要多种窗口布局，请考虑使用标签。 标签页 （标签）是窗口的集合。因此当你想使用多种窗口布局时候请使用标签。 简单的说，如果你启动 Vim 的时候没有附带任何参数，你会得到一个包含着一个呈现一个缓冲区的窗口的标签。 顺带提一下，缓冲区列表是全局可见的，你可以在任何标签中访问任何一个缓冲区。 返回主目录 :arrow_heading_up: 已激活、已载入、已列出、已命名的缓冲区用类似 vim file1 的命令启动 Vim 。这个文件的内容将会被加载到缓冲区中，你现在有一个已载入的缓冲区。如果你在 Vim 中保存这个文件，缓冲区内容将会被同步到磁盘上（写回文件中）。 由于这个缓冲区也在一个窗口上显示，所以他也是一个已激活的缓冲区。如果你现在通过 :e file2 命令加载另一个文件，file1 将会变成一个隐藏的缓冲区，并且 file2 变成已激活缓冲区。 使用 :ls 我们能够列出所有可以列出的缓冲区。插件缓冲区和帮助缓冲区通常被标记为不可以列出的缓冲区，因为那并不是你经常需要在编辑器中编辑的常规文件。通过 :ls! 命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区。 未命名的缓冲区是一种没有关联特定文件的缓冲区，这种缓冲区经常被插件使用。比如 :enew 将会创建一个无名临时缓冲区。添加一些文本然后使用 :w /tmp/foo 将他写入到磁盘，这样这个缓冲区就会变成一个已命名的缓冲区。 返回主目录 :arrow_heading_up: 参数列表全局缓冲区列表是 Vim 的特性。在这之前的 vi 中，仅仅只有参数列表，参数列表在 Vim 中依旧可以使用。 每一个通过 shell 命令传递给 Vim 的文件名都被记录在一个参数列表中。可以有多个参数列表：默认情况下所有参数都被放在全局参数列表下，但是你可以使用 :arglocal 命令去创建一个新的本地窗口的参数列表。 使用 :args 命令可以列出当前参数。使用 :next，:previous，:first，:last 命令可以在切换在参数列表中的文件。通过使用 :argadd，:argdelete 或者 :args 等命令加上一个文件列表可以改变参数列表。 偏爱缓冲区列表还是参数列表完全是个人选择，我的印象中大多数人都是使用缓冲区列表的。 然而参数列表在有些情况下被大量使用：批处理使用 :argdo！ 一个简单的重构例子： 12:args **/*.[ch]:argdo %s/foo/bar/ge | update 这条命令将替换掉当前目录下以及当前目录的子目录中所有的 C 源文件和头文件中的“foo”，并用“bar”代替。 相关帮助：:h argument-list 返回主目录 :arrow_heading_up: 按键映射使用 :map 命令家族你可以定义属于你自己的快捷键。该家族的每一个命令都限定在特定的模式下。从技术上来说 Vim 自带高达 12 中模式，其中 6 种可以被映射。另外一些命令作用于多种模式： 递归 非递归 模式 :map :noremap normal, visual, operator-pending :nmap :nnoremap normal :xmap :xnoremap visual :cmap :cnoremap command-line :omap :onoremap operator-pending :imap :inoremap insert 例如：这个自定义的快捷键只在普通模式下工作。 1:nmap &lt;space&gt; :echo &quot;foo&quot;&lt;cr&gt; 使用 :nunmap &lt;space&gt; 可以取消这个映射。 对于更少数，不常见的模式（或者他们的组合），查看 :h map-modes。 到现在为止还好，对新手而言有一个问题会困扰他们：:nmap 是递归执行的！结果是，右边执行可能的映射。 你自定义了一个简单的映射去输出“Foo”： 1:nmap b :echo &quot;Foo&quot;&lt;cr&gt; 但是如果你想要映射 b （回退一个单词）的默认功能到一个键上呢？ 1:nmap a b 如果你敲击a，我们期望着光标回退到上一个单词，但是实际情况是“Foo”被输出到命令行里！因为在右边，b 已经被映射到别的行为上了，换句话说就是 :echo &quot;Foo&quot;&lt;cr&gt;。 解决此问题的正确方法是使用一种 非递归 的映射代替： 1:nnoremap a b 经验法则：除非递归是必须的，否则总是使用非递归映射。 通过不给一个右值来检查你的映射。比如:nmap 显示所以普通模式下的映射，:nmap &lt;leader&gt; 显示所有以 &lt;leader&gt; 键开头的普通模式下的映射。 如果你想禁止用标准映射，把他们映射到特殊字符 &lt;nop&gt; 上，例如：:noremap &lt;left&gt; &lt;nop&gt;。 相关帮助： 123:h key-notation:h mapping:h 05.3 返回主目录 :arrow_heading_up: 映射前置键映射前置键（Leader 键）本身就是一个按键映射，默认为 \\。我们可以通过在 map 中调用 &lt;leader&gt; 来为把它添加到其他按键映射中。 1nnoremap &lt;leader&gt;h :helpgrep&lt;space&gt; 这样，我们只需要先按 \\ 然后连续按 \\h 就可以激活这个映射 :helpgrep&lt;space&gt;。如果你想通过先按 空格 键来触发，只需要这样做： 12let mapleader = &#x27; &#x27;nnoremap &lt;leader&gt;h :helpgrep&lt;space&gt; 另外，还有一个叫 &lt;localleader&gt; 的，可以把它理解为局部环境中的 &lt;leader&gt;，默认值依然为 \\。当我们需要只对某一个条件下（比如，特定文件类型的插件）的缓冲区设置特别的 &lt;leader&gt; 键，那么我们就可以通过修改当前环境下的 &lt;localleader&gt; 来实现。 注意：如果你打算设置 Leader 键，请确保在设置按键映射之前，先设置好 Leader 键。如果你先设置了含有 Leader 键的映射，然后又修改了 Leader 键，那么之前映射内的 Leader 键是不会因此而改变的。你可以通过执行 :nmap &lt;leader&gt; 来查看普通模式中已绑定给 Leader 键的所有映射。 请参阅 :h mapleader 与 :h maploacalleader 来获取更多帮助。 返回主目录 :arrow_heading_up: 寄存器寄存器就是存储文本的地方。我们常用的「复制」操作就是把文本存储到寄存器，「 粘贴」 操作就是把文本从寄存器中读出来。顺便，在 Vim 中复制的快捷键是 y，粘贴的快捷键是 p。 Vim 为我们提供了如下的寄存器： 类型 标识 读写者 是否为只读 包含的字符来源 Unnamed &quot; vim 否 最近一次的复制或删除操作 (d, c, s, x, y) Numbered 0至9 vim 否 寄存器 0: 最近一次复制。寄存器 1: 最近一次删除。寄存器 2: 倒数第二次删除，以此类推。对于寄存器 1 至 9，他们其实是只读的最多包含 9 个元素的队列。这里的队列即为数据类型 queue Small delete - vim 否 最近一次行内删除 Named a至z, A至Z 用户 否 如果你通过复制操作存储文本至寄存器 a，那么 a 中的文本就会被完全覆盖。如果你存储至 A，那么会将文本添加给寄存器 a，不会覆盖之前已有的文本 Read-only :与.和% vim 是 :: 最近一次使用的命令，.: 最近一次添加的文本，%: 当前的文件名 Alternate buffer # vim 否 大部分情况下，这个寄存器是当前窗口中，上一次访问的缓冲区。请参阅 :h alternate-file 来获取更多帮助 Expression = 用户 否 复制 VimL 代码时，这个寄存器用于存储代码片段的执行结果。比如，在插入模式下复制 &lt;c-r&gt;=5+5&lt;cr&gt;，那么这个寄存器就会存入 10 Selection +和* vim 否 * 和 + 是 剪贴板 寄存器 Drop ~ vim 是 最后一次拖拽添加至 Vim 的文本（需要 “+dnd” 支持，暂时只支持 GTK GUI。请参阅 :help dnd 及 :help quote~） Black hole _ vim 否 一般称为黑洞寄存器。对于当前操作，如果你不希望在其他寄存器中保留文本，那就在命令前加上 _。比如，&quot;_dd 命令不会将文本放到寄存器 &quot;、1、+ 或 * 中 Last search pattern / vim 否 最近一次通过 /、? 或 :global 等命令调用的匹配条件 只要不是只读的寄存器，用户都有权限修改它的内容，比如： 1:let @/ = &#x27;register&#x27; 这样，我们按 n 的时候就会跳转到单词”register” 出现的地方。 有些时候，你的操作可能已经修改了寄存器，而你没有察觉到。请参阅 :h registers 获取更多帮助。 上面提到过，复制的命令是 y，粘贴的命令是 p 或者 P。但请注意，Vim 会区分「字符选取」与「行选取」。请参阅 :h linewise 获取更多帮助。 行选取：命令 yy 或 Y 都是复制当前行。这时移动光标至其他位置，按下 p 就可以在光标下方粘贴复制的行，按下 P 就可以在光标上方粘贴至复制的行。 字符选取：命令 0yw 可以复制第一个单词。这时移动光标至其他位置，按下 p 就可以在当前行、光标后的位置粘贴单词，按下 P 就可以在当前行、光标前的位置粘贴单词。 将文本存到指定的寄存器中：命令 &quot;aY 可以将当前行复制，并存储到寄存器 a 中。这时移动光标至其他位置，通过命令 &quot;AY 就可以把这一行的内容扩展到寄存器 a 中，而之前存储的内容也不会丢失。 为了便于理解和记忆，建议大家现在就试一试上面提到的这些操作。操作过程中，你可以随时通过 :reg 来查看寄存器的变化。 有趣的是：在 Vim 中，y 是复制命令，源于单词 “yanking”。而在 Emacs 中，”yanking” 代表的是粘贴（或者说，重新插入刚才删掉的内容），而并不是复制。 返回主目录 :arrow_heading_up: 范围范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。 很多命令都可以加一个数字，用于指明操作范围 范围可以是一个行号，用于指定某一行 范围也可以是一对通过 , 或 ; 分割的行号 大部分命令，默认只作用于当前行 只有 :write 和 :global 是默认作用于所有行的 范围的使用是十分直观的。以下为一些例子（其中，:d 为 :delete 的缩写）： 命令 操作的行 :d 当前行 :.d 当前行 :1d 第一行 :$d 最后一行 :1,$d 所有行 :%d 所有行（这是 1,$ 的语法糖） :.,5d 当前行至第 5 行 :,5d 同样是当前行至第 5 行 :,+3d 当前行及接下来的 3 行 :1,+3d 第一行至当前行再加 3 行 :,-3d 当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围） :3,&#39;xdelete 第三行至标注 为 x 的那一行 :/^foo/,$delete 当前行以下，以字符 “foo” 开头的那一行至结尾 :/^foo/+1,$delete 当前行以下，以字符 “foo” 开头的那一行的下一行至结尾 需要注意的是，; 也可以用于表示范围。区别在于，a,b 的 b 是以当前行作为参考的。而 a;b 的 b 是以 a 行作为参考的。举个例子，现在你的光标在第 5 行。这时 :1,+1d 会删除第 1 行至第 6 行，而 :1;+1d 会删除第 1 行和第 2 行。 如果你想设置多个寻找条件，只需要在条件前加上 /，比如： 1:/foo//bar//quux/d 这就会删除当前行之后的某一行。定位方式是，先在当前行之后寻找第一个包含 “foo” 字符的那一行，然后在找到的这一行之后寻找第一个包含 “bar” 字符的那一行，然后再在找到的这一行之后寻找第一个包含 “quux” 的那一行。删除的就是最后找到的这一行。 有时，Vim 会在命令前自动添加范围。举个例子，如果你先通过 V 命令进入行选取模式，选中一些行后按下 : 进入命令模式，这时候你会发现 Vim 自动添加了 &#39;&lt;,&#39;&gt; 范围。这表示，接下来的命令会使用之前选取的行号作为范围。但如果后续命令不支持范围，Vim 就会报错。为了避免这样的情况发生，有些人会设置这样的按键映射：:vnoremap foo :&lt;c-u&gt;command，组合键 Ctrl + u 可以清除当前命令行中的内容。 另一个例子是在普通模式中按下 !!，命令行中会出现 :.!。如果这时你如果输入一个外部命令，那么当前行的内容就会被这个外部命令的输出替换。你也可以通过命令 :?^$?+1,/^$/-1!ls 把当前段落的内容替换成外部命令 ls 的输出，原理是向前和向后各搜索一个空白行，删除这两个空白行之间的内容，并将外部命令 ls 的输出放到这两个空白行之间。 请参阅以下两个命令来获取更多帮助： 12:h cmdline-ranges:h 10.3 返回主目录 :arrow_heading_up: 标注你可以使用标注功能来标记一个位置，也就是记录文件某行的某个位置。 标注 设置者 使用 a-z 用户 仅对当前的一个文件生效，也就意味着只可以在当前文件中跳转 A-Z 用户 全局标注，可以作用于不同文件。大写标注也称为「文件标注」。跳转时有可能会切换到另一个缓冲区 0-9 viminfo 0 代表 viminfo 最后一次被写入的位置。实际使用中，就代表 Vim 进程最后一次结束的位置。1 代表 Vim 进程倒数第二次结束的位置，以此类推 如果想跳转到指定的标注，你可以先按下 &#39; &#x2F; g&#39; 或者 ` &#x2F; g` 然后按下标注名。 如果你想定义当前文件中的标注，可以先按下 m 再按下标注名。比如，按下 mm 就可以把当前位置标注为 m。在这之后，如果你的光标切换到了文件的其他位置，只需要通过 &#39;m 或者 `m即可回到刚才标注的行。区别在于，&#39;m会跳转回被标记行的第一个非空字符，而`m会跳转回被标记行的被标记列。根据 viminfo 的设置，你可以在退出 Vim 的时候保留小写字符标注。请参阅:h viminfo-&#39; 来获取更多帮助。 如果你想定义全局的标注，可以先按下 m 再按下大写英文字符。比如，按下 mM 就可以把当前文件的当前位置标注为 M。在这之后，就算你切换到其他的缓冲区，依然可以通过 &#39;M 或 `M 跳转回来。 关于跳转，还有以下的方式： 按键 跳转至 &#39;[ 与 `[ 上一次修改或复制的第一行或第一个字符 &#39;] 与 `] 上一次修改或复制的最后一行或最后一个字符 &#39;&lt; 与 `&lt; 上一次在可视模式下选取的第一行或第一个字符 &#39;&gt; 与 `&gt; 上一次在可视模式下选取的最后一行或最后一个字符 &#39;&#39; 与 `&#39; 上一次跳转之前的光标位置 &#39;&quot; 与 `&quot; 上一次关闭当前缓冲区时的光标位置 &#39;^ 与 `^ 上一次插入字符后的光标位置 &#39;. 与 `. 上一次修改文本后的光标位置 &#39;( 与 `( 当前句子的开头 &#39;) 与 `) 当前句子的结尾 &#39;&#123; 与 `&#123; 当前段落的开头 &#39;&#125; 与 `&#125; 当前段落的结尾 标注也可以搭配 范围 一起使用。前面提到过，如果你在可视模式下选取一些文本，然后按下 :，这时候你会发现命令行已经被填充了 :&#39;&lt;,&#39;&gt;。对照上面的表格，现在你应该明白了，这段代表的就是可视模式下选取的范围。 请使用 :marks 命令来显示所有的标注，参阅 :h mark-motions 来获取关于标注的更多帮助。 返回主目录 :arrow_heading_up: 补全Vim 在插入模式中为我们提供了多种补全方案。如果有多个补全结果，Vim 会弹出一个菜单供你选择。 常见的补全有标签、项目中引入的模块或库中的方法名、文件名、字典及当前缓冲区的字段。 针对不同的补全方案，Vim 为我们提供了不同的按键映射。这些映射都是在插入模式中通过 Ctrl + x 来触发： 映射 类型 帮助文档 &lt;c-x&gt;&lt;c-l&gt; 整行 :h i^x^l &lt;c-x&gt;&lt;c-n&gt; 当前缓冲区中的关键字 :h i^x^n &lt;c-x&gt;&lt;c-k&gt; 字典（请参阅 :h &#39;dictionary&#39;）中的关键字 :h i^x^k &lt;c-x&gt;&lt;c-t&gt; 同义词字典（请参阅 :h &#39;thesaurus&#39;）中的关键字 :h i^x^t &lt;c-x&gt;&lt;c-i&gt; 当前文件以及包含的文件中的关键字 :h i^x^i &lt;c-x&gt;&lt;c-]&gt; 标签 :h i^x^] &lt;c-x&gt;&lt;c-f&gt; 文件名 :h i^x^f &lt;c-x&gt;&lt;c-d&gt; 定义或宏定义 :h i^x^d &lt;c-x&gt;&lt;c-v&gt; Vim 命令 :h i^x^v &lt;c-x&gt;&lt;c-u&gt; 用户自定义补全（通过 &#39;completefunc&#39; 定义） :h i^x^u &lt;c-x&gt;&lt;c-o&gt; Omni Completion（通过 &#39;omnifunc&#39; 定义） :h i^x^o &lt;c-x&gt;s 拼写建议 :h i^Xs 尽管用户自定义补全与 Omni Completion 是不同的，但他们做的事情基本一致。共同点在于，他们都是一个监听当前光标位置的函数，返回值为一系列的补全建议。用户自定义补全是由用户定义的，基于用户的个人用途，因此你可以根据自己的喜好和需求随意定制。而 Omni Completion 是针对文件类型的补全，比如在 C 语言中补全一个结构体（struct）的成员（members），或者补全一个类的方法，因而它通常都是由文件类型插件设置和调用的。 如果你设置了 &#39;complete&#39; 选项，那么你就可以在一次操作中采用多种补全方案。这个选项默认包含了多种可能性，因此请按照自己的需求来配置。你可以通过 &lt;c-n&gt; 来调用下一个补全建议，或通过 &lt;c-p&gt; 来调用上一个补全建议。当然，这两个映射同样可以直接调用补全函数。请参阅 :h i^n 与 :h &#39;complete&#39; 来获得更多帮助。 如果你想配置弹出菜单的行为，请一定要看一看 :h &#39;completeopt&#39; 这篇帮助文档。默认的配置已经不错了，但我个人（原作者）更倾向于把 “noselect” 加上。 请参阅以下文档获取更多帮助： 123:h ins-completion:h popupmenu-keys:h new-omni-completion 返回主目录 :arrow_heading_up: 动作，操作符，文本对象动作也就是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。他们都可以搭配数字使用，比如 2?the&lt;cr&gt; 可以将光标移动到倒数第二个 “the” 出现的位置。 以下会列出一些常用的动作。你也可以通过 :h navigation 来获取更多的帮助。 操作符是对某个区域文本执行的操作。比如，d、~、gU 和 &gt; 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。在普通模式中，顺序是先按操作符，再按动作指令，比如 &gt;j。在可视模式中，选中区域后直接按操作符就可以，比如 Vjd。 与动作一样，操作符也可以搭配数字使用，比如 2gUw 可以将当前单词以及下一个单词转成大写。由于动作和操作符都可以搭配数字使用，因此 2gU2w 与执行两次 gU2w 效果是相同的。 请参阅 :h operator 来查看所有的操作符。你也可以通过 :set tildeop 命令把 ~ 也变成一个操作符 值得注意的是，动作是单向的，而文本对象是双向的。文本对象不仅作用于符号（比如括号、中括号和大括号等）标记的范围内，也作用于整个单词、整个句子等其他情况。 文本对象不能用于普通模式中移动光标的操作，因为光标还没有智能到可以向两个方向同时跳转。但这个功能可以在可视模式中实现，因为在对象的一端选中的情况下，光标只需要跳转到另一端就可以了。 文本对象操作一般用 i 或 a 加上对象标识符操作，其中 i 表示在对象内（英文 inner）操作，a 表示对整个对象（英文 around）操作，这时开头和结尾的空格都会被考虑进来。举个例子，diw 可以删除当前单词，ci( 可以改变括号中的内容。 文本对象同样可以与数字搭配使用。比如，像 ((( ))) 这样的文本，假如光标位于最内层的括号上或最内层的括号内，那么 d2a( 将会删除从最内层开始的两对括号，以及他们之间的所有内容。其实，d2a( 这个操作等同于 2da(。在 Vim 的命令中，如果有两处都可以接收数字作为参数，那么最终结果就等同于两个数字相乘。在这里，d 与 a( 都是可以接收参数的，一个参数是 1，另一个是 2，我们可以把它们相乘然后放到最前面。 请参阅 :h text-objects 来获取更多关于文本对象的帮助。 返回主目录 :arrow_heading_up: 自动命令在特定的情况下，Vim 会传出事件。如果你想针对这些事件执行回调方法，那么就需要用到自动命令这个功能。 如果没有了自动命令，那你基本上是用不了 Vim 的。自动命令一直都在执行，只是很多时候你没有注意到。不信的话，可以执行命令 :au ，不要被结果吓到，这些是当前有效的所有自动命令。 请使用 :h &#123;event&#125; 来查看 Vim 中所有事件的列表，你也可以参考 :h autocmd-events-abc 来获取关于事件的更多帮助。 一个很常用的例子，就是针对文件类型执行某些设置： 1autocmd FileType ruby setlocal shiftwidth=2 softtabstop=2 comments-=:# 但是缓冲区是如何知道当前的文件中包含 Ruby 代码呢？这其实是另一个自动命令检测的到的，然后把文件类型设置成为 Ruby，这样就触发了上面的 FileType 事件。 在配置 vimrc 的时候，一般第一行加进去的就是 filetype on。这就意味着，Vim 启动时会读取 filetype.vim 文件，然后根据文件类型来触发相应的自动命令。 如果你勇于尝试，可以查看下 :e $VIMRUNTIME/filetype.vim，然后在输出中搜索 “Ruby”。这样，你就会发现其实 Vim 只是通过文件扩展名 .rb 判断某个文件是不是 Ruby 的。 注意：对于相同事件，如果有多个自动命令，那么自动命令会按照定义时的顺序执行。通过 :au 就可以查看它们的执行顺序。 1au BufNewFile,BufRead *.rb,*.rbw setf ruby BufNewFile 与 BufRead 事件是被写在 Vim 源文件中的。因此，每当你通过 :e 或者类似的命令打开文件，这两个事件都会触发。然后，就是读取 filetype.vim 文件来判断打开的文件类型。 简单来说，事件和自动命令在 Vim 中的应用十分广泛。而且，Vim 为我们留出了一些易用的接口，方便用户配置适合自己的事件驱动回调。 请参阅 :h autocommand 来获取更多帮助 返回主目录 :arrow_heading_up: 变更历史，跳转历史在 Vim 中，用户最近 100 次的文字改动都会被保存在变更历史中。如果在同一行有多个小改动，那么 Vim 会把它们合并成一个。尽管内容改动会合并，但作用的位置还是会只记录下最后一次改动的位置。 在你移动光标或跳转的时候，每一次的移动或跳转前的位置会被记录到跳转历史中。类似地，跳转历史也可以最多保存 100 条记录。对于每个窗口，跳转记录是独立的。但当你分离窗口时（比如使用 :split 命令），跳转历史会被复制过去。 Vim 中的跳转命令，包括 &#39;、`、G、/、?、n、N、%、(、)、[[、]]、&#123;、&#125;、:s、:tag、L、M、H 以及开始编辑一个新文件的命令。 列表 显示所有条目 跳转到上一个位置 跳转到下一个位置 跳转历史 :jumps [count]&lt;c-o&gt; [count]&lt;c-i&gt; 变更历史 :changes [count]g; [count]g, 如果你执行第二列的命令显示所有条目，这时 Vim 会用 &gt; 标记来为你指示当前位置。通常这个标记位于 1 的下方，也就代表最后一次的位置。 如果你希望关闭 Vim 之后还保留这些条目，请参阅 :h viminfo-&#39; 来获取更多帮助。 注意：上面提到过，最后一次跳转前的位置也会记录在标注中，也可以通过连按 `` 或 '' 跳转到那个位置 请参阅以下两个命令来获取更多帮助： 12:h changelist:h jumplist 返回主目录 :arrow_heading_up: 内容变更历史记录Vim 会记录文本改变之前的状态。因此，你可以使用「撤销」操作 u 来取消更改，也可以通过「重做」操作 Ctrl + r 来恢复更改。 值得注意的是，Vim 采用 tree 数据结构来存储内容变更的历史记录，而不是采用 queue。你的每次改动都会成为存储为树的节点。而且，除了第一次改动（根节点），之后的每次改动都可以找到一个对应的父节点。每一个节点都会记录改动的内容和时间。其中，「分支」代表从任一节点到根节点的路径。当你进行了撤销操作，然后又输入了新的内容，这时候就相当于创建了分支。这个原理和 git 中的 branch（分支）十分类似。 考虑以下这一系列按键操作： 12345ifoo&lt;esc&gt;obar&lt;esc&gt;obaz&lt;esc&gt;uoquux&lt;exc&gt; 那么现在，Vim 中会显示三行文本，分别是 “foo”、”bar” 和 “quux”。这时候，存储的树形结构如下： foo(1) / bar(2) / \\ baz(3) quux(4) 这个树形结构共包含四次改动，括号中的数字就代表时间顺序。 现在，我们有两种方式遍历这个树结构。一种叫「按分支遍历」，一种叫「按时间遍历」。 撤销 u 与重做 Ctrl + r 操作是按分支遍历。对于上面的例子，现在我们有三行字符。这时候按 u 会回退到 “bar” 节点，如果再按一次 u 则会回退到 “foo” 节点。这时，如果我们按下 Ctrl + r 就会前进至 “bar” 节点，再按一次就回前进至 “quux” 节点。在这种方式下，我们无法访问到兄弟节点（即 “baz” 节点）。 与之对应的是按时间遍历，对应的按键是 g- 和 g+。对于上面的例子，按下 g- 会首先回退到 “baz” 节点。再次按下 g- 会回退到 “bar” 节点。 命令&#x2F;按键 执行效果 [count]u 或 :undo [count] 回退到 [count] 次改动之前 [count]&lt;c-r&gt; 或 :redo [count] 重做 [count] 次改动 U 回退至最新的改动 [count]g- 或 :earlier [count]? 根据时间回退到 [count] 次改动之前。”?” 为 “s”、”m”、”h”、”d” 或 “f”之一。例如，:earlier 2d 会回退到两天之前。:earlier 1f 则会回退到最近一次文件保存时的内容 [count]g+ 或 :later [count]? 类似 g-，但方向相反 内容变更记录会储存在内存中，当 Vim 退出时就会清空。如果需要持久化存储内容变更记录，请参阅备份文件，交换文件，撤销文件以及 viminfo 文件的处理章节的内容。 如果你觉得这一部分的内容难以理解，请参阅 undotree，这是一个可视化管理内容变更历史记录的插件。类似的还有 vim-mundo。 请参阅以下链接获取更多帮助： 12:h undo.txt:h usr_32 返回主目录 :arrow_heading_up: 全局位置信息表，局部位置信息表在某一个动作返回一系列「位置」的时候，我们可以利用「全局位置信息表」和「局部位置信息表」来存储这些位置信息，方便以后跳转回对应的位置。每一个存储的位置包括文件名、行号和列号。 比如，编译代码是出现错误，这时候我们就可以把错误的位置直接显示在全局位置信息表，或者通过外部抓取工具使位置显示在局部位置信息表中。 尽管我们也可以把这些信息显示到一个空格缓冲区中，但用这两个信息表显示的好处在于接口调用很方便，而且也便于浏览输出。 Vim 中，全局位置信息表只能有一个，但每一个窗口都可以有自己的局部位置信息表。这两个信息表的外观看上去很类似，但在操作上会稍有不同。 以下为两者的操作比较： 动作 全局位置信息表 局部位置信息表 打开窗口 :copen :lopen 关闭窗口 :cclose :lclose 下一个条目 :cnext :lnext 上一个条目 :cprevious :lprevious 第一个条目 :cfirst :lfirst 最后一个条目 :clast :llast 请参阅 :h :cc 以及底下的内容，来获取更多命令的帮助。 应用实例：如果我们想用 grep 递归地在当前文件夹中寻找某个关键词，然后把输出结果放到全局位置信息表中，只需要这样： 1234:let &amp;grepprg = &#x27;grep -Rn $* .&#x27;:grep! foo&lt;grep output - hit enter&gt;:copen 执行了上面的代码，你就能看到所有包含字符串 “foo” 的文件名以及匹配到的相关字段都会显示在全局位置信息表中。 返回主目录 :arrow_heading_up: 宏你可以在 Vim 中录制一系列按键，并把他们存储到寄存器中。对于一些需要临时使用多次的一系列操作，把它们作为宏保存起来会显著地提升效率。对于一些复杂的操作，建议使用 Vim 脚本来实现。 首先，按下 q，然后按下你想要保存的寄存器，任何小写字母都可以。比如我们来把它保存到 q 这个寄存器中。按下 qq，你会发现命令行里已经显示了 “recording @q”。 如果你已经录制完成，那么只需要再按一次 q 就可以结束录制。 如果你想调用刚才录制的宏，只需要 [count]@q 如果你想调用上一次使用的宏，只需要 [count]@@ 实例 1： 一个插入字符串 “abc” 后换行的宏，重复调用十次： 1234qqiabc&lt;cr&gt;&lt;esc&gt;q10@q （对于上面这个功能，你同样可以通过如下的按键： oabc 然后 ESC 然后 10. 来实现）。 实例 2： 一个在每行前都加上行号的宏。从第一行开始，行号为 1，后面依次递增。我们可以通过 Ctrl + a 来实现递增的行号，在定义宏的时候，它会显示成 ^A。 1234qq0yf jP0^Aq1000 @q 这里能实现功能，是因为我们假定了文件最多只有 1000 行。但更好的方式是使用「递归」宏，它会一直执行，知道不能执行为止： 1234qq0yf jP0^A@qq@q （对于上面这个插入行号的功能，如果你不愿意使用宏，同样可以通过这段按键操作来实现：:%s/^/\\=line(&#39;.&#39;) . &#39;. &#39;）。 这里向大家展示了如何不用宏来达到相应的效果，但要注意，这些不用宏的实现方式只适用于这些简单的示例。对于一些比较复杂的自动化操作，你确实应该考虑使用宏。 请参阅以下文档获取更多帮助： 12:h recording:h &#x27;lazyredraw&#x27; 返回主目录 :arrow_heading_up: 颜色主题颜色主题可以把你的 Vim 变得更漂亮。Vim 是由多个组件构成的，我们可以给每一个组件都设置不同的文字颜色、背景颜色以及文字加粗等等。比如，我们可以通过这个命令来设置背景颜色： 1:highlight Normal ctermbg=1 guibg=red 执行后你会发现，现在背景颜色变成红色了。请参阅 :h :highlight 来获取更多帮助。 其实，颜色主题就是一系列的 :highlight 命令的集合。 事实上，大部分颜色主题都包含两套配置。一套适用于例如 xterm 和 iTerm 这样的终端环境（使用前缀 cterm），另一套适用于例如 gvim 和 MacVim 的图形界面环境（使用前缀 gui）。对于上面的例子，ctermbg 就是针对终端环境的，而 guibg 就是针对图形界面环境的。 如果你下载了一个颜色主题，并且在终端环境中打开了 Vim，然后发现显示的颜色与主题截图中差别很大，那很可能是配置文件只设置了图形界面环境的颜色。反之同理，如果你使用的是图形界面环境，发现显示颜色有问题，那就很可能是配置文件只设置了终端环境的颜色。 第二种情况（图形界面环境的显示问题）其实不难解决。如果你使用的是 Neovim 或者 Vim 7.4.1830 的后续版本，可以通过打开真彩色设置来解决显示问题。这就可以让终端环境的 Vim 使用 GUI 的颜色定义，但首先，你要确认一下你的终端环境和环境内的组件（比如 tmux）是否都支持真彩色。可以看一下这篇文档，描述的十分详细。 请参阅以下文档或链接来获取更多帮助： :h &#39;termguicolors&#39; 主题列表 自定义主题中的颜色 返回主目录 :arrow_heading_up: 折叠每一部分文字（或者代码）都会有特定的结构。对于存在结构的文字和代码，也就意味着它们可以按照一定的逻辑分割成不同区域。Vim 中的折叠功能，就是按照特定的逻辑把文字和代码折叠成一行，并显示一些简短的描述。折叠功能涉及到很多操作，而且折叠功能可以嵌套使用。 在 Vim 中，有以下 6 中折叠类型： 折叠方式 概述 diff 在「比较窗口」中折叠未改变的文本 expr 使用 &#39;foldexpr&#39; 来创建新的折叠逻辑 indent 基于缩进折叠 manual 使用 zf、zF 或 :fold 来自定义折叠 marker 根据特定的文本标记折叠（通常用于代码注释） syntax 根据语法折叠，比如折叠 if 代码块 注意：折叠功能可能会显著地影响性能。如果你在使用折叠功能的时候出现了打字卡顿之类的问题，请考虑使用 FastFold 插件。这个插件可以让 Vim 按需更新折叠内容，而不是一直调用。 请参阅以下文档获取更多帮助： 12:h usr_28:h folds 会话如果你保存了当前的「视图」（请参阅 :h :mkview），那么当前窗口、配置和按键映射都会被保存下来（请参阅 :h :loadview）。 「会话」就是存储所有窗口的相关设置，以及全局设置。简单来说，就是给当前的 Vim 运行实例拍个照，然后把相关信息存储到会话文件中。存储之后的改动就不会在会话文件中显示，你只需要在改动后更新一下会话文件就可以了。 你可以把当前工作的「项目」存储起来，然后可以在不同的「项目」之间切换。 现在就来试试吧。打开几个窗口和标签，然后执行 :mksession Foo.vim。如果你没有指定文件名，那就会默认保存为 Session.vim。这个文件会保存在当前的目录下，你可以通过 :pwd 来显示当前路径。重启 Vim 之后，你只需要执行 :source Foo.vim，就可以恢复刚才的会话了。所有的缓冲区、窗口布局、按键映射以及工作路径都会恢复到保存时的状态。 其实 Vim 的会话文件就只是 Vim 命令的集合。你可以通过命令 :vs Foo.vim 来看看会话文件中究竟有什么。 你可以决定 Vim 会话中究竟要保存哪些配置，只需要设置一下 &#39;sessionoptions&#39; 就可以了。 为了方便开发，Vim 把最后一次调用或写入的会话赋值给了一个内部变量 v:this_session。 请参阅以下文档来获取更多帮助： 123:h Session:h &#x27;sessionoptions&#x27;:h v:this_session 局部化以上提到的很多概念，都有一个局部化（非全局）的版本： 全局 局部 作用域 帮助文档 :set :setlocal 缓冲区或窗口 :h local-options :map :map &lt;buffer&gt; 缓冲区 :h :map-local :autocmd :autocmd * &lt;buffer&gt; 缓冲区 :h autocmd-buflocal :cd :lcd 窗口 :h :lcd :&lt;leader&gt; :&lt;localleader&gt; 缓冲区 :h maploacalleader 变量也有不同的作用域，详细内容请参考 Vim scripting 的文档。 用法获取离线帮助Vim 自带了一套很完善的帮助文档，它们是一个个有固定排版格式的文本文件，通过标签可以访问这些文件的特定位置。 在开始之前先读一下这个章节：:help :help。执行这个命令以后会在新窗口打开 $VIMRUNTIME/doc/helphelp.txt 文件并跳转到这个文件中 :help 标签的位置。 一些关于帮助主题的简单规则： 用单引号把文本包起来表示选项，如：:h &#39;textwidth&#39; 以小括号结尾表示 VimL 函数，如：:h reverse() 以英文冒号开头表示命令，如：:h :echo 使用快捷键 &lt;c-d&gt; （这是 ctrl+d）来列出所有包含你当前输入的内容的帮助主题。如：:h tab&lt;c-d&gt; 会列出所有包含 tab 主题，从 softtabstop 到 setting-guitablabel （译者注：根据安装的插件不同列出的选项也会不同）。 你想查看所有的 VimL 方法吗？很简单，只要输入：:h ()&lt;c-d&gt; 就可以了。你想查看所有与窗口相关的函数吗？输入 :h win*()&lt;c-d&gt;。 相信你很快就能掌握这些技巧，但是在刚开始的时候，你可能对于该通过什么进行查找一点线索都没有。这时你可以想象一些与要查找的内容相关的关键字，再让 :helpgrep 来帮忙。 1:helpgrep backwards 上面的命令会在所有的帮助文件中搜索“backwards”，然后跳转到第一个匹配的位置。所有的匹配位置都会被添加到全局位置信息表，用 :cp / :cn 可以在匹配位置之间进行切换。或者用 :copen 命令来打开全局位置信息表，将光标定位到你想要的位置，再按 回车就可以跳转到该匹配项。详细说明请参考 :h quickfix。 获取离线帮助（补充）这个列表最初发表在 vim_dev，由 @chrisbra 编辑的，他是 Vim 开发人员中最活跃的一个。 经过一些微小的改动后，重新发布到了这里。 如果你知道你想要找什么，使用帮助系统的搜索会更简单一些，因为搜索出的主题都带有固定的格式。 而且帮助系统中的主题包含了你当前使用的 Vim 版本的所特有特性，而网上那些已经过时或者是早期发布的话题是不会包含这些的。 因此学习使用帮助系统以及它所用的语言是很有必要的。这里是一些例子（不一定全，我有可能忘了一些什么）。 （译者注：下面列表中提及的都是如何指定搜索主题以便快速准确的找到你想要的帮助） 选项要用单引号引起来。用 :h &#39;list&#39; 来查看列表选项帮助。只有你明确的知道你要找这么一个选项的时候才可以这么做，不然的话你可以用 :h options.txt 来打开所有选项的帮助页面，再用正则表达式进行搜索，如：/width。某些选项有它们自己的命名空间，如：:h cpo-a，:h cpo-A， :h cpo-b 等等。 普通模式的命令不能用冒号作为前缀。使用 :h gt 来转到“gt”命令的帮助页面。 正则表达式以“&#x2F;”开头，所以 :h /\\+ 会带你到正则表达式中量词“+”的帮助页面。 组合键经常以一个字母开头表示它们可以在哪些模式中使用。如：:h i_CTRL-X 会带你到插入模式下的 CTRL-X 命令的用法帮助页面，这是一个自动完成类的组合键。需要注意的是某些键是有固定写法的，如 Control 键写成 CTRL。还有，查找普通模式下的组合键帮助时，可以省略开头的字母“n”，如：:h CTRL-A。而 :h c_CTRL-A（译者注：原文为 :h c_CRTL-R，感觉改为 A 更符合上下文语境）会解释 CTRL-A 在命令模式下输入命令时的作用；:h v_CTRL-A 说的是在可见模式下把光标所在处的数字加 1；:h g_CTRL-A 则说的是 g 命令（你需要先按 “g” 的命令）。这里的 “g” 代表一个普通的命令，这个命令总是与其它的按键组合使用才生效，与 “z” 开始的命令相似。 寄存器是以 “quote” 开头的。如：:h quote: （译者注：原文为:h quote，感觉作者想以”:”来举例）来查看关于”:”寄存器的说明。 关于 Vim 脚本（VimL）的帮助都在 :h eval.txt 里。而某些方面的语言可以使用 :h expr-X 获取帮助，其中的 ‘X’ 是一个特定的字符，如：:h expr-! 会跳转到描述 VimL 中’!’（非）的章节。另外一个重要提示，可以使用 :h function-list 来查看所有函数的简要描述，列表中包括函数名和一句话描述。 关于映射都可以在 :h map.txt 中找到。通过 :h mapmode-i 来查找 :imap 命令的相关信息；通过 :h map-topic 来查找专门针对映射的帮助（译者注：topic 为一个占位符，正如上面的字符 ‘X’ 一样，在实际使用中需要替换成相应的单词）（如：:h :map-local 查询本地 buffer 的映射，:h map-bar 查询如何在映射中处理’|’)。 命令定义用 “command-“ 开头，如用 :h command-bar 来查看自定义命令中’!’的作用。 窗口管理类的命令是以 “CTRL-W” 开头的，所以你可以用 :h CTRL-W_* 来查找相应的帮助（译者注：’*‘同样为占位符）（如：:h CTRL-W_p 查看切换到之前访问的窗口命令的解释）。如果你想找窗口处理的命令，还可以通过访问 :h windows.txt 并逐行向下浏览，所有窗口管理的命令都在这里了。 执行类的命令以”:”开头，即：:h :s 讲的是 “:s” 命令。 在输入某个话题时按 CTRL-D，让 Vim 列出所有的近似项辅助你输入。 用 :helpgrep 在所有的帮助页面（通常还包括了已安装的插件的帮助页面）中进行搜索。参考 :h :helpgrep 来了解如何使用。当你搜索了一个话题之后，所有的匹配结果都被保存到了全局位置信息表（或局部位置信息表）当中，可以通过 :copen 或 :lopen 打开。在打开的窗口中可能通过 / 对搜索结果进行进一步的过滤。 :h helphelp 里介绍了如何使用帮助系统。 用户手册。它采用了一种对初学者更加友好的方式来展示帮助话题。用 :h usr_toc.txt 打开目录（你可能已经猜到这个命令的用处了）。浏览用户手册能帮助你找出某些你想了解的话题，如你可以在第 24 章看到关于“复合字符”以及“输入特殊字符”的讲解（用 :h usr_24.txt 可以快速打开相关章节）。 高亮分组的帮助以 hl- 开头。如：:h hl-WarningMsg 说的是警告信息分组的高亮。 语法高亮以:syc- 开头，如：:h :syn-conceal 讲的是 :syn 命令的对于隐藏字符是如何显示的。 快速修复命令以 :c 开头，而位置列表命令以 :l 开头。 :h BufWinLeave 讲的是 BufWinLeave 自动命令。还有，:h autocommand-events （译者注：原文是 :h autocommands-events，但是没有该帮助）讲的是所有可用的事件。 启动参数都以“-”开头，如：:h -f 会告诉你 Vim 中 “-f” 参数的作用。 额外的特性都以“+”开头，如：:h +conceal 讲的是关于隐藏字符的支持。 错误代码可以在帮助系统中直接查到。:h E297 会带你到关于这一错误的详细解释。但是有时并没有转到错误描述，而是列出了经常导出这一错误的 Vim 命令，如 :h E128 （译者注：原文为:h hE128，但是并没有该帮助）会直接跳转到 :function 命令。 关于包含的语法文件的文档的帮助话题格式是 :h ft-*-syntax。如：:h ft-c-syntax 说的就是 C 语言语法文件以及它所提供的选项。有的语法文件还会带有自动完成（:h ft-php-omni）或文件类型插件（:h ft-tex-plugin）相关的章节可以查看。 另外在每个帮助页的顶端通常会包含一个用户文档链接（更多的从从用户的角度出发来主角命令的功能和用法，不涉及那么多细节）。如：:h pattern.txt 里包含了 :h 03.9 和 :h usr_27 两个章节的链接。 获取在线帮助如果你遇到了无法解决的问题，或者需要指引的话，可以参考 Vim 使用邮件列表。 IRC 也是一个很不错的资源。 Freenode 上的 #vim 频道很庞大，并且里面有许多乐于助人的人。 如果你想给 Vim 提交 Bug 的话，可以使用 vim_dev 邮件列表。 执行自动命令你可以触发任何事件，如：:doautocmd BufRead。 用户自定义事件对于插件而言，创建你自己的自定义事件有时非常有用。 12345function! Chibby() &quot; A lot of stuff is happening here. &quot; And at last.. doautocmd User ChibbyExitendfunction 现在你插件的用户可以在 Chibby 执行完成之后做任何他想做的事情： 1autocmd User ChibbyExit call ChibbyCleanup() 顺便提一句，如果在使用 :autocmd 或 :doautocmd 时没有捕捉异常，那么会输出 “No matching autocommands” 信息。这也是为什么许多插件用 silent doautocmd ... 的原因。但是这也会有不足，那就是你不能再在 :autocmd 中使用 echo &quot;foo&quot; 了，取而代之的是你要使用 unsilent echo &quot;foo&quot; 来输出。 这就是为什么要在触发事件之前先判断事件是否存在的原因， 123if exists(&#x27;#User#ChibbyExit&#x27;) doautocmd User ChibbyExitendif 帮助文档：:h User 事件嵌套默认情况下，自动命令不能嵌套！如果某个自动命令执行了一个命令，这个命令再依次触发其它的事件，这是不可能的。 例如你想在每次启动 Vim 的时候自动打开你的 vimrc 文件： 1autocmd VimEnter * edit $MYVIMRC 当你启动 Vim 的时候，它会帮你打开你的 vimrc 文件，但是你很快会注意到这个文件没有任何的高亮，尽管平时它是正常可以高亮的。 问题在于你的非嵌套自动命令 :edit 不会触发“BufRead”事件，所以并不会把文件类型设置成“vim”，进而 $VIMRUNTIME/syntax/vim.vim 永远不会被引入。详细信息请参考：:au BufRead *.vim。要想完成上面所说的需求，使用下面这个命令： 1autocmd VimEnter * nested edit $MYVIMRC 帮助文档：:h autocmd-nested 剪切板如果你想在没有 GUI 支持的 Unix 系统中使用 Vim 的 &#39;clipboard&#39; 选项，则需要 +clipboard 以及可选的 +xterm_clipboard 两个特性支持。 帮助文档： 123:h &#x27;clipboard&#x27;:h gui-clipboard:h gui-selections 另外请参考：持续粘贴（为什么我每次都要设置 ‘paste’ 模式 剪贴板的使用（Windows, OSX）Windows 自带了剪贴板，OSX 则带了一个粘贴板 在这两个系统中都可以用大家习惯用的 ctrl+c / cmd+c 复制选择的文本，然后在另外一个应用中用 ctrl+v / cmd+v 进行粘贴。 需要注意的是复制的文本已经被发送到了剪贴板，所以你在粘贴复制的内容之前关闭这个应用是没有任何问题的。 每次复制的时候，都会向剪贴板寄存器 * 中写入数据。 而在 Vim 中分别使用 &quot;*y 和 &quot;*p 来进行复制（yank) 和 粘贴（paste)。 如果你不想每次操作都要指定 * 寄存器，可以在你的 vimrc 中添加如下配置： 1set clipboard=unnamed 通常情况下复制&#x2F;删除&#x2F;放入操作会往 &quot; 寄存器中写入数据，而加上了上面的配置之后 * 寄存器也会被写入同样数据，因此简单的使用 y 和 p 就可以复制粘贴了。 我再说一遍：使用上面的选项意味着每一次的复制&#x2F;粘贴，即使在同一个 Vim 窗口里，都会修改剪贴板的内容。你自己决定上面的选项是否适合。 如果你觉得输入 y 还是太麻烦的话，可以使用下面的设置把在可视模式下选择的内容发送到剪贴板： 12set clipboard=unnamed,autoselectset guioptions+=a 帮助文档： 123:h clipboard-unnamed:h autoselect:h &#x27;go_a&#x27; 剪贴板的使用（Linux, BSD, …）如果你的系统使用了 X 图形界面，事情会变得有一点不同。X 图形界面实现了 X 窗口系统协议, 这个协议在 1987 年发布的主版本 11，因此 X 也通常被称为 X11。 在 X10 版本中，剪贴缓冲区被用来实现像 clipboard 一样由 X 来复制文本，并且可以被所有的程序访问。现在这个机制在 X 中还存在，但是已经过时了，很多程序都不再使用这一机制。 近年来数据在程序之间是通过选择进行传递的。一共有三种选择，经常用到的有两种：PRIMARY 和 CLIPBOARD。 选择的工作工模大致是这样的： Program A：&lt;ctrl+c&gt; Program A：声称对 CLIPBOARD 的所有权 Program B：&lt;ctrl+v&gt; Program B：发现CLIPBOARD的所有权被Program A持有 Program B：从Program A请求数据 Program A：响应这个请求并发送数据给Program B Program B：从Program A接收数据并插入到窗口中 选择 何时使用 如何粘贴 如何在 Vim 中访问 PRIMARY 选择文本 鼠标中键, shift+insert * 寄存器 CLIPBOARD 选择文本并按 ctrl+c ctrl+v +寄存器 注意：X 服务器并不会保存选择（不仅仅是 CLIPBOARD 选择）！因此在关闭了相应的程序后，你用 ctrl+c 复制的内容将丢失。 使用 &quot;*p 来贴粘 PRIMARY 选择中的内容，或者使用 &quot;+y1G 来将整个文件的内容复制到 CLIPBOARD 选择。 如果你需要经常访问这两个寄存器，可以考虑使用如下配置： 123set clipboard^=unnamed &quot; * 寄存器&quot; 或者set clipboard^=unnamedplus &quot; + 寄存器 （^= 用来将设置的值加到默认值之前，详见：:h :set^=） 这会使得所有复制&#x2F;删除&#x2F;放入操作使用 * 或 + 寄存器代替默认的未命令寄存器 &quot;。之后你就可以直接使用 y 或 p 访问你的 X 选择了。 帮助文档： 12:h clipboard-unnamed:h clipboard-unnamedplus 打开文件时恢复光标位置如果没有这个设置，每次打开文件时光标都将定位在第一行。而加入了这个设置以后，你就可以恢复到上次关闭文件时光标所在的位置了。 将下面的配置添加到你的 vimrc 文件： 1234autocmd BufReadPost * \\ if line(&quot;&#x27;\\&quot;&quot;) &gt; 1 &amp;&amp; line(&quot;&#x27;\\&quot;&quot;) &lt;= line(&quot;$&quot;) | \\ exe &quot;normal! g`\\&quot;&quot; | \\ endif 这是通过判断之前的光标位置是否存在（文件可能被其它程序修改而导致所记录的位置已经不存在了），如果存在的话就执行 g`&quot; （转到你离开时的光标位置但是不更改跳转列表）。 这需要使用 viminfo 文件：:h viminfo-。 临时文件根据选项的不同， Vim 最多会创建 4 种工作文件。 备份文件你可以让 Vim 在将修改写入到文件之前先备份原文件。默认情况下， Vim 会保存一个备份文件但是当修改成功写入后会立即删除它（:set writebackup）。如果你想一直保留这个备份文件的话，可以使用 :set backup。而如果你想禁用备份功能的话，可以使用 :set nobackup nowritebackup。 咱们来看一下上次我在 vimrc 中改了什么： 123$ diff ~/.vim/vimrc ~/.vim/files/backup/vimrc-vimbackup390d389&lt; command! -bar -nargs=* -complete=help H helpgrep &lt;args&gt; 帮助文档：:h backup 交换文件假设你有一个非常棒的科幻小说的构思。在按照故事情节已经写了好几个小时几十万字的时候..忽然停电了！而那时你才想起来你上次保存 ~/来自外太空的邪恶入侵者.txt 是在.. 好吧，你从来没有保存过。 但是并非没有希望了！在编辑某个文件的时候， Vim 会创建一个交换文件，里面保存的是对当前文件所有未保存的修改。自己试一下，打开任意的文件，并使用 :swapname 获得当前的交换文件的保存路径。你也可以将 :set noswapfile 加入到 vimrc 中来禁用交换文件。 默认情况下，交换文件会自动保存在被编辑文件所在的目录下，文件名以 .file.swp 后缀结尾，每当你修改了超过 200 个字符或是在之前 4 秒内没有任何动作时更新它的内容，在你不再编辑这个文件的时候会被删除。你可以自己修改这些数字，详见：:h &#39;updatecount&#39; 和 :h &#39;updatetime&#39;。 而在断电时，交换文件并不会被删除。当你再次打开 vim ~/来自外太空的邪恶入侵者.txt 时， Vim 会提示你恢复这个文件。 帮助文档：:h swap-file 和 :h usr_11 撤销文件内容变更历史记录是保存在内存中的，并且会在 Vim 退出时清空。如果你想让它持久化到磁盘中，可以设置 :set undofile。这会把文件 ~/foo.c 的撤销文件保存在 ~/foo.c.un~。 帮助文档：:h &#39;undofile&#39; 和 :h undo-persistence viminfo 文件备份文件、交换文件和撤销文件都是与文本状态相关的，而 viminfo 文件是用来保存在 Vim 退出时可能会丢失的其它的信息的。包括历史记录（命令历史、搜索历史、输入历史）、寄存器内容、标注、缓冲区列表、全局变量等等。 默认情况下，viminfo 被保存在 ~/.viminfo。 帮助文档：:h viminfo 和 :h &#39;viminfo&#39; 临时文件管理设置示例如果你跟我一样，也喜欢把这些文件放到一个位置（如：~/.vim/files）的话，可以使用下面的配置： 123456789101112131415161718&quot; 如果文件夹不存在，则新建文件夹if !isdirectory($HOME.&#x27;/.vim/files&#x27;) &amp;&amp; exists(&#x27;*mkdir&#x27;) call mkdir($HOME.&#x27;/.vim/files&#x27;)endif&quot; 备份文件set backupset backupdir =$HOME/.vim/files/backup/set backupext =-vimbackupset backupskip =&quot; 交换文件set directory =$HOME/.vim/files/swap//set updatecount =100&quot; 撤销文件set undofileset undodir =$HOME/.vim/files/undo/&quot; viminfo 文件set viminfo =&#x27;100,n$HOME/.vim/files/info/viminfo 注意：如果你在一个多用户系统中编辑某个文件时， Vim 提示你交换文件已经存在的话，可能是因为有其他的用户此时正在编辑这个文件。而如果将交换文件放到自己的 home 目录的话，这个功能就失效了。因此服务器非常不建议将这些文件修改到 HOME 目录，避免多人同时编辑一个文件，却没有任何警告。 编辑远程文件Vim 自带的 netrw 插件支持对远程文件的编辑。实际上它将远程的文件通过 scp 复制到本地的临时文件中，再用那个文件打开一个缓冲区，然后在保存时把文件再复制回远程位置。 下面的命令在你本地的 VIM 配置与 SSH 远程服务器上管理员想让你使用的配置有冲突时尤其有用： 1:e scp://bram@awesome.site.com/.vimrc 如果你已经设置了 ~/.ssh/config，SSH 会自动读取这里的配置： Host awesome HostName awesome.site.com Port 1234 User bram 如果你的 ~/.ssh/config 中有以上的内容，那么下面的命令就可以正常执行了： 1:e scp://awesome/.vimrc 可以用同样的方法编辑 ~/.netrc, 详见：:h netrc-netrc。 确保你已经看过了 :h netrw-ssh-hack 和 :h g:netrw_ssh_cmd。 另外一种编辑远程文件的方法是使用 sshfs，它会用 FUSE 来挂载远程的文件系统到你本地的系统当中。 插件管理Pathogen是第一个比较流行的插件管理工具。实际上它只是修改了 runtimepath （:h &#39;rtp&#39;） 来引入所有放到该目录下的文件。你需要自己克隆插件的代码仓库到那个目录。 真正的插件管理工具会在 Vim 中提供帮助你安装或更新插件的命令。以下是一些常用的插件管理工具： dein plug vim-addon-manager vundle 多行编辑这是一种可以同时输入多行连续文本的技术。参考这个示例。 用 &lt;c-v&gt; 切换到可视块模式。然后向下选中几行，按 I 或 A （译者注：大写字母，即 shift+i 或 shift+a）然后开始输入你想要输入的文本。 在刚开始的时候可能会有些迷惑，因为文本只出现在了当前编辑的行，只有在当前的插入动作结束后，之前选中的其它行才会出现插入的文本。 举一个简单的例子：&lt;c-v&gt;3jItext&lt;esc&gt;。 如果你要编辑的行长度不同，但是你想在他们后面追加相同的内容的话，可以试一下这个：&lt;c-v&gt;3j$Atext&lt;esc&gt;。 有时你可能需要把光标放到当前行末尾之后，默认情况下你是不可能做到的，但是可能通过设置 virtualedit 选项达到目的： 1set virtualedit=all 设置之后 $10l 或 90| 都会生效，即使超过了行尾的长度。 详见 :h blockwise-examples。在开始的时候可能会觉得有些复杂，但是它很快就会成为你的第二天性的。 如果你想探索更有趣的事情，可以看看多光标 使用外部程序和过滤器免责声明：Vim 是单线程的，因此在 Vim 中以前端进程执行其它的程序时会阻止其它的一切。当然你可以使用 Vim 程序接口，如 Lua，并且使用它的多线程支持，但是在那期间， Vim 的处理还是被阻止了。Neovim 添加了任务 API 解决了此问题。 （据说 Bram 正在考虑在 Vim 中也添加任务控制。如果你使用了较新版本的的 Vim ，可以看一下 :helpgrep startjob。） 使用 :! 启动一个新任务。如果你想列出当前工作目录下的所有文件，可以使用 :!ls。 用 | 来将结果通过管道重定向，如：:!ls -l | sort | tail -n5。 没有使用范围时（译者注：范围就是 : 和 ! 之间的内容，. 表示当前行，+4 表示向下偏移 4 行，$ 表示最末行等，多行时用 , 将它们分开，如 .,$ 表示从当前行到末行），:! 会显示在一个可滚动的窗口中（译者注：在 GVim 和在终端里运行的结果稍有不同）。相反的，如果指定了范围，这些行会被过滤。这意味着它们会通过管道被重定向到过滤程序的 stdin，在处理后再通过过滤程序的 stdout 输出，用输出结果替换范围内的文本。例如：为接下来的 5 行文本添加行号，可以使用： 1:.,+4!nl -ba -w1 -s&#x27; &#x27; 由于手动添加范围很麻烦， Vim 提供了一些辅助方法以方便的添加范围。如果需要经常带着范围的话，你可以在可见模式中先选择，然后再按 : （译者注：选中后再按 ! 更方便）。还可以使用 ! 来取用一个 motion 的范围，如 !ipsort （译者注：原文为 !ip!sort ，但经过实验发现该命令执行报错，可能是因为 Vim 版本的原因造成的，新版本使用 ip 选择当前段落后自动在命令后添加了 ! ，按照作者的写法来看，可能之前的版本没有自动添加 ! ）可以将当前段落的所有行按字母表顺序进行排序。 一个使用过滤器比较好的案例是Go 语言。它的缩进语法非常个性，甚至还专门提供了一个名为 gofmt 的过滤器来对 Go 语言的源文件进行正确的缩进。Go 语言的插件通常会提供一个名为 :Fmt 的函数，这个函数就是执行了 :%!gofmt 来对整个文件进行缩进。 人们常用 :r !prog 将 prog 程序的插入放到当前行的下面，这对于脚本来说是很不错的选择，但是在使用的过程中我发现 !!ls 更加方便，它会用输出结果替换当前行的内容。（译者注：前面命令中的 prog 只是个占位符，在实际使用中需要替换成其它的程序，如 :r !ls，这就与后面的 !!ls 相对应了，两者唯一的不同是第一个命令不会覆盖当前行内容，但是第二个命令会） 帮助文档： 12:h filter:h :read! CscopeCscope 的功能比 ctags 要完善，但是只支持 C（通过设置 cscope.files 后同样支持 C++以及 Java）。 鉴于 Tag 文件只是知道某个符号是在哪里定义的，cscope 的数据库里的数据信息就多的多了： 符号是在哪里定义的？ 符号是在哪里被使用的？ 这个全局符号定义了什么？ 这个变量是在哪里被赋值的？ 这个函数在源文件的哪个位置？ 哪些函数调用了这个函数？ 这个函数调用了哪些函数？ “out of space”消息是从哪来的？ 在目录结构中当前的源文件在哪个位置？ 哪些文件引用了这个头文件？ 1. 构建数据库在你项目的根目录执行下面的命令： 1$ cscope -bqR 这条命令会在当前目录下创建三个文件：cscope&#123;,.in,.po&#125;.out 。把它们想象成你的数据库。 不幸的时 cscope 默认只分析 *.[c|h|y|l] 文件。如果你想在 Java 项目中使用 cscope ，需要这样做： 12$ find . -name &quot;*.java&quot; &gt; cscope.files$ cscope -bq 2. 添加数据库打开你新创建的数据库连接： 1:cs add cscope.out 检查连接已经创建成功： 1:cs show （当然你可以添加多个连接。） 3. 查询数据库1:cs find &lt;kind&gt; &lt;query&gt; 如：:cs find d foo 会列出 foo(...) 调用的所有函数。 Kind 说明 s symbol：查找使用该符号的引用 g global：查找该全局符号的定义 c calls：查找调用当前方法的位置 t text：查找出现该文本的位置 e egrep：使用 egrep 搜索当前单词 f file：打开文件名 i includes：查询引入了当前文件的文件 d depends：查找当前方法调用的方法 推荐一些比较方便的映射，如： 12345678nnoremap &lt;buffer&gt; &lt;leader&gt;cs :cscope find s &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;cg :cscope find g &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;cc :cscope find c &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;ct :cscope find t &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;ce :cscope find e &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;cf :cscope find f &lt;c-r&gt;=expand(&#x27;&lt;cfile&gt;&#x27;)&lt;cr&gt;&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;ci :cscope find i ^&lt;c-r&gt;=expand(&#x27;&lt;cfile&gt;&#x27;)&lt;cr&gt;$&lt;cr&gt;nnoremap &lt;buffer&gt; &lt;leader&gt;cd :cscope find d &lt;c-r&gt;=expand(&#x27;&lt;cword&gt;&#x27;)&lt;cr&gt;&lt;cr&gt; 所以 :tag （或 &lt;c-]&gt;）跳转到标签定义的文件，而 :cstag 可以达到同样的目的，同时还会打开 cscope 的数据库连接。&#39;cscopetag&#39; 选项使得 :tag 命令自动的像 :cstag 一样工作。这在你已经使用了基于标签的映射时会非常方便。 帮助文档：:h cscope MatchIt由于 Vim 是用 C 语言编写的，因此许多功能都假设使用类似 C 语言的语法。默认情况下，如果你的光标在 &#123; 或 #endif , 就可以使用 % 跳转到与之匹配的 &#125; 或 #ifdef。 Vim 自带了一个名为 matchit.vim 的插件，但是默认没有启用。启用后可以用 % 在 HTML 相匹配的标签或 VimL 的 if&#x2F;else&#x2F;endif 块之间进行跳转，它还带来了一些新的命令。 在 Vim 8 中安装12&quot; vimrcpackadd! matchit 在 Vim 7 或者更早的版本中安装12&quot;vimrcruntime macros/matchit.vim 由于 matchit 的文档很全面，我建议安装以后执行一次下面的命令： 123:!mkdir -p ~/.vim/doc:!cp $VIMRUNTIME/macros/matchit.vim ~/.vim/doc:helptags ~/.vim/doc 简短的介绍至此这个插件已经可以使用了。 参考 :h matchit-intro 来获得支持的命令以及 :h matchit-languages 来获得支持的语言。 你可以很方便的定义自己的匹配对，如： 1autocmd FileType python let b:match_words = &#x27;\\&lt;if\\&gt;:\\&lt;elif\\&gt;:\\&lt;else\\&gt;&#x27; 之后你就可以在任何的 Python 文件中使用 % （向前）或 g% （向后）在这三个片断之间跳转了。 帮助文档： 123:h matchit-install:h matchit:h b:match_words 技巧聪明地使用 n 和 Nn 与 N 的实际跳转方向取决于使用 / 还是 ? 来执行搜索，其中 / 是向后搜索，? 是向前搜索。一开始我（原作者）觉得这里很难理解。 如果你希望 n 始终为向后搜索，N 始终为向前搜索，那么只需要这样设置： 12nnoremap &lt;expr&gt; n &#x27;Nn&#x27;[v:searchforward]nnoremap &lt;expr&gt; N &#x27;nN&#x27;[v:searchforward] 聪明地使用命令行历史我（原作者）习惯用 Ctrl + p 和 Ctrl + n 来跳转到上一个&#x2F;下一个条目。其实这个操作也可以用在命令行中，快速调出之前执行过的命令。 不仅如此，你会发现 上 和 下 其实更智能。如果命令行中已经存在了一些文字，我们可以通过按方向键来匹配已经存在的内容。比如，命令行中现在是 :echo，这时候我们按 上，就会帮我们补全成 :echo &quot;Vim rocks!&quot;（前提是，之前输入过这段命令）。 当然，Vim 用户都不愿意去按方向键，事实上我们也不需要去按，只需要设置这样的映射： 12cnoremap &lt;c-n&gt; &lt;down&gt;cnoremap &lt;c-p&gt; &lt;up&gt; 这个功能，我（原作者）每天都要用很多次。 智能 Ctrl-lCtrl + l 的默认功能是清空并「重新绘制」当前的屏幕，就和 :redraw! 的功能一样。下面的这个映射就是执行重新绘制，并且取消通过 / 和 ? 匹配字符的高亮，而且还可以修复代码高亮问题（有时候，由于多个代码高亮的脚本重叠，或者规则过于复杂，Vim 的代码高亮显示会出现问题）。不仅如此，还可以刷新「比较模式」（请参阅 :help diff-mode）的代码高亮： 1nnoremap &lt;leader&gt;l :nohlsearch&lt;cr&gt;:diffupdate&lt;cr&gt;:syntax sync fromstart&lt;cr&gt;&lt;c-l&gt; 禁用错误报警声音和图标123set noerrorbellsset novisualbellset t_vb= 请参阅 Vim Wiki: Disable beeping。 快速移动当前行有时，我（原作者）想要快速把当前行上移或下移一行，只需要这样设置映射： 12nnoremap [e :&lt;c-u&gt;execute &#x27;move -1-&#x27;. v:count1&lt;cr&gt;nnoremap ]e :&lt;c-u&gt;execute &#x27;move +&#x27;. v:count1&lt;cr&gt; 这个映射，同样可以搭配数字使用，比如连续按下 2 ] e 就可以把当前行向下移动两行。 快速添加空行12nnoremap [&lt;space&gt; :&lt;c-u&gt;put! =repeat(nr2char(10), v:count1)&lt;cr&gt;&#x27;[nnoremap ]&lt;space&gt; :&lt;c-u&gt;put =repeat(nr2char(10), v:count1)&lt;cr&gt; 设置之后，连续按下 5 [ 空格 在当前行上方插入 5 个空行。 运行时检测需要的特性：+profile Vim 提供了一个内置的运行时检查功能，能够找出运行慢的代码。 :profile 命令后面跟着子命令来确定要查看什么。 如果你想查看所有的： 12345:profile start /tmp/profile.log:profile file *:profile func *&lt;do something in Vim&gt;&lt;quit Vim&gt; Vim 不断地在内存中检查信息，只在退出的时候输出出来。（Neovim 已经解决了这个问题用 :profile dump 命令） 看一下 /tmp/profile.log 文件，检查时运行的所有代码都会被显示出来，包括每一行代码运行的频率和时间。 大多数代码都是用户不熟悉的插件代码，如果你是在解决一个确切的问题，直接跳到这个日志文件的末尾，那里有 FUNCTIONS SORTED ON TOTAL TIME 和 FUNCTIONS SORTED ON SELF TIME 两个部分，如果某个 function 运行时间过长一眼就可以看到。 查看启动时间感觉 Vim 启动的慢？到了研究几个数字的时候了： 1vim --startuptime /tmp/startup.log +q &amp;&amp; vim /tmp/startup.log 第一栏是最重要的因为它显示了绝对运行时间，如果在前后两行之间时间差有很大的跳跃，那么是第二个文件太大或者含有需要检查的错误的 VimL 代码。 NUL 符用新行表示文件中的 NUL 符 （\\0），在内存中被以新行（\\n）保存，在缓存空间中显示为 ^@。 更多信息请参看 man 7 ascii 和 :h NL-used-for-Nul 。 快速编辑自定义宏这个功能真的很实用！下面的映射，就是在一个新的命令行窗口中读取某一个寄存器（默认为 *）。当你设置完成后，只需要按下 回车 即可让它生效。 在录制宏的时候，我经常用这个来更改拼写错误。 1nnoremap &lt;leader&gt;m :&lt;c-u&gt;&lt;c-r&gt;&lt;c-r&gt;=&#x27;let @&#x27;. v:register .&#x27; = &#x27;. string(getreg(v:register))&lt;cr&gt;&lt;c-f&gt;&lt;left&gt; 只需要连续按下 leader m 或者 \" leader m 就可以调用了。 请注意，这里之所以要写成 &lt;c-r&gt;&lt;c-r&gt; 是为了确保 &lt;c-r&gt; 执行了。请参阅 :h c_^R^R 快速跳转到源(头)文件这个技巧可以用在多种文件类型中。当你从源文件或者头文件中切换到其他文件的时候，这个技巧可以设置「文件标记」（请参阅 :h marks），然后你就可以通过连续按下 ' C 或者 ' H 快速跳转回去（请参阅 :h &#39;A）。 12autocmd BufLeave *.&#123;c,cpp&#125; mark Cautocmd BufLeave *.h mark H 注意：由于这个标记是设置在 viminfo 文件中，因此请先确认 :set viminfo? 中包含了 :h viminfo-&#39;。 在 GUI 中快速改变字体大小印象中，我（原作者）记得一下代码是来自 tpope’s 的配置文件： 12command! Bigger :let &amp;guifont = substitute(&amp;guifont, &#x27;\\d\\+$&#x27;, &#x27;\\=submatch(0)+1&#x27;, &#x27;&#x27;)command! Smaller :let &amp;guifont = substitute(&amp;guifont, &#x27;\\d\\+$&#x27;, &#x27;\\=submatch(0)-1&#x27;, &#x27;&#x27;) 根据模式改变光标类型我（原作者）习惯在普通模式下用块状光标，在插入模式下用条状光标（形状类似英文 “I” 的样子），然后在替换模式中使用下划线形状的光标。 123456789if empty($TMUX) let &amp;t_SI = &quot;\\&lt;Esc&gt;]50;CursorShape=1\\x7&quot; let &amp;t_EI = &quot;\\&lt;Esc&gt;]50;CursorShape=0\\x7&quot; let &amp;t_SR = &quot;\\&lt;Esc&gt;]50;CursorShape=2\\x7&quot;else let &amp;t_SI = &quot;\\&lt;Esc&gt;Ptmux;\\&lt;Esc&gt;\\&lt;Esc&gt;]50;CursorShape=1\\x7\\&lt;Esc&gt;\\\\&quot; let &amp;t_EI = &quot;\\&lt;Esc&gt;Ptmux;\\&lt;Esc&gt;\\&lt;Esc&gt;]50;CursorShape=0\\x7\\&lt;Esc&gt;\\\\&quot; let &amp;t_SR = &quot;\\&lt;Esc&gt;Ptmux;\\&lt;Esc&gt;\\&lt;Esc&gt;]50;CursorShape=2\\x7\\&lt;Esc&gt;\\\\&quot;endif 原理很简单，就是让 Vim 在进入和离开插入模式的时候，输出一些序列，请参考 escape sequence。Vim 与终端之间的中间层，比如 tmux 会处理并执行上面的代码。 但上面这个还是有一个缺点的。终端环境的内部原理不尽相同，对于序列的处理方式也稍有不同。因此，上面的代码可能无法在你的环境中运行。甚至，你的运行环境也有可能不支持其他光标形状，请参阅你的 Vim 运行环境的文档。 好消息是，上面这个代码，可以在 iTerm2 中完美运行。 防止水平滑动的时候失去选择如果你选中了一行或多行，那么你可以用 &lt; 或 > 来调整他们的缩进。但在调整之后就不会保持选中状态了。 你可以连续按下 g v 来重新选中他们，请参考 :h gv。因此，你可以这样来配置映射： 12xnoremap &lt; &lt;gvxnoremap &gt; &gt;gv 设置好之后，在可视模式中使用 &gt;&gt;&gt;&gt;&gt; 就不会再出现上面提到的问题了。 重新载入保存文件通过自动命令，你可以在保存文件的同时触发一些其他功能。比如，如果这个文件是一个配置文件，那么就重新载入；或者你还可以对这个文件进行代码风格检查。 12autocmd BufWritePost $MYVIMRC source $MYVIMRCautocmd BufWritePost ~/.Xdefaults call system(&#x27;xrdb ~/.Xdefaults&#x27;) 更加智能的当前行高亮我（原作者）很喜欢「当前行高亮」（请参阅 :h cursorline）这个功能，但我只想让这个效果出现在当前窗口，而且在插入模式中关闭这个效果： 12autocmd InsertLeave,WinEnter * set cursorlineautocmd InsertEnter,WinLeave * set nocursorline 更快的关键字补全关键字补全（&lt;c-n&gt; 或 &lt;c-p&gt;）功能的工作方式是，无论 &#39;complete&#39; 设置中有什么，它都会尝试着去补全。这样，一些我们用不到的标签也会出现在补全列表中。而且，它会扫描很多文件，有时候运行起来非常慢。如果你不需要这些，那么完全可以像这样把它们禁用掉： 12set complete-=i &quot; disable scanning included filesset complete-=t &quot; disable searching tags 改变颜色主题的默认外观如果你想让状态栏在颜色主题更改后依然保持灰色，那么只需要这样设置： 1autocmd ColorScheme * highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE 同理，如果你想让某一个颜色主题（比如 “lucius”）的状态栏为灰色（请使用 :echo color_name 来查看当前可用的所有颜色主题）： 1autocmd ColorScheme lucius highlight StatusLine ctermbg=darkgray cterm=NONE guibg=darkgray gui=NONE 命令下面的命令都比较有用，最好了解一下。用 :h :&lt;command name&gt; 来了解更多关于它们的信息，如：:h :global。 :global 和 :vglobal - 在所有匹配行执行命令在所有符合条件的行上执行某个命令。如： :global /regexp/ print 会在所有包含 “regexp” 的行上执行 print 命令（译者注：regexp 有正则表达式的意思，该命令同样支持正则表达式，在所有符合正则表达式的行上执行指定的命令）。 趣闻：你们可能都知道老牌的 grep 命令，一个由 Ken Thompson 编写的过滤程序。它是干什么用的呢？它会输出所有匹配指定正则表达式的行！现在猜一下 :global /regexp/ print 的简写形式是什么？没错！就是 :g/re/p 。 Ken Thompsom 在编写 grep 程序的时候是受了 vi :global 的启发。（译者注： https://robots.thoughtbot.com/how-grep-got-its-name） 既然它的名字是 :global，理应仅作用在所有行上，但是它也是可以带范围限制的。假设你想使用 :delete 命令删除从当前行到下一个空行（由正则表达式 ^$ 匹配）范围内所有包含 “foo” 的行： 1:,/^$/g/foo/d 如果要在所有 不 匹配的行上执行命令的话，可以使用 :global! 或是它的别名 :vglobal （ V 代表的是 inVerse ）。 :normal 和 :execute - 脚本梦之队这两个命令经常在 Vim 的脚本里使用。 借助于 :normal 可以在命令行里进行普通模式的映射。如：:normal! 4j 会令光标下移 4 行（由于加了”!”，所以不会使用自定义的映射 “j”）。 需要注意的是 :normal 同样可以使用范围数（译者注：参考 :h range 和 :h :normal-range 了解更多），故 :%norm! Iabc 会在所有行前加上 “abc”。 借助于 :execute 可以将命令和表达式混合在一起使用。假设你正在编辑一个 C 语言的文件，想切换到它的头文件： 1:execute &#x27;edit&#x27; fnamemodify(expand(&#x27;%&#x27;), &#x27;:r&#x27;) . &#x27;.h&#x27; （译者注：头文件为与与源文件同名但是扩展名为 .h 的文件。上面的命令中 expand 获得当前文件的名称，fnamemodify 获取不带扩展名的文件名，再连上 ‘.h’ 就是头文件的文件名了，最后在使用 edit 命令打开这个头文件。） 这两个命令经常一起使用。假设你想让光标下移 n 行： 12:let n = 4:execute &#x27;normal!&#x27; n . &#x27;j&#x27; 重定向消息许多命令都会输出消息，:redir 用来重定向这些消息。它可以将消息输出到文件、寄存器或是某个变量中。 12345678910&quot; 将消息重定向到变量 `neatvar` 中:redir =&gt; neatvar&quot; 打印所有寄存器的内容:reg&quot; 结束重定向:redir END&quot; 输出变量:echo neatvar&quot; 恶搞一下，我们把它输出到当前缓冲区:put =neatvar 再 Vim 8 中，可以更简单的方式即位： :put =execute(&#39;reg&#39;) （译者注：原文最后一条命令是 :put =nicevar 但是实际会报变量未定义的错误）（实测 neovim&#x2F;vim8 下没问题） 帮助文档：:h :redir 调试常规建议如果你遇到了奇怪的行为，尝试用这个命令重现它： vim -u NONE -N 这样会在不引用 vimrc（默认设置）的情况下重启 vim，并且在 nocompatible 模式下（使用 vim 默认设置而不是 vi 的）。（搜索 :h --noplugin 命令了解更多启动加载方式） 如果仍旧能够出现该错误，那么这极有可能是 vim 本身的 bug，请给 vim_dev 发送邮件反馈错误，多数情况下问题不会立刻解决，你还需要进一步研究 许多插件经常会提供新的（默认的&#x2F;自动的）操作。如果在保存的时候发生了，那么请用 :verb au BufWritePost 命令检查潜在的问题 如果你在使用一个插件管理工具，将插件行注释调，再进行调试。 问题还没有解决？如果不是插件的问题，那么肯定是你的自定义的设置的问题，可能是你的 options 或 autocmd 等等。 到了一行行代码检查的时候了，不断地排除缩小检查范围知道你找出错误，根据二分法的原理你不会花费太多时间的。 在实践过程中，可能就是这样，把 :finish 放在你的 vimrc 文件中间，Vim 会跳过它之后的设置。如果问题还在，那么问题就出在:finish之前的设置中，再把:finish放到前一部分设置的中间位置。否则问题就出现在它后面的半部分设置，那么就把:finish放到后半部分的中间位置。不断的重复即可找到。 调整日志等级Vim 现在正在使用的另一个比较有用的方法是增加 debug 信息输出详细等级。现在 Vim 支持 9 个等级，可以用:h &#39;verbose&#39;命令查看。 1234:e /tmp/foo:set verbose=2:w:set verbose=0 这可以显示出所有引用的文件、没有变化的文件或者各种各样的作用于保存的插件。 如果你只是想用简单的命令来提高等级，也是用 :verbose ，放在其他命令之前，通过计数来指明等级，默认是 1. 1234:verb set verbose&quot; verbose=1:10verb set verbose&quot; verbose=10 通常用等级 1 来显示上次从哪里设置的选项 12:verb set ai?&quot; Last set from ~/.vim/vimrc 一般等级越高输出信息月详细。但是不要害怕，亦可以把输出导入到文件中： 1:set verbosefile=/tmp/foo | 15verbose echo &quot;foo&quot; | vsplit /tmp/foo 你可以一开始的时候就打开 verbosity，用 -V 选项，它默认设置调试等级为 10。 例如：vim -V5 查看启动日志查看运行时日志Vim 脚本调试如果你以前使用过命令行调试器的话，对于:debug命令你很快就会感到熟悉。 只需要在任何其他命令之前加上:debug就会让你进入调试模式。也就是，被调试的 Vim 脚本会在第一行停止运行，同时该行会被显示出来。 想了解可用的 6 个调试命令，可以查阅:h &gt;cont和阅读下面内容。需要指出的是，类似 gdb 和其他相似调试器，调试命令可以使用它们的简短形式：c、 q、n、s、 i和 f。 除了上面的之外，你还可以自由地使用任何 Vim 的命令。比如，:echo myvar，该命令会在当前的脚本代码位置和上下文上被执行。 只需要简单使用:debug 1，你就获得了REPL调试特性。 当然，调试模式下是可以定义断点的，不然的话每一行都去单步调试就会十分痛苦。（断点之所以被叫做断点，是因为运行到它们的时候，运行就会停止下来。因此，你可以利用断点跳过自己不感兴趣的代码区域）。请查阅:h :breakadd、 :h :breakdel和 :h :breaklist获取更多细节。 假设你需要知道你每次在保存一个文件的时候有哪些代码在运行： 1234567891011121314151617:au BufWritePost&quot; signify BufWritePost&quot; * call sy#start():breakadd func *start:w&quot; Breakpoint in &quot;sy#start&quot; line 1&quot; Entering Debug mode. Type &quot;cont&quot; to continue.&quot; function sy#start&quot; line 1: if g:signify_locked&gt;s&quot; function sy#start&quot; line 3: endif&gt;&quot; function sy#start&quot; line 5: let sy_path = resolve(expand(&#x27;%:p&#x27;))&gt;q:breakdel * 正如你所见，使用&lt;cr&gt;命令会重复之前的调试命令，也就是在该例子中的s命令。 :debug命令可以和verbose选项一起使用。 语法文件调试语法文件由于包含错误的或者复制的正则表达式，常常会使得 Vim 的运行较慢。如果 Vim 在编译的时候包含了+profile feature特性，就可以给用户提供一个超级好用的:syntime命令。 1234:syntime on&quot; 多次敲击&lt;c-l&gt;来重绘窗口，这样的话就会使得相应的语法规则被重新应用一次:syntime off:syntime report 输出结果包含了很多的度量维度。比如，你可以通过结果知道哪些正则表达式耗时太久需要被优化；哪些正则表达式一直在别使用但重来没有一次成功匹配。 请查阅:h :syntime。 杂项附加资源 资源名称 简介 七个高效的文本编辑习惯 作者：Bram Moolenaar（即 Vim 的作者） 七个高效的文本编辑习惯 2.0（PDF 版） 同上 IBM DeveloperWorks: 使用脚本编写 Vim 编辑器 Vim 脚本编写五辑 《漫漫 Vim 路》 使用魔抓定制 Vim 插件 《 Vim 实践 (第 2 版)》 轻取 Vim 最佳书籍 Vimcasts.org Vim 录屏演示 为什么是个脚本都用 vi？ 常见误区释疑 你不爱 vi，所以你不懂 Vim 简明,扼要,准确的干货 Vim 配置集合目前，网上有很多流行 Vim 配置集合，对于 Vim 配置集合，个人认为有利有弊。对于维护的比较好的配置，比如 SpaceVim 还是值得尝试的，可以节省很多自行配置的时间。当然，网上还有很多其他很流行的配置，比如： k-vim amix’s vimrc janus 常见问题编辑小文件时很慢有两个因素对性能影响非常大： 过于复杂的 正则表达式 。尤其是 Ruby 的语法文件，以前会造成性能下降。（见调试语法文件） 屏幕重绘 。有一些功能会强制重绘所有行。 典型肇事者 原因 解决方案 :set cursorline 会导致所有行重绘 :set nocursorline :set cursorcolumn 会导致所有行重绘 :set nocursorcolumn :set relativenumber 会导致所有行重绘 :set norelativenumber :set foldmethod=syntax 如果语法文件已经很慢了，这只会变得更慢 :set foldmethod=manual，:set foldmethod=marker 或者使用快速折叠插件 :set synmaxcol=3000 由于内部表示法，Vim 处理比较长的行时会有问题。让它高亮到 3000 列…… :set synmaxcol=200 matchparen.vim Vim 默认加载的插件，用正则表达式查找配对的括号 禁用插件：:h matchparen 注意：只有在你真正遇到性能问题的时候才需要做上面的调整。在大多数情况下使用上面提到的选项是完全没有问题的。 编辑大文件的时候很慢Vim 处理大文件最大的问题就是它会一次性读取整个文件。这么做是由于缓冲区的内部机理导致的（在 vim_dev 中讨论）。 如果只是想查看的话，tail hugefile | vim - 是一个不错的选择。 如果你能接受没有语法高亮，并且禁用所有插件和设置的话，使用： 1$ vim -u NONE -N 这将会使得跳转变快很多，尤其是省去了基于很耗费资源的正则表达式的语法高亮。你还可以告诉 Vim 不要使用交换文件和 viminfo 文件，以避免由于写这些文件而造成的延时： 1$ vim -n -u NONE -i NONE -N 简而言之，尽量避免使用 Vim 写过大的文件。 持续粘贴（为什么我每次都要设置 ‘paste’ 模式）持续粘贴模式让终端模拟器可以区分输入内容与粘贴内容。 你有没有遇到过往 Vim 里粘贴代码之后被搞的一团糟？ 这在你使用 cmd+v、shirt-insert、middle-click 等进行粘贴的时候才会发生。因为那样的话你只是向终端模拟器扔了一大堆的文本。Vim 并不知道你刚刚是粘贴的文本，它以为你在飞速的输入。于是它想缩进这些行但是失败了。 这明显不是个问题，如果你用 Vim 的寄存器粘贴，如：&quot;+p ，这时 Vim 就知道了你在粘贴，就不会导致格式错乱了。 使用 :set paste 就可以解决这个问题正常进行粘贴。见 :h &#39;paste&#39; 和 :h &#39;pastetoggle&#39; 获取更多信息。 如果你受够了每次都要设置 &#39;paste&#39; 的话，看看这个能帮你自动设置的插件：bracketed-paste。 点此查看该作者对于这个插件的更多描述。 Neovim 尝试把这些变得更顺畅，如果终端支持的话，它会自动开启持续粘贴模式，无须再手动进行切换。 在终端中按 ESC 后有延时如果你经常使用命令行，那么肯定要接触 终端模拟器 ，如 xterm、gnome-terminal、iTerm2 等等（与实际的终端不同）。 终端模拟器与他们的祖辈一样，使用 转义序列 （也叫 控制序列 ）来控制光标移动、改变文本颜色等。转义序列就是以转义字符开头的 ASCII 字符串（用脱字符表示法表示成 ^[ ）。当遇到这样的字符串后，终端模拟器会从终端信息数据库中查找对应的动作。 为了使用问题更加清晰，我会先来解释一下什么是映射超时。在映射存在歧义的时候就会产生映射超时： 12:nnoremap ,a :echo &#x27;foo&#x27;&lt;cr&gt;:nnoremap ,ab :echo &#x27;bar&#x27;&lt;cr&gt; 上面的例子中两个映射都能正常工作，但是当输入 ,a 之后，Vim 会延时 1 秒，因为它要确认用户是否还要输入那个 b。 转义序列会产生同样的问题： &lt;esc&gt; 作为返回普通模式或取消某个动作的按键而被大量使用 光标键使用转义序列进行的编码 Vim 期望 Alt （也叫作 Mate Key ）会发送一个正确的 8-bit 编码的高位，但是许多终端模拟器并不支持这个（也可能默认没有启用），而只是发送一个转义序列作为代替。 你可以这样测试上面所提到的事情： vim -u NONE -N 然后输入 i&lt;c-v&gt;&lt;left&gt; ，你会看到一个以 ^[ 开头的字符串，表明这是一个转义序列，^[ 就是转义字符。 简而言之，Vim 在区分录入的 &lt;esc&gt; 和转义序列的时候需要一定的时间。 默认情况下，Vim 用 :set timeout timeoutlen=1000，就是说它会用 1 秒的时间来区分有歧义的映射 以及 按键编码。这对于映射来说是一个比较合理的值，但是你可以自行定义按键延时的长短，这是解决该问题最根本的办法： 1234set timeout &quot; for mappingsset timeoutlen=1000 &quot; default valueset ttimeout &quot; for key codesset ttimeoutlen=10 &quot; unnoticeable small value 在 :h ttimeout 里你可以找到一个关于这些选项之间关系的小表格。 而如果你在 tmux 中使用 Vim 的话，别忘了把下面的配置加入到你的 ~/.tmux.conf文件中： set -sg escape-time 0 无法重复函数中执行的搜索 在命令中的搜索（/、:substitute 等）内容会改变“上次使用的搜索内容”。（它保存在/寄存器中，用 :echo @/ 可以输出它里面的内容） 简单的文本变化可以通过 . 重做。（它保存在 . 寄存器，用 :echo @. 可以输出它的内容） 而在你在函数中进行这些操作的时候，一切就会变得不同。因此你不能用 N&#x2F;n 查找某个函数刚刚查找的内容，也不能重做函数中对文本的修改。 帮助文档：:h function-search-undo。 进阶阅读 Vim 插件开发指南 常用插件列表 加入我们可以协助我们核对翻译，或者从章节列表中认领章节进行翻译。","categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"}],"tags":[{"name":"Vim","slug":"Vim","permalink":"https://blog.jugg.xyz/tags/Vim/"}]},{"title":"LAMP环境搭建","slug":"ops/LAMP","date":"2017-05-19T06:43:13.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2017/05/19/ops/LAMP/","permalink":"https://blog.jugg.xyz/2017/05/19/ops/LAMP/","excerpt":"","text":"LAMP是指一组通常一起使用来运行动态网站或者服务器的自由软件名称首字母缩写： &emsp;&emsp;Linux，操作系统 &emsp;&emsp;Apache，网页服务器 &emsp;&emsp;MariaDB或MySQL，数据库管理系统（或者数据库服务器） &emsp;&emsp;PHP、Perl或Python，脚本语言 ——摘自维基百科 软件安装这里我们选择的是 Linux+Apache+MariaDB+PHP。 Arch Linux安装LAMP非常简单，所有的包官方源里都有，所以： # pacman -S apache php php-apache mariadb libmariadbclient mariadb-clients 一条命令就将所有需要的软件直接安装好。 启动PHP配置PHP&emsp;&emsp;首先，我们来配置PHP。 &emsp;&emsp;php-apache 中包含的 libphp7.so 不支持 mod_mpm_event，仅支持 mod_mpm_prefork。所以需要在 &#x2F;etc&#x2F;httpd&#x2F;conf&#x2F;httpd.conf 中注释掉: #LoadModule mpm_event_module modules/mod_mpm_event.so &emsp;&emsp;并取消下面行的注释: LoadModule mpm_prefork_module modules/mod_mpm_prefork.so &emsp;&emsp;此外，将这一行放在LoadModule列表中 LoadModule dir_module modules&#x2F;mod_dir.so 之后的任意地方： LoadModule php7_module modules/libphp7.so &emsp;&emsp;将这一行放到Include列表的末尾： Include conf/extra/php7_module.conf 测试PHP&emsp;&emsp;要测试PHP，在 apache 文档根目录中创建test.php文件，在其中写入： &lt;?php phpinfo(); ?&gt; &emsp;&emsp;然后访问启动apache服务，访问 http://localhost/test.php。若成功启动的话，应如下图所示： PHP 启动MariaDB初始化MariaDB&emsp;&emsp;首先，我们必须必须运行下面这条命令： # mysql_install_db --user=mysql --basedir=/usr --datadir=/var/lib/mysql &emsp;&emsp;启动 mysqld 守护进程，运行安装脚本，然后重新启动守护进程： # systemctl start mysqld # mysql_secure_installation # systemctl restart mysqld &emsp;&emsp;安装脚本的内容是配置数据库root密码和删除匿名权限还有远程权限之类的，大家各凭所需去选择就行。 配置MariaDB&emsp;&emsp;运行完脚本后便可以使用设置好的root账号登陆MariaDB： # mysql -p -u root &emsp;&emsp;下面直接改下&#x2F;etc&#x2F;php&#x2F;php.ini，取消这两行的注释： extension=pdo_mysql.so extension=mysqli.so &emsp;&emsp;本次搭建便已经完成了,这时再重启下httpd.service 服务便可。 &emsp;&emsp;下面再额外介绍下MariaDB的其他配置。 创建用户&emsp;&emsp;以下是创建一个密码为’some_pass’的’monty’用户的示例，并赋予 mydb 完全操作权限： Mydb 禁用远程访问&emsp;&emsp;MariaDB 服务器默认可从网络访问。如果只有本机需要 MariaDB，可以通过不监听 TCP 端口 3306 来增强安全性。要拒绝远程连接，取消注释 &#x2F;etc&#x2F;mysql&#x2F;my.cnf 中以下这行： skip-networking 为数据库使用 UTF-8 编码&emsp;&emsp;在 &#x2F;etc&#x2F;mysql&#x2F;my.cnf 的 mysqld 下, 添加: [mysqld] init_connect = &#39;SET collation_connection = utf8_general_ci,NAMES utf8&#39; collation_server = utf8_general_ci character_set_client = utf8 character_set_server = utf8 结语&emsp;&emsp;额😂，还是不滥竽充数了，Arch 的Wiki实在是太全了，一开始是打算参考Wiki写这篇博客，到后面几乎是直接copy了。 &emsp;&emsp;这篇就此结束吧，回头应该还会补上LNMP搭建，另外再推荐下官方Wiki，比我这个要全并且直观多了，Wiki不愧是Archer的一大财富。 Apache PHP MySQL","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Apache","slug":"Apache","permalink":"https://blog.jugg.xyz/tags/Apache/"},{"name":"Mariadb","slug":"Mariadb","permalink":"https://blog.jugg.xyz/tags/Mariadb/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jugg.xyz/tags/PHP/"},{"name":"Archlinux","slug":"Archlinux","permalink":"https://blog.jugg.xyz/tags/Archlinux/"}]},{"title":"用git服务器和hexo搭建博客","slug":"ops/Git-And-Hexo","date":"2017-05-15T06:43:13.000Z","updated":"2024-03-11T18:14:54.495Z","comments":true,"path":"2017/05/15/ops/Git-And-Hexo/","permalink":"https://blog.jugg.xyz/2017/05/15/ops/Git-And-Hexo/","excerpt":"","text":"Git安装 git 安装非常简单，几乎所有的发行版都能在官方源找到，直接用包管理器下载即可。由于我的 vps 使用的 debian ，所以： #apt install git Git使用 Git仓库初始化 git 的初始化仓库命令是 git init，git 服务器一般都会带上 –bare 参数，这样不会在服务器上生成工作目录，不过由于我的需求是通过 git 同步 hexo 站点，所以： #git init weibo 当然，在此之前还要创建个 git 用户，最好把仓库放在git用户有权限的目录下或者用root创建目录，再 chown 给 git 用户。 Git同步 我的需求是 git+nginx+hexo ，完成本地编写网页，再通过 git 来 push 到 nginx 目录下。所以上一步的初始化工作就默认是在 nginx 的目录下完成的。 首先我们要修改服务器上的两个文件，一个是 .git&#x2F;config ，因为默认的配置是不允许 push 操作的，这和我们的需求不同，需要添加如下代码： [receive] denyCurrentBranch = ignore 解决了不能 push 的问题后，还要解决一个不能同步的问题，因为git服务器的主要作用还是共享数据，所以本地工作目录的文件在别的设备 push 上来后并不会即时同步，必须要手动输入 git reset –hard 才能同步，为了让 git 自动同步 push 内容到 work directory 这里就要用到 git 的 hooks 功能，也就是钩子。 仓库的 .git 目录下有一个 hooks 目录，在仓库数据遭遇改变时，hooks下的脚本就会自动执行。所以我们要在这个目录下创建一个新的脚本： root@vultr ~www/html/weibo (git)-[master] # cat .git/hooks/post-receive #!/bin/bash git --work-tree=/var/www/html/weibo checkout -f 然后再确定此文件归属 git 用户，还要给予他可执行权限： # chown git:git post-receive # chmod +x post-receive OK了，现在要开始在本地搭建hexo站点，这个非常简单，暂不赘述。搭建完后，使用 hexo g 生成静态文件，再进入静态文件目录 clone 下服务端的仓库： # git clone git@sieke.lt:/var/www/html/weibo 接下来就很简单了，把hexo生成的静态页面再 push 上远程仓库，hooks会自动让仓库的工作目录自动同步 push 内容，一个 git+nginx+hexo 的组合就这么完成了。 最后顺便说一下 push 过程(ps.以readme.txt为例.)： # git add readme.txt # git commit -m &quot;此处填写改动声明。&quot; # git push origin master happy(´▽&#96;ʃ♡ƪ)","categories":[{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://blog.jugg.xyz/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jugg.xyz/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.jugg.xyz/tags/Nginx/"}]}],"categories":[{"name":"转载","slug":"转载","permalink":"https://blog.jugg.xyz/categories/%E8%BD%AC%E8%BD%BD/"},{"name":"运维","slug":"运维","permalink":"https://blog.jugg.xyz/categories/%E8%BF%90%E7%BB%B4/"},{"name":"前端","slug":"前端","permalink":"https://blog.jugg.xyz/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"startups","slug":"startups","permalink":"https://blog.jugg.xyz/tags/startups/"},{"name":"Linux","slug":"Linux","permalink":"https://blog.jugg.xyz/tags/Linux/"},{"name":"Ceph","slug":"Ceph","permalink":"https://blog.jugg.xyz/tags/Ceph/"},{"name":"Python","slug":"Python","permalink":"https://blog.jugg.xyz/tags/Python/"},{"name":"Limits","slug":"Limits","permalink":"https://blog.jugg.xyz/tags/Limits/"},{"name":"Shell","slug":"Shell","permalink":"https://blog.jugg.xyz/tags/Shell/"},{"name":"UNIX","slug":"UNIX","permalink":"https://blog.jugg.xyz/tags/UNIX/"},{"name":"Docker","slug":"Docker","permalink":"https://blog.jugg.xyz/tags/Docker/"},{"name":"MySQL","slug":"MySQL","permalink":"https://blog.jugg.xyz/tags/MySQL/"},{"name":"HTTP","slug":"HTTP","permalink":"https://blog.jugg.xyz/tags/HTTP/"},{"name":"数据通信","slug":"数据通信","permalink":"https://blog.jugg.xyz/tags/%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1/"},{"name":"网络协议","slug":"网络协议","permalink":"https://blog.jugg.xyz/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"},{"name":"Windows","slug":"Windows","permalink":"https://blog.jugg.xyz/tags/Windows/"},{"name":"Node.js","slug":"Node-js","permalink":"https://blog.jugg.xyz/tags/Node-js/"},{"name":"PWA","slug":"PWA","permalink":"https://blog.jugg.xyz/tags/PWA/"},{"name":"Vim","slug":"Vim","permalink":"https://blog.jugg.xyz/tags/Vim/"},{"name":"Apache","slug":"Apache","permalink":"https://blog.jugg.xyz/tags/Apache/"},{"name":"Mariadb","slug":"Mariadb","permalink":"https://blog.jugg.xyz/tags/Mariadb/"},{"name":"PHP","slug":"PHP","permalink":"https://blog.jugg.xyz/tags/PHP/"},{"name":"Archlinux","slug":"Archlinux","permalink":"https://blog.jugg.xyz/tags/Archlinux/"},{"name":"Git","slug":"Git","permalink":"https://blog.jugg.xyz/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"https://blog.jugg.xyz/tags/Hexo/"},{"name":"Nginx","slug":"Nginx","permalink":"https://blog.jugg.xyz/tags/Nginx/"}]}